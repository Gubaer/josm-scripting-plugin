<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"clipboard.js.html":{"id":"clipboard.js.html","title":"Source: clipboard.js","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: clipboard.js /** * Provides access to the system clipboard * * @module clipboard */ /* global Java */ /** * Set or get the clipboard content as text * * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;get&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Replies the clipboard content as text or &lt;code&gt;undefined&lt;/code&gt;, * if no clipboard content is available or if it can't be converted to a * string.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;set&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Sets the clipboard content&lt;/dd&gt; * &lt;/dl&gt; * * @example * const clipboard = require('clipboard') * // set the clipboard content * clipboard.text = 'Hello World!' * * @property {string} text clipboard content as text * @name text * @summary Set or get the clipboard content as text * @static */ Object.defineProperty(exports, 'text', { enumerable: true, get: function () { const Toolkit = Java.type('java.awt.Toolkit') const DataFlavor = Java.type('java.awt.datatransfer.DataFlavor') const transferable = Toolkit.getDefaultToolkit() .getSystemClipboard().getContents(null) try { if (transferable &amp;&amp; transferable.isDataFlavorSupported(DataFlavor.stringFlavor)) { return transferable.getTransferData(DataFlavor.stringFlavor) } } catch (e) { } return undefined }, set: function (value) { const StringSelection = Java.type('java.awt.datatransfer.StringSelection') const Toolkit = Java.type('java.awt.Toolkit') Toolkit.getDefaultToolkit().getSystemClipboard().setContents( new StringSelection(String(value || '')), null ) } }) × Search results Close "},"josm.js.html":{"id":"josm.js.html","title":"Source: josm.js","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm.js /** * This module is auto-loaded by the scripting plugin. It provides the * implementation of the global &lt;code&gt;josm&lt;/code&gt; object. * * @module josm */ /* global require */ /* global Java */ /* ScriptingPlugin */ const Version = Java.type('org.openstreetmap.josm.data.Version') const JOptionPane = Java.type('javax.swing.JOptionPane') const HelpAwareOptionPane = Java.type('org.openstreetmap.josm.gui.HelpAwareOptionPane') const MainApplication = Java.type('org.openstreetmap.josm.gui.MainApplication') const util = require('josm/util') const layers = require('josm/layers') const { MenuBar } = require('josm/ui/menu') /** * Replies the current JOSM version string. * * @example * josm.alert(josm.version); * * @property {string} version the JOSM version * @readOnly * @static * @name version * @summary JOSM version string */ Object.defineProperty(exports, 'version', { enumerable: true, get: function () { return Version.getInstance().getVersionString() } }) /** * Replies the layers object. * * @example * josm.alert('num layers: ' + josm.layers.length) * * // name of first layer * josm.alert('num layers: ' + josm.layers.get(0).name) * * @readOnly * @name layers * @static * @property {module:josm/layers} layers the layers object * @summary accessor for JOSM layers */ Object.defineProperty(exports, 'layers', { enumerable: true, get: function () { return layers } }) /** * Displays an alert window with a message * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;alert(message)&lt;/code&gt;&lt;dt&gt; * &lt;dd&gt;Displays an information message with an OK button.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;alert(message, ?options)&lt;/code&gt;&lt;dt&gt; * &lt;dd&gt;Displays a message. The look and feel of the alert window depends on * the &lt;var&gt;options&lt;/var&gt;. The following options are supported: * &lt;dl&gt; * &lt;dt&gt;&lt;code&gt;title&lt;/code&gt;:string&lt;/dt&gt; * &lt;dd&gt;(optional) the window title. A string is expected. Empty string * if missing.&lt;/dt&gt; * * &lt;dd&gt;&lt;code&gt;messageType&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;(optional) the message type. Use one of the following values: * &lt;ul&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.INFORMATION_MESSAGE, * \"info\",\"information\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.ERROR_MESSAGE, * \"error\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.WARNING_MESSAGE, * \"warning\", \"warn\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.QUESTION_MESSAGE, * \"question\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.PLAIN_MESSAGE, * \"plain\"&lt;/li&gt; * &lt;/ul&gt; * Default value is * {@class javax.swing.JOptionPane}.INFORMATION_MESSAGE. * String values are not case sensitive and leading and * trailing white space is removed. * &lt;/dd&gt; * &lt;/dl&gt; * &lt;/dd&gt; * &lt;/dl&gt; * * @example * // display an information alert * josm.alert('Hello World!') * * // display an error alert * josm.alert('Got an error', { * title: 'Error Alert', * messageType: 'error' * }) * * @summary display a message * @param {string} message the message * @function * @static */ exports.alert = function () { const map = { information: JOptionPane.INFORMATION_MESSAGE, info: JOptionPane.INFORMATION_MESSAGE, error: JOptionPane.ERROR_MESSAGE, warning: JOptionPane.WARNING_MESSAGE, warn: JOptionPane.INFORMATION_MESSAGE, question: JOptionPane.QUESTION_MESSAGE, plain: JOptionPane.PLAIN_MESSAGE } function titleFromOptions (options) { return util.isString(options.title) ? options.title : '' } function messageTypeFromOptions (options) { if (util.isNumber(options.messageType)) { const mt = options.messageType for (const key in map) { if (!util.hasProp(map, key)) continue if (mt === map[key]) return mt } return JOptionPane.INFORMATION_MESSAGE } else if (util.isString(options.messageType)) { const opt = util.trim(options.messageType).toLowerCase() const ret = map[opt] return ret !== undefined ? ret : JOptionPane.INFORMATION_MESSAGE } return JOptionPane.INFORMATION_MESSAGE } switch (arguments.length) { case 0: return case 1: HelpAwareOptionPane.showOptionDialog(MainApplication.getMainFrame(), arguments[0], '', JOptionPane.INFORMATION_MESSAGE, null) return default: { if (typeof arguments[1] !== 'object') { HelpAwareOptionPane.showOptionDialog(MainApplication.getMainFrame(), arguments[0], '', JOptionPane.INFORMATION_MESSAGE, null) return } const title = titleFromOptions(arguments[1]) const messageType = messageTypeFromOptions(arguments[1]) HelpAwareOptionPane.showOptionDialog(MainApplication.getMainFrame(), arguments[0], title, messageType, null) } } } /** * Opens one or more files in JOSM. * * Accepts a variable number of files. Each argument is either a string * (a file name) or a {@class java.io.File}. * * Creates and opens layers in JOSM, depending on the kind of file opened: * * &lt;ul&gt; * &lt;li&gt;creates a data layer for data files&lt;/li&gt; * &lt;li&gt;creates a gpx layer for gpx files&lt;/li&gt; * &lt;li&gt;creates an image layer for a directory with images&lt;/li&gt; * &lt;li&gt;etc.&lt;/li&gt; * &lt;/ul&gt; * * * @example * // open a data file in a new data layer * josm.open('/my/data/file.osm') * * @summary Opens one or more files in JOSM * @param {...(java.io.File | string)} files files to open * @function * @static */ exports.open = function () { const OpenFileAction = Java.type('org.openstreetmap.josm.actions.OpenFileAction') const File = Java.type('java.io.File') const files = [] for (let i = 0; i &lt; arguments.length; i++) { const file = arguments[i] if (util.isNothing(file)) { continue } else if (util.isString(file)) { files.push(new File(file)) } else if (file instanceof File) { files.push(file) } else { util.assert(false, 'expected java.io.File or string, got {0}', file) } } // openFiles is async OpenFileAction.openFiles(files) } /** * Replies the global command history. * * * Use this object to undo/redo commands, or to clear the command * history. * * @example * // undoes the last command * josm.commands.undo() * * // redoes two commands * josm.commands.redo(2) * * @readOnly * @name commands * @property {module:josm/command.CommandHistory} commands * @summary the global command history * @static */ const { CommandHistory } = require('josm/command') Object.defineProperty(exports, 'commands', { enumerable: true, value: CommandHistory }) /** * Replies an accessor for JOSMs menu bar. * * * Use this object to inspect or modify the menu bar, i.e. to add additional * menu items. * * @readOnly * @property {module:josm/ui/menu~MenuBar} menu accessor for JOSMs menu bar * @name menu * @static * @summary Replies an accessor for JOSMs menu bar. */ Object.defineProperty(exports, 'menu', { enumerable: true, value: MenuBar }) × Search results Close "},"josm_api.js.html":{"id":"josm_api.js.html","title":"Source: josm/api.js","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/api.js /** * This module provides functions to retrieve data from and upload data * to an OSM server. * * @module josm/api */ /* global Java */ /* global require */ const URL = Java.type('java.net.URL') const OsmApi = Java.type('org.openstreetmap.josm.io.OsmApi') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') const PrimitiveId = Java.type('org.openstreetmap.josm.data.osm.PrimitiveId') const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') const NullProgressMonitor = Java.type('org.openstreetmap.josm.gui.progress.NullProgressMonitor') const OsmServerChangesetReader = Java.type('org.openstreetmap.josm.io.OsmServerChangesetReader') const OsmServerObjectReader = Java.type('org.openstreetmap.josm.io.OsmServerObjectReader') const OsmServerBackreferenceReader = Java.type('org.openstreetmap.josm.io.OsmServerBackreferenceReader') const Preferences = Java.type('org.openstreetmap.josm.data.Preferences') const Bounds = Java.type('org.openstreetmap.josm.data.Bounds') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const util = require('josm/util') /** * Creates a {@class org.openstreetmap.josm.data.coor.LatLon} from a * javascript object. * * @example * const { buildLatLon } = require('josm/api') * const pos = buildLatLon({lat: 1, lon: 2}); * * @param {object} obj a javascript object with two number properties * &lt;code&gt;lat:&lt;/code&gt; and &lt;code&gt;lon:&lt;/code&gt; * @name buildLatLon * @static * @returns {org.openstreetmap.josm.data.coor.LatLon} * @summary Create a {@class org.openstreetmap.josm.data.coor.LatLon} * from a javascript object. * @function */ exports.buildLatLon = function (obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined'); util.assert(typeof obj === 'object', 'obj: expected an object, got {0}', obj); util.assert(util.isNumber(obj.lat), 'obj.lat: expected a number, got {0}', obj.lat); util.assert(util.isNumber(obj.lon), 'obj.lon: expected a number, got {0}', obj.lon); util.assert(LatLon.isValidLat(obj.lat), 'obj.lat: expected a valid lat in the range [-90,90], got {0}', obj.lat); util.assert(LatLon.isValidLon(obj.lon), 'obj.lon: expected a valid lon in the range [-180,180], got {0}', obj.lon); return new LatLon(obj.lat, obj.lon); } /** * Creates a {@ org.openstreetmap.josm.data.Bounds} instance from a javascript object. * * @example * let { buildBounds } = require('josm/api') * const bounds1 = buildBounds({minlat: 46.9479186, minlon: 7.4619484, * maxlat: 46.9497642, maxlon: 7.4660683}) * * const bounds2 = buildBounds({ * min: {lat: 46.9479186, lon: 7.4619484}, * max: {lat: 46.9497642, lon: 7.4660683} * }) * * @param {object} obj a javascript object * @return {org.openstreetmap.josm.data.Bounds} the bounds * @name buildBounds * @function * @static */ exports.buildBounds = function (obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined') util.assert(typeof obj === 'object', 'obj: expected an object, got {0}', obj) function normalizeLat(obj,name) { util.assert(util.isDef(obj[name]), '{0}: missing mandatory property', name) util.assert(util.isNumber(obj[name]), '{0}: expected a number, got {1}', name, obj[name]) util.assert(LatLon.isValidLat(obj[name]), '{0}: expected a valid lat, got {1}', name, obj[name]) return obj[name] } function normalizeLon(obj,name) { util.assert(util.isDef(obj[name]), '{0}: missing mandatory property', name) util.assert(util.isNumber(obj[name]), '{0}: expected a number, got {1}', name, obj[name]) util.assert(LatLon.isValidLon(obj[name]), '{0}: expected a valid lon, got {1}', name, obj[name]) return obj[name] } if (util.isDef(obj.minlat)) { const minlat = normalizeLat(obj.minlat) const minlon = normalizeLat(obj.minlon) const maxlat = normalizeLat(obj.maxlat) const maxlon = normalizeLat(obj.maxlon) return new Bounds(minlat, minlon, maxlat, maxlon) } else if (util.isDef(obj.min)) { const min = exports.buildLatLon(obj.min) const max = exports.buildLatLon(obj.max) return new Bounds(min,max) } else { util.assert(false, 'obj: expected an object {min:.., max:..} or ' + '{minlat:, maxlat:, minlon:, maxlon:}, got {0}', obj) } } /** * Provides methods to open, close, get, update, etc. changesets on the OSM * API server. * * &lt;strong&gt;Note:&lt;/strong&gt; this class doesn't provide a constructor. Methods * and properties are &lt;code&gt;static&lt;/code&gt;. * * @example * // load the changeset api * const { ChangesetApi } = require('josm/api') * * // create a new changeset on the server * const cs = ChangesetApi.open() * * @class * @summary Provides methods to open, close, get, and update changesets on the OSM API server * @name ChangesetApi */ exports.ChangesetApi = {} /** * Creates and opens a changeset * * &lt;ul&gt; * &lt;li&gt;&lt;code&gt;open()&lt;/code&gt; - open a new changeset with no tags&lt;/li&gt; * &lt;li&gt;&lt;code&gt;open(aChangeset)&lt;/code&gt; - open a new changeset with the tags * from &lt;code&gt;aChangeset&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;open(anObject)&lt;/code&gt; - open a new changeset with the tags * given by the properties of &lt;code&gt;anObject&lt;/code&gt;&lt;/li&gt; * &lt;/ul&gt; * * @example * const { ChangesetApi } = require('josm/api') * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // open a new changeset with no tags * const cs1 = ChangesetApi.open() * * // open a new changeset with the tags given by the supplied changeset * const cs2 = new Changeset() * cs2.put('comment', 'a test comment') * cs2 = ChangesetApi.open(cs2) * * // open a new changeset with the tags given by the object * var cs3 = ChangesetApi.open({comment: 'a test comment'}) * * @static * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset * @summary Creates and opens a changeset * @function * @memberof module:josm/api~ChangesetApi * @name open * @param {org.openstreetmap.josm.data.osm.Changeset | object} [changeset] the changeset to open */ exports.ChangesetApi.open = function () { let cs switch (arguments.length) { case 0: cs = new Changeset() break case 1: var o = arguments[0] if (o instanceof Changeset) { cs = o } else if (typeof o === 'object') { cs = new Changeset() for (var p in o) { if (!util.hasProp(o, p)) continue var key = p var value = o[p] key = util.trim(key) value = value + '' // convert to string cs.put(key, value) } } else { util.assert(false, 'Unexpected type of argument, expected Changeset or object, ' + 'got {0}', o) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } var api = OsmApi.getOsmApi() api.openChangeset(cs, NullProgressMonitor.INSTANCE) return cs } /** * Closes a changeset * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;close(id)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;closes the changeset with the given id&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;close(aChangeset)&lt;/code&gt;&lt;dt&gt; * &lt;dd&gt;Xloses the changeset given by &lt;code&gt;aChangeset&lt;/code&gt;&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { ChangesetApi } = require('josm/api') * const util = require('josm/util') * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // closs the changeset 12345 * ChangesetApi.close(12345) * * // open a new changeset with the tags given by the supplied changeset * const cs2 = new Changeset(12345) * cs2 = ChangesetApi.close(cs2) * util.assert(cs2.closed) // the changeset is now closed * * @param {number | org.openstreetmap.josm.data.osm.Changeset} changeset the changeset to close * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset * @summary Closes a changeset * @memberof module:josm/api~ChangesetApi * @function * @name close */ exports.ChangesetApi.close = function () { let cs switch (arguments.length) { case 0: util.assert(false, 'Missing arguments. Expected a changeset it or a changeset') break case 1: { const o = arguments[0] if (o instanceof Changeset) { cs = o } else if (util.isNumber(o)) { util.assert(o &gt; 0, 'Expected a positive changeset id, got {0}', o) cs = new Changeset(o) } else { util.assert(false, 'Unexpected type of argument, expected Changeset or number, ' + 'got {0}', o) } break } default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } const api = OsmApi.getOsmApi() api.closeChangeset(cs, NullProgressMonitor.INSTANCE) return cs } /** * Updates a changeset * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;update(aChangeset)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Updates the changeset &lt;code&gt;aChangeset&lt;/code&gt;&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { ChangesetApi } = require('josm/api') * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // update the comment of a changeset * const cs2 = new Changeset(12345) * cs2.put('comment', 'an updated comment') * cs2 = ChangesetApi.update(cs2) * * @param {org.openstreetmap.josm.data.osm.Changeset} changeset the changeset to update * @static * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset * @summary Updates a changeset * @function * @memberof module:josm/api~ChangesetApi * @name update */ exports.ChangesetApi.update = function () { let cs switch (arguments.length) { case 0: util.assert(false, 'Missing arguments. Expected a changeset') break case 1: { const o = arguments[0] if (o instanceof Changeset) { cs = o } else { util.assert(false, 'Unexpected type of argument, expected Changeset, got {0}', o) } break } default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } const api = OsmApi.getOsmApi() api.updateChangeset(cs, NullProgressMonitor.INSTANCE) return cs } /** * Get a changeset from the server * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature&gt;get(aChangeset)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Gets the changeset specified by &lt;code&gt;aChangeset&lt;/code&gt;. aChangset * must be an instance of &lt;code&gt;Changeset&lt;/code&gt;. * aChangeset.id &amp;gt 0 expected.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;get(id)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;gets the changeset for the id. id must be a number &amp;gt 0.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { ChangesetApi } = require('josm/api') * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // get the changeset with id 12345 * const cs1 = ChangesetApi.get(12345) * * // get the changeset with id 12345 * const cs2 = new Changeset(12345) * cs2 = ChangesetApi.get(cs2) * * @param {number|org.openstreetmap.josm.data.osm.Changeset} changeset the changeset to close * @static * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset * @summary Get a changeset from the server * @memberof module:josm/api~ChangesetApi * @name get * @function * @param {number | org.openstreetmap.josm.data.osm.Changeset} changeset */ exports.ChangesetApi.get = function () { let cs switch (arguments.length) { case 0: util.assert(false, 'Missing arguments. Expected a changeset id or a changeset') break case 1: { const o = arguments[0] if (o instanceof Changeset) { cs = o } else if (util.isNumber(o)) { util.assert(o &gt; 0, 'Expected a positive changeset id, got {0}', o) cs = new Changeset(o) } else { util.assert(false, 'Unexpected type of argument, expected Changeset or number, ' + 'got {0}', o) } break } default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } const reader = new OsmServerChangesetReader() cs = reader.readChangeset(cs.id, NullProgressMonitor.INSTANCE) return cs } /** * Collection of static methods to download objects from and upload objects * to the OSM server. * * &lt;strong&gt;Note:&lt;/strong&gt; this class doesn't provide a constructor. * Methods and properties are 'static'. * * @example * // load the api * const { Api } = require('josm/api') * * // download node 12345 * const ds = Api.downloadObject(12345, 'node') * * @class * @summary Collection of static methods to download objects from and upload objects * to the OSM server * @name Api */ exports.Api = function () {} function normalizeType (type) { util.assert(util.isSomething(type), 'type must not be null or undefined') if (util.isString(type)) { try { type = OsmPrimitiveType.fromApiTypeName(type) } catch (e) { util.assert(false, 'Invalid primitive type, got \\'\\'{0}\\'\\'', type) } } else if (type instanceof OsmPrimitiveType) { if (![OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, OsmPrimitiveType.RELATION].contains(type)) { util.assert(false, 'Invalid primitive type, got {0}', type) } } else { util.assert(false, 'Invalid primitive type, got {0}', type) } return type } function normalizeId (id) { util.assert(util.isSomething(id), 'id must not be null or nothing') util.assert(util.isNumber(id), 'Expected a number as id, got {0}', id) util.assert(id &gt; 0, 'Expected a positive number as id, got {0}', id) return id } function primitiveIdFromObject (o) { util.assert(util.hasProp(o, 'id'), 'Mandatory property \\'\\'id\\'\\' is missing in object {0}', o) util.assert(util.hasProp(o, 'type'), 'Mandatory property \\'\\'type\\'\\' is missing in object {0}', o) return new SimplePrimitiveId(normalizeId(o.id), normalizeType(o.type)) } function downloadObject1 () { let id const o = arguments[0] util.assert(util.isSomething(o), 'Argument 0: must not be null or undefined') if (o instanceof PrimitiveId) { id = o } else if (typeof o === 'object') { id = primitiveIdFromObject(o) } else { util.assert(false, 'Argument 0: unexpected type, got {0}', o) } var reader = new OsmServerObjectReader(id, false) var ds = reader.parseOsm(null /* null progress monitor */) return ds } function optionFull (options) { if (!util.hasProp(options, 'full')) return undefined var o = options.full if (typeof o === 'boolean') return o util.assert('Expected a boolean value for option \\'\\'full\\'\\', got {0}', o) } function optionVersion (options) { if (!util.hasProp(options, 'version')) return undefined var o = options.version util.assert(util.isNumber(o), 'Expected a number for option \\'\\'version\\'\\', got {0}', o) util.assert(o &gt; 0, 'Expected a number &gt; 0 for option \\'\\'version\\'\\', got {0}', o) return o } function downloadObject2 () { function parseOptions (arg) { const options = { full: undefined, version: undefined } if (!(typeof arg === 'object')) { return options } options.full = optionFull(arg) options.version = optionVersion(arg) return options } let id let options = { full: undefined, version: undefined } if (util.isNumber(arguments[0])) { id = normalizeId(arguments[0]) var type = normalizeType(arguments[1]) id = new SimplePrimitiveId(id, type) } else if (arguments[0] instanceof PrimitiveId) { id = arguments[0] options = parseOptions(arguments[1]) } else if (typeof arguments[0] === 'object') { id = primitiveIdFromObject(arguments[0]) options = parseOptions(arguments[1]) } else { util.assert(false, 'Unsupported types of arguments') } var reader if (util.isDef(options.version)) { reader = new OsmServerObjectReader(id, options.version) } else { reader = new OsmServerObjectReader(id, !!options.full) } var ds = reader.parseOsm(null /* null progress monitor */) return ds } function downloadObject3 () { const options = { full: undefined, version: undefined } var n = normalizeId(arguments[0]) var type = normalizeType(arguments[1]) var id = new SimplePrimitiveId(n, type) util.assert(typeof arguments[2] === 'object', 'Expected an object with named parameters, got {0}', arguments[2]) options.full = optionFull(arguments[2]) options.version = optionVersion(arguments[2]) let reader if (util.isDef(options.version)) { reader = new OsmServerObjectReader(id, options.version) } else { reader = new OsmServerObjectReader(id, !!options.full) } var ds = reader.parseOsm(null /* null progress monitor */) return ds } /** * Downloads an object from the server. * * There are multiple options to specify what object to download. * In addition, the function accepts a set of optional named parameters * as last argument. * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;downloadObject(id, type, ?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;&lt;code&gt;id&lt;/code&gt; is the global numeric id. * &lt;code&gt;type&lt;/code&gt; is either one of the strings 'node', 'way', * or 'relation', or one of the enumeration OsmPrimitiveType.NODE, * OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION * &lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;downloadObject(id, ?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;&lt;code&gt;id&lt;/code&gt; is a &lt;code&gt;PrimitiveId&lt;/code&gt; or an object * with the (mandatory) properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, * i.e. an object &lt;code&gt;{id: ..., type: ...}&lt;/code&gt;. * &lt;code&gt;id&lt;/code&gt; is again a number, &lt;code&gt;type&lt;/code&gt; is again either one * of the strings 'node', 'way', or 'relation', or one of the * enumeration OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, * or OsmPrimitiveType.RELATION. * &lt;/dd&gt; * &lt;/dl&gt; * In both cases, &lt;code&gt;?options&lt;/code&gt; is an (optional) object with the * following two (optional) properties: * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;full&lt;/code&gt;: boolean&lt;/dt&gt; * &lt;dd&gt;If &lt;code&gt;true&lt;/code&gt;, the object and its immediate children are * downloaded, i.e. the nodes of a way and * the relation members of a relation. Default if missing is * &lt;code&gt;false&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;version&lt;/code&gt;: number&lt;/dt&gt; * &lt;dd&gt;If present, the specified version of the object is downloaded. * If missing, the current version is downloaded. If present, the * option &lt;code&gt;full&lt;/code&gt; is ignored.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { Api } = require('josm/api') * const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') * const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') * * // download the node with id 12345 * const ds1 = Api.downloadObject(12345, 'node') * * // download the node with id 12345 * const ds2 = Api.downloadObject({id: 12345, type: 'node'}) * * // download the full relation (including its members) with id 12345 * const id = new SimplePrimitiveId(12345, OsmPrimitiveType.RELATION) * const ds3 = Api.downloadObject(id, {full: true}) * * // download version 5 of the full way 12345 (including its nodes) * const ds4 = Api.downloadObject(12345, OsmPrimitiveType.WAY, {version: 5}) * * @static * @returns {org.openstreetmap.josm.data.osm.DataSet} the downloaded primitives * @summary Downloads an object from the server. * @memberof module:josm/api~Api * @function * @name downloadObjects * @param args see description and examples */ exports.Api.downloadObject = function () { switch (arguments.length) { case 0: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) break case 1: return downloadObject1.apply(this, arguments) case 2: return downloadObject2.apply(this, arguments) case 3: return downloadObject3.apply(this, arguments) default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } } function downloadReferrer1 () { let id const o = arguments[0] util.assert(util.isSomething(o), 'Argument 0: must not be null or undefined') if (o instanceof PrimitiveId) { id = o } else if (typeof o === 'object') { id = primitiveIdFromObject(o) } else { util.assert(false, 'Argument 0: unexpected type, got {0}', o) } const reader = new OsmServerBackreferenceReader(id.getUniqueId(), id.getType()) const ds = reader.parseOsm(NullProgressMonitor.INSTANCE) return ds } function downloadReferrer2 () { let id let type const options = { full: undefined } if (util.isNumber(arguments[0])) { id = normalizeId(arguments[0]) type = normalizeType(arguments[1]) id = new SimplePrimitiveId(id, type) } else if (arguments[0] instanceof PrimitiveId) { id = arguments[0] const o = arguments[1] if (util.isSomething(o)) { util.assert(typeof o === 'object', 'Expected an object with named parameters, got {0}', o) options.full = optionFull(o) } } else if (typeof arguments[0] === 'object') { id = primitiveIdFromObject(arguments[0]) const o = arguments[1] if (util.isSomething(o)) { util.assert(typeof o === 'object', 'Expected an object with named parameters, got {0}', o) options.full = optionFull(o) } } else { util.assert(false, 'Unsupported types of arguments') } const reader = new OsmServerBackreferenceReader(id.getUniqueId(), id.getType()) if (options.full) { reader.setReadFull(true) } const ds = reader.parseOsm(NullProgressMonitor.INSTANCE) return ds } function downloadReferrer3 () { const options = { full: undefined } const n = normalizeId(arguments[0]) const type = normalizeType(arguments[1]) const id = new SimplePrimitiveId(n, type) util.assert(typeof arguments[2] === 'object', 'Expected an object with named parameters, got {0}', arguments[2]) options.full = optionFull(arguments[2]) const reader = new OsmServerBackreferenceReader(id.getUniqueId(), id.getType()) if (options.full) { reader.setReadFull(true) } const ds = reader.parseOsm(NullProgressMonitor.INSTANCE) return ds } /** * Downloads the objects &lt;em&gt;referring&lt;/em&gt; to another object from * the server. * * Downloads primitives from the OSM server which * refer to a specific primitive. Given a node, the referring ways and * relations are downloaded. Given a way or a relation, only referring * relations are downloaded. * * The default behaviour is to reply proxy objects only. * * If you set the option &lt;code&gt;{full: true}&lt;/code&gt;, every referring object * is downloaded in full. * * There are multiple options to specify what referrers to download. * In addition, the function accepts a set of optional named parameters as * last argument. * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;downloadReferrer(id, type, ?options) * &lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;&lt;code&gt;id&lt;/code&gt; is the global numeric id. * &lt;code&gt;type&lt;/code&gt; is either one of the strings 'node', 'way', or * 'relation', or one of the enumeration * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, * or {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION. * &lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;downloadReferrer(id, ?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;&lt;code&gt;id&lt;/code&gt; is a &lt;code&gt;PrimitiveId&lt;/code&gt; or an object * with the (mandatory) properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, * i.e. an object &lt;code&gt;{id: ..., type: ...}&lt;/code&gt;. * &lt;code&gt;id&lt;/code&gt; is again a number, &lt;code&gt;type&lt;/code&gt; is again either one * of the strings 'node', 'way', or 'relation', or one of the * enumeration * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, * or {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION. * &lt;/dd&gt; * &lt;/dl&gt; * In both cases, &lt;code&gt;?options&lt;/code&gt; is an (optional) object with the * following (optional) property: * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;full&lt;/code&gt;:boolean&lt;/dt&gt; * &lt;dd&gt;If &lt;code&gt;true&lt;/code&gt;, the the &lt;strong&gt;full&lt;/strong&gt; objects are * retrieved using multi-gets. If missing or &lt;code&gt;false&lt;/code&gt;, * only proxy objects are downloaded. Default: false&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { Api } = require('josm/api') * const { NodeBuilder } = require('josm/builder') * const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') * const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') * * // download the objects referring to the node with id 12345 * const ds1 = Api.downloadReferrer(12345, 'node') * * // download the objects referring to the node with id 12345 * const ds2 = Api.downloadReferrer({id: 12345, type: 'node'}) * * // download the relations referring to the relation with id 12345. * // Referring relations are downloaded in full. * const id = new SimplePrimitiveId(12345, OsmPrimitiveType.RELATION) * const ds3 = Api.downloadReferrer(id, { full: true }) * * // create the global node 12345 ... * const node = NodeBuilder.create(12345) * // ... and downloads its referrers in full * const ds = Api.downloadReferrer(node, { full: true }) * * @static * @returns {org.openstreetmap.josm.data.osm.DataSet} the downloaded primitives * @summary Downloads the objects &lt;em&gt;referring&lt;/em&gt; to another object from * the server. * @memberof module:josm/api~Api * @function * @name downloadReferrer * @param args see description and examples */ exports.Api.downloadReferrer = function () { switch (arguments.length) { case 0: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) break case 1: return downloadReferrer1.apply(this, arguments) case 2: return downloadReferrer2.apply(this, arguments) case 3: return downloadReferrer3.apply(this, arguments) default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } } /** * Downloads the objects within a bounding box. * * @example * const { Api } = require('josm/api') * const ds1 = Api.downloadArea(new Bounds( * new LatLon(46.9479186,7.4619484), // min * new LatLon(46.9497642, 7.4660683) // max * )) * * const ds2 = Api.downloadArea({ * min: {lat: 46.9479186, lon: 7.4619484}, * max: {lat: 46.9497642, lon: 7.4660683} * }) * * @static * @returns {org.openstreetmap.josm.data.osm.DataSet} the downloaded primitives * @summary Downloads the objects within a bounding box * @param {org.openstreetmap.josm.data.Bounds|object} bounds the bounding box * @memberof module:josm/api~Api * @name downloadArea * @function */ exports.Api.downloadArea = function () { const BoundingBoxDownloader = Java.type('org.openstreetmap.josm.io.BoundingBoxDownloader') const NullProgressMonitor = Java.type('org.openstreetmap.josm.gui.progress.NullProgressMonitor') const Bounds = Java.type('org.openstreetmap.josm.data.Bounds') util.assert(arguments.length === 1, 'Expected 1 argument, got {0}', arguments.length) let bounds = arguments[0] util.assert(util.isSomething(bounds), 'bounds: must not be null or undefined') if (bounds instanceof Bounds) { // do nothing } else if (typeof bounds === 'object') { bounds = exports.buildBounds(bounds) // convert to bounds } else { util.assert(false, 'expected an instance of Bounds or an object, got {0}', bounds) } const downloader = new BoundingBoxDownloader(bounds) return downloader.parseOsm(NullProgressMonitor.INSTANCE) } /** * Uploads objects to the server. * * You can submit data either as * {@class org.openstreetmap.josm.data.osm.DataSet}, * {@class org.openstreetmap.josm.data.APIDataSet}, javascript array of * {@class org.openstreetmap.josm.data.osm.OsmPrimitive}s or * a {@class java.util.Collection} of * {@class org.openstreetmap.josm.data.osm.OsmPrimitive}s. * * This method supports the same upload strategy as the JOSM upload dialog. * Supply the named parameter &lt;code&gt;{strategy: ...}&lt;/code&gt; to choose the * strategy. * * &lt;p class='documentation-warning'&gt; * Be careful when uploading data to the OSM server! Do not upload copyright * protected or test data. * * * The method takes care to update the primitives in the uploaded data when * the upload succeeds. For instance, uploaded new primitives become global * objects and get assigned their new id and version, successfully deleted * objects become invisible, etc. * * Even if the entire upload of a dataset fails, a subset therefore may * have been uploaded successfully. In order to keep track, which pritives * have been uploaded successfully in case of an error, the method replies a * collection of the successfully uploaded objects. * Named options * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;strategy: string| * {@class org.openstreetmap.josm.io.UploadStrategy}&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Indicates how the data is uploaded. Either one of the strings * &lt;ul&gt; * &lt;li&gt;individualobjects&lt;/li&gt; * &lt;li&gt;chunked&lt;/li&gt; * &lt;li&gt;singlerequest&lt;/li&gt; * &lt;/ul&gt; * or one of the enumeration values in * {@class org.openstreetmap.josm.io.UploadStrategy}. * Default falue: UploadStrategy.DEFAULT_UPLOAD_STRATEGY * &lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;changeset: * number|{@class org.openstreetmap.josm.data.osm.Changeset}&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;The changeset to which the data is uploaded. Either a number * (the changeset id) or a * {@class org.openstreetmap.josm.data.osm.Changeset} instance. * Default: creates a new changeset.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;chunkSize: number&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;The size of an upload chunk, if the data is uploaded with the * upload strategy * {@class org.openstreetmap.josm.io.UploadStrategy}.CHUNKED_DATASET_STRATEGY.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;closeChangeset: boolean&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;If true, closes the changeset after the upload. Default: true&lt;/dd&gt; * &lt;/dl&gt; * * @example * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * const { WayBuilder } = require('josm/builder') * const { Api }= require('josm/api') * const ds = new DataSet() * WayBuilder * .forDataSet(ds) * .withNodes( * ds.nodeBuilder.withTags({name: 'node1'}).create(), * ds.nodeBuilder.withTags({name: 'node2'}.create() * ) * .withTags({name: 'way1'}) * .create() * * // uploads the data in a new changeset in one chunk * const processed = Api.upload(ds, 'just testing') * * @param {org.openstreetmap.josm.data.osm.DataSet| * org.openstreetmap.josm.data.APIDataSet|array|java.util.Collection} data the data to upload * @param {string} comment the upload comment * @param {object} [options] various options (see above) * @static * @returns {java.util.Collection} * @summary Uploads objects * @memberof module:josm/api~Api * @name upload * @function */ exports.Api.upload = function (data, comment, options) { const UploadStrategy = Java.type('org.openstreetmap.josm.io.UploadStrategy') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') const APIDataSet = Java.type('org.openstreetmap.josm.data.APIDataSet') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const UploadStrategySpecification = Java.type('org.openstreetmap.josm.io.UploadStrategySpecification') const Collection = Java.type('java.util.Collection') const OsmServerWriter = Java.type('org.openstreetmap.josm.io.OsmServerWriter') comment = comment || '' comment = String(comment) util.assertSomething(data, 'data: must not be null or undefined') options = options || {} util.assert(typeof options === 'object', 'options: expected an object with named arguments, got {0}', options) function normalizeChunkSize (size) { util.assert(util.isNumber(size), 'chunksize: expected a number, got {0}', size) util.assert(size &gt;= -1, 'chunksize: expected -1 or a number &gt; 0, got {0]', size) return size } function normalizeChangeset (changeset) { if (util.isNothing(changeset)) { return new Changeset() } else if (util.isNumber(changeset)) { util.assert(changeset &gt; 0, 'changeset: expected a changeset id &gt; 0, got {0}', changeset) return new Changeset(changeset) } else if (changeset instanceof Changeset) { return changeset } else { util.assert(false, 'changeset: unexpected value, got {0}', changeset) } } function uploadSpecFromOptions (options) { let strategy = options.strategy || UploadStrategy.DEFAULT_UPLOAD_STRATEGY strategy = UploadStrategy.from(strategy) let chunkSize = options.chunkSize || UploadStrategySpecification.UNSPECIFIED_CHUNK_SIZE chunkSize = normalizeChunkSize(chunkSize) let closeChangeset = util.isDef(options.closeChangeset) ? options.closeChangeset : true closeChangeset = Boolean(closeChangeset) const spec = new UploadStrategySpecification() spec.setStrategy(strategy) spec.setChunkSize(chunkSize) spec.setCloseChangesetAfterUpload(closeChangeset) return spec } let apiDataSet if (data instanceof DataSet) { apiDataSet = new APIDataSet(data) } else if (data instanceof APIDataSet) { apiDataSet = data } else if (util.isArray(data)) { apiDataSet = new APIDataSet(data) } else if (data instanceof Collection) { apiDataSet = new APIDataSet(data) } else { util.assert(false, 'data: unexpected type of value, got {0}', data) } if (apiDataSet.isEmpty()) return undefined apiDataSet.adjustRelationUploadOrder() const toUpload = apiDataSet.getPrimitives() let changeset = options.changeset || new Changeset() changeset = normalizeChangeset(changeset) changeset.put('comment', comment) const spec = uploadSpecFromOptions(options) const writer = new OsmServerWriter() writer.uploadOsm(spec, toUpload, changeset, null /* progress monitor */) if (spec.isCloseChangesetAfterUpload()) { exports.ChangesetApi.close(changeset) } return writer.getProcessedPrimitives() } /* -------------------------------------------------------------------------- */ /* ApiConfig */ /* -------------------------------------------------------------------------- */ /** * ApiConfig provides methods and properties for configuring API parameters. * * * @class * @summary ApiConfig provides methods and properties for configuring API parameters * @name ApiConfig */ exports.ApiConfig = function() {} const DEFAULT_URL = 'http://api.openstreetmap.com/api/0.6' /** * Get or set the API server URL. * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;get&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Replies the currently configured server URL or undefinend, if no * server URL is configured.&lt;/dd&gt; * &lt;dt&gt;&lt;code class='signature'&gt;set&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Sets the current server URL. If null or undefined, removes the * current configuration. Accepts either a string or a {@class java.net.URL}. * Only accepts http or https URLs. * &lt;/dd&gt; * &lt;/dl&gt; * * @example * const { ApiConfig } = require('josm/api') * ApiConfig.serverUrl // -&gt; the current server url * * // set a new API url * ApiConfig.serverUrl = 'http://api06.dev.openstreetmap.org' * * @static * @summary Get or set the API server URL. * @property {string} serverUrl * @name serverUrl * @memberof module:josm/api~ApiConfig */ Object.defineProperty(exports.ApiConfig, 'serverUrl', { enumerable: true, get: function () { var url = Preferences.main().get('osm-server.url', null) if (url == null) url = DEFAULT_URL return url == null ? undefined : util.trim(url) }, set: function (value) { if (util.isNothing(value)) { Preferences.main().put('osm-server.url', null) } else if (value instanceof URL) { util.assert(value.getProtocol() === 'http' || value.getProtocol() === 'https', 'url: expected a http or https URL, got {0}', value) Preferences.main().put('osm-server.url', value.toString()) } else if (util.isString(value)) { value = util.trim(value) try { const url = new URL(value) util.assert(url.getProtocol() === 'http' || url.getProtocol() === 'https', 'url: expected a http or https URL, got {0}', url.toString()) Preferences.main().put('osm-server.url', url.toString()) } catch (e) { util.assert(false, 'url: doesn\\'\\'t look like a valid URL, got {0}. Error: {1}', value, e) } } else { util.assert(false, 'Unexpected type of value, got {0}', value) } } }) /** * Get the default server URL. * * @example * const { ApiConfig } = require('josm/api') * ApiConfig.defaultServerUrl // -&gt; the default server url * * @static * @summary Get the default server URL * @name defaultServerUrl * @property {string} defaultServerUrl the default server URL * @readOnly * @memberof module:josm/api~ApiConfig */ Object.defineProperty(exports.ApiConfig, 'defaultServerUrl', { value: DEFAULT_URL, writable: false, enumerable: true }) function normalizeAuthMethod (authMethod) { util.assert(util.isString(authMethod), 'authMethod: expected a string, got {0}', authMethod) authMethod = util.trim(authMethod).toLowerCase() util.assert(authMethod === 'basic' || authMethod === 'oauth', 'Unsupported value for authMethod, got {0}', authMethod) return authMethod } /** * Get or set the authentication method. * * JOSM uses two authentication methods: * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;basic&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Basic authentication with a username and a password&lt;/dd&gt; * &lt;dt&gt;&lt;code class='signature'&gt;oauth&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Authentication with the &lt;a href='http://oauth.net/'&gt;OAuth&lt;/a&gt; * protocol.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { ApiConfig } = require('josm/api') * ApiConfig.authMethod // -&gt; the current authentication method * * // set OAuth as authentication method * ApiConfig.authMethod = 'oauth' * * @static * @summary Get or set the authentication method. * @type string * @name authMethod * @property {string} authMethod the authentication method * @memberof module:josm/api~ApiConfig */ Object.defineProperty(exports.ApiConfig, 'authMethod', { enumerate: true, get: function () { var authMethod = Preferences.main().get('osm-server.auth-method', 'basic') authMethod = util.trim(authMethod).toLowerCase() if (authMethod === 'basic' || authMethod === 'oauth') return authMethod // unsupported value for authMethod in the preferences. Returning // 'basic' as default. return 'basic' }, set: function (value) { value = normalizeAuthMethod(value) Preferences.main().put('osm-server.auth-method', value) } }) /** * Gets the credentials, i.e. username and password for the basic * authentication method. * * &lt;strong&gt;Named options&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;host:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;The host name of the API server for which credentials are retrieved. * If missing, the host name of the currently configured OSM API server * is used.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { ApiConfig } = require('josm/api') * * // get username/password for the current OSM API server * const credentials = ApiConfig.getCredentials('basic') * * @param {string} authMethod the authentication method. Either &lt;code&gt;basic&lt;/code&gt; or &lt;code&gt;oauth&lt;/code&gt; * @param {object} options (optional) additional options (see above) * @static * @summary Gets the credentials. * @returns {object} the credentials * @name getCredentials * @function * @memberof module:josm/api~ApiConfig */ exports.ApiConfig.getCredentials = function (authMethod, options) { const CredentialsManager = Java.type('org.openstreetmap.josm.io.auth.CredentialsManager') const OsmApi = Java.type('org.openstreetmap.josm.io.OsmApi') const RequestorType = Java.type('java.net.Authenticator.RequestorType') const String = Java.type('java.lang.String') options = options || {} util.assert(typeof options === 'object', 'options: expected an object with named options, got {0}', options) function getBasicCredentials () { const cm = CredentialsManager.getInstance() if (options.host) options.host = util.trim(String(options.host)) const host = options.host ? options.host : OsmApi.getOsmApi().getHost() const pa = cm.lookup(RequestorType.SERVER, host) return pa ? { host: host, user: pa.getUserName(), password: String.valueOf(pa.getPassword()) } : { host: host, user: undefined, password: undefined } } function getOAuthCredentials () { const cm = CredentialsManager.getInstance() const token = cm.lookupOAuthAccessToken() if (token == null) return undefined return { key: token.getKey(), secret: token.getSecret() } } authMethod = normalizeAuthMethod(authMethod) if (authMethod === 'basic') return getBasicCredentials() if (authMethod === 'oauth') return getOAuthCredentials() util.assert(false, 'Unsupported authentication method, got {0}', authMethod) } function normalizeBasicCredentials (credentials) { const PasswordAuthentication = Java.type('java.net.PasswordAuthentication') if (util.isNothing(credentials)) return null util.assert(credentials instanceof PasswordAuthentication || typeof credentials === 'object', 'basic credentials: expected an object or an instance of ' + 'PasswordAuthentication , got {0}', credentials) if (credentials instanceof PasswordAuthentication) { return credentials } else { const user = String.valueOf(credentials.user || '') let password = credentials.password || null password = password ? String.valueOf(password).toCharArray() : password return new PasswordAuthentication(user, password) } } function normalizeOAuthCredentials (credentials) { const OAuthToken = Java.type('org.openstreetmap.josm.data.oauth.OAuthToken') if (util.isNothing(credentials)) return null util.assert(credentials instanceof OAuthToken || typeof credentials === 'object', 'oauth credentials: expected an object or an instance of OAuthToken, ' + 'got {0}', credentials) if (credentials instanceof OAuthToken) { return credentials } else { const key = String(credentials.key || '') const secret = String(credentials.secret || '') return new OAuthToken(key, secret) } } /** * Set the credentials, i.e. username and password for the basic * authentication method. * * Basic authentication credentials are either an instance of * java.net.PasswordAuthentication or * an object &lt;code&gt;{user: string, password: string}&lt;/code&gt;. * * OAuth authentication credentials are either an instance of * {@class org.openstreetmap.josm.data.oauth.OAuthToken} or * an object &lt;code&gt;{key: string, secret: string}&lt;/code&gt;. * &lt;strong&gt;Named options&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;host:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;The host name of the API server for which credentials are set. * If missing, the host name of the currently configured OSM API server * is used.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { ApiConfig } = require('josm/api') * * // set the credentials * ApiConfig.setCredentials('basic', { user:'test', password:'apassword' }) * * @param {string} authMethod the authentication method. Either 'basic' or 'oauth'. * @param {(object|org.openstreetmap.josm.data.oauth.OAuthToken|java.net.PasswordAuthentication)} * credentials the credentials. * @param {object} options (optional) additional options (see above) * @function * @static * @summary Set the credentials. * @returns {object} the credentials * @name setCredentials * @memberof module:josm/api~ApiConfig */ exports.ApiConfig.setCredentials = function (authMethod, credentials, options) { const CredentialsManager = Java.type('org.openstreetmap.josm.io.auth.CredentialsManager') const RequestorType = Java.type('java.net.Authenticator.RequestorType') const OsmApi = Java.type('org.openstreetmap.josm.io.OsmApi') options = options || {} util.assert(typeof options === 'object', 'options: expected an object with named options, got {0}', options) authMethod = normalizeAuthMethod(authMethod) if (authMethod === 'basic') { credentials = normalizeBasicCredentials(credentials) util.assert(credentials != null, 'credentials: can\\'\\'t store null credentials') let host = options.host ? String(options.host) : null host = host || OsmApi.getOsmApi().getHost() const cm = CredentialsManager.getInstance() cm.store(RequestorType.SERVER, host, credentials) } else if (authMethod === 'oauth') { credentials = normalizeOAuthCredentials(credentials) util.assert(credentials != null, 'credentials: can\\'\\'t store null credentials') const cm = CredentialsManager.getInstance() cm.storeOAuthAccessToken(credentials) } else { util.assert(false, 'Unsupported authentication method, got {0}', authMethod) } } × Search results Close "},"josm_builder.js.html":{"id":"josm_builder.js.html","title":"Source: josm/builder.js","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/builder.js /** * Collection of builders for creating OSM nodes, ways and relations. * * @module josm/builder */ /* global Java */ /* global require */ // -- imports const Node = Java.type('org.openstreetmap.josm.data.osm.Node') const Way = Java.type('org.openstreetmap.josm.data.osm.Way') const Relation = Java.type('org.openstreetmap.josm.data.osm.Relation') const RelationMember = Java.type('org.openstreetmap.josm.data.osm.RelationMember') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const OsmPrimitive = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitive') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const List = Java.type('java.util.List') const util = require('josm/util') function assertGlobalId (id) { util.assertSomething(id, 'Expected a defined, non-null object id, got {0}', id) util.assertNumber(id, 'Expected a number as object id, got {0}', id) util.assert(id &gt; 0, 'Expected a positive id, got {0}', id) } function rememberId (builder, id, version) { assertGlobalId(id) builder.id = id version = util.isDef(version) ? version : 1 util.assertNumber(version, 'Expected a number for \\'version\\', got {0}', version) util.assert(version &gt; 0, 'Expected a positive number for \\'version\\', got {0}', version) builder.version = version } function rememberTags (builder, tags) { if (util.isNothing(tags)) return util.assert(typeof tags === 'object', 'Expected a hash with tags, got {0}', tags) builder.tags = builder.tags || {} for (let name in tags) { if (!util.hasProp(tags, name)) break let value = tags[name] name = util.trim(name) if (util.isNothing(value)) break value = value + '' // convert to string builder.tags[name] = value } } function assignTags (primitive, tags) { for (const name in tags) { if (!util.hasProp(tags, name)) continue let value = tags[name] if (util.isNothing(value)) continue value = value + '' primitive.put(name, value) } } function rememberIdFromObject (builder, args) { if (!util.hasProp(args, 'id')) return const o = args.id util.assert(util.isSomething(o), \"''{0}'': must not be null or undefined\", 'id') util.assert(util.isNumber(o), \"''{0}'': expected a number, got {1}\", 'id', o) util.assert(o &gt; 0, \"''{0}'': expected a number &gt; 0, got {1}\", 'id', o) builder.id = o } function rememberVersionFromObject (builder, args) { if (!util.hasProp(args, 'version')) return const o = args.version util.assert(util.isSomething(o), \"''{0}'': must not be null or undefined\", 'version') util.assert(util.isNumber(o), \"''{0}'': expected a number, got {1}\", 'version', o) util.assert(o &gt; 0, \"''{0}'': expected a number &gt; 0, got {1}\", 'version', o) builder.version = o } function checkLat (value) { if (!(util.isSomething(value) &amp;&amp; util.isNumber(value) &amp;&amp; LatLon.isValidLat(value))) { throw new Error(`invalid lat value, got '${value}`) } return value } function checkLon (value) { if (!(util.isSomething(value) &amp;&amp; util.isNumber(value) &amp;&amp; LatLon.isValidLon(value))) { throw new Error(`invalid lon value, got '${value}`) } return value } function rememberPosFromObject (builder, args) { if (util.hasProp(args, 'pos')) { util.assert(!(util.hasProp(args, 'lat') || util.hasProp(args, 'lon')), \"Can''t process both properties ''pos'' and ''lat''/''lon''\") const pos = args.pos util.assert(util.isSomething(pos), \"''{0}'': must not be null or undefined\", 'pos') if (pos instanceof LatLon) { builder.lat = pos.lat() builder.lon = pos.lon() } else if (util.isArray(pos)) { util.assert(pos.length === 2, \"''{0}'': expected exactly two numbers in array\", 'pos') try { builder.lat = checkLat(pos[0]) } catch (e) { util.assert(false, \"''{0}'': {1}\", 'lat', e) } try { builder.lon = checkLon(pos[1]) } catch (e) { util.assert(false, \"''{0}'': {1}\", 'lon', e) } } else if (util.isObject(pos)) { util.assert(util.hasProp(pos, 'lat'), \"''{0}'': missing mandatory property ''lat''\", 'pos') util.assert(util.hasProp(pos, 'lon'), \"''{0}'': missing mandatory property ''lon''\", 'pos') try { builder.lat = checkLat(pos.lat) } catch (e) { util.assert(false, \"''{0}'': {1}\", 'pos', e) } try { builder.lon = checkLon(pos.lon) } catch (e) { util.assert(false, \"''{0}'': {1}\", 'pos', e) } } } if (util.hasProp(args, 'lat')) { const o = args.lat util.assert(util.isSomething(o), \"''{0}'': must not be null or undefined\", 'lat') util.assert(util.isNumber(o), \"''{0}'': expected a number, got {1}\", 'lat', o) util.assert(LatLon.isValidLat(o), \"''{0}'': expected a valid latitude, got {1}\", 'lat', o) builder.lat = o } if (util.hasProp(args, 'lon')) { const o = args.lon util.assert(util.isSomething(o), \"''{0}'': must not be null or undefined\", 'lon') util.assert(util.isNumber(o), \"''{0}'': expected a number, got {1}\", 'lon', o) util.assert(LatLon.isValidLon(o), \"''{0}'': expected a valid longitude, got {1}\", 'lon', o) builder.lon = o } } function rememberTagsFromObject (builder, args) { if (!util.hasProp(args, 'tags')) return const o = args.tags if (util.isNothing(o)) return rememberTags(builder, o) } // ---------------------------------------------------------------------------- // NodeBuilder // ---------------------------------------------------------------------------- (function () { // start submodul NodeBuilder /** * NodeBuilder helps to create OSM nodes. * * Methods of NodeBuilder can be used in a static and in an instance context. * It isn't necessary to create an instance of NodeBuilder, unless it is * configured with a {@class org.openstreetmap.josm.data.osm.DataSet}, * to which created nodes are added. * * @example * const NodeBuilder = require('josm/builder').NodeBuilder * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const ds = new DataSet() * // create a node builder without and underlying dataset ... * let nbuilder = new NodeBuilder() * // ... with an underlying dataset .... * nbuilder = new NodeBuilder(ds) * // ... or using this factory method * nbuilder = NodeBuilder.forDataSet(ds) * * // create a new local node at position (0,0) without tags * const n1 = nbuilder.create() * * // create a new global node at a specific position with tags * const n2 = nbuilder.withPosition(1,1).withTags({name: 'test'}).create(123456) * * // create a new proxy for a global node * // (an 'incomplete' node in JOSM terminology) * const n3 = nbuilder.createProxy(123456) * * @class * @summary NodeBuilder helps to create OSM nodes * @name NodeBuilder * @param {org.openstreetmap.josm.data.osm.DataSet} [ds] the dataset * which created objects are added to */ /** * Creates a new node builder. * * @param {org.openstreetmap.josm.data.osm.DataSet} ds (optional) the dataset, * to which created objects are added * @constructor * @memberOf NodeBuilder * @name NodeBuilder */ exports.NodeBuilder = function (ds) { if (util.isSomething(ds)) { util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) this.ds = ds } } /** * Creates or configures a NodeBuilder which will add created nodes * to the dataset &lt;code&gt;ds&lt;/code&gt;. * * @example * const builder = require('josm/builder') * * // create a new node builder building to a data set * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * const ds = new DataSet() * * // ... using a static method ... * const nb1 = builder.NodeBuilder.forDataSet(ds) * // ... or the instance method * let nb2 = new builder.NodeBuilder() * nb = nb.forDataSet(ds) * * @returns {module:josm/builder.NodeBuilder} the node builder * @param {org.openstreetmap.josm.data.osm.DataSet} ds the dataset which * created objects are added to * @summary Creates a new NodeBuilder for a specific * {@class org.openstreetmap.josm.data.osm.DataSet}. * @function * @memberof module:josm/builder~NodeBuilder */ function forDataSet (ds) { const builder = receiver(this) util.assert(util.isSomething(ds), 'Expected a non-null defined object, got {0}', ds) util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) builder.ds = ds return builder } exports.NodeBuilder.prototype.forDataSet = forDataSet exports.NodeBuilder.forDataSet = forDataSet function receiver (that) { return typeof that === 'object' ? that : new exports.NodeBuilder() } function initFromObject (builder, args) { rememberIdFromObject(builder, args) rememberVersionFromObject(builder, args) rememberPosFromObject(builder, args) rememberTagsFromObject(builder, args) } /** * Creates a new {@class org.openstreetmap.josm.data.osm.Node}. * * Can be used in an instance or in a static context. * &lt;p&gt; * &lt;strong&gt;Optional named arguments in the parameter &lt;code&gt;options&lt;/code&gt;&lt;/strong&gt; * &lt;ul&gt; * &lt;li&gt;&lt;code&gt;version&lt;/code&gt; - the version of a global node (number &gt; 0)&lt;/li&gt; * &lt;li&gt;&lt;code&gt;lat&lt;/code&gt; - a valide latitude (number in the range * [-90,90])&lt;/li&gt; * &lt;li&gt;&lt;code&gt;lon&lt;/code&gt; - a valide longitude (number in the range * [-180,180])&lt;/li&gt; * &lt;li&gt;&lt;code&gt;pos&lt;/code&gt; - either an array &lt;code&gt;[lat,lon]&lt;/code&gt;, * an object &lt;code&gt;{lat: ..., lon: ...}&lt;/code&gt;, * or an instance of {@class org.openstreetmap.josm.data.coor.LatLon}&lt;/li&gt; * &lt;li&gt;&lt;code&gt;tags&lt;/code&gt; - an object with tags. Null values and undefined * values are ignored. Any other value is converted to a string. * Leading and trailing white space in keys is removed.&lt;/li&gt; * &lt;/ul&gt; * * * @example * const nb = require('josm/builder').NodeBuilder * // create a new local node at position [0,0] * const n1 = nb.create() * * // create a new global node at position [0,0] * const n2 = nb.create(12345) * * // create a new global way with version 3 at a specific position * // and with some tags * const n3 = nb.create(12345, { * version: 3, * lat: 23.45, * lon: 87.23, * tags: {amenity: 'restaurant'} * }) * * @param {number} [id] a global node id. If missing and * not set before using &lt;code&gt;withId(..)&lt;/code&gt;, creates a new local id. * @param {object} [options] additional options for creating the node * @returns {org.openstreetmap.josm.data.osm.Node} the created node * @summary Creates a new {@class org.openstreetmap.josm.data.osm.Node} * @function * @name create * @memberof module:josm/builder~NodeBuilder * @instance */ function create () { const builder = receiver(this) let arg switch (arguments.length) { case 0: break case 1: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') if (util.isNumber(arg)) { util.assert(arg &gt; 0, 'Argument 0: expected an id &gt; 0, got {0}', arg) builder.id = arg } else if (typeof arg === 'object') { initFromObject(builder, arg) } else { util.assert(false, \"Argument 0: unexpected type, got ''{0}''\", arg) } break case 2: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(arg), 'Argument 0: must be a number') util.assert(arg &gt; 0, 'Expected an id &gt; 0, got {0}', arg) builder.id = arg arg = arguments[1] if (util.isSomething(arg)) { util.assert(typeof arg === 'object', 'Argument 1: must be an object') initFromObject(builder, arg) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } let node if (util.isNumber(builder.id)) { if (util.isNumber(builder.version)) { node = new Node(builder.id, builder.version) } else { node = new Node(builder.id, 1) } const coor = new LatLon(builder.lat || 0, builder.lon || 0) node.setCoor(coor) } else { node = new Node(new LatLon(builder.lat || 0, builder.lon || 0)) } assignTags(node, builder.tags || {}) if (builder.ds) { if (builder.ds.getPrimitiveById(node) == null) { builder.ds.addPrimitive(node) } else { throw new Error( 'Failed to add primitive, primitive already included ' + 'in dataset. \\n' + 'primitive=' + node ) } } return node } exports.NodeBuilder.create = create exports.NodeBuilder.prototype.create = create /** * Creates a new &lt;em&gt;proxy&lt;/em&gt; * {@class org.openstreetmap.josm.data.osm.Node}. A proxy node is a node, * for which we only know its global id. In order to know more details * (position, tags, etc.), we would have to download it from the OSM server. * * * The method can be used in a static and in an instance context. * * @example * const nbuilder = require('josm/builder').NodeBuilder * * // a new proxy node for the global node with id 12345 * cons n1 = nbuilder.createProxy(12345) * * @param {number} id the node id (not null, number &gt; 0 expected) * @return {org.openstreetmap.josm.data.osm.Node} the new proxy node * @summary Creates a new &lt;em&gt;proxy&lt;/em&gt; {@class org.openstreetmap.josm.data.osm.Node} * @function * @name createProxy * @memberof module:josm/builder~NodeBuilder * @instance */ function createProxy (id) { const builder = receiver(this) util.assert(util.isSomething(id), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(id), 'Argument 0: expected a number, got {0}', id) util.assert(id &gt; 0, 'Argument 0: id &gt; 0 expected, got {0}', id) const node = new Node(id) if (builder.ds) builder.ds.addPrimitive(node) return node } exports.NodeBuilder.prototype.createProxy = exports.NodeBuilder.createProxy = createProxy /** * Declares the node position. * * The method can be used in a static and in an instance context. * * @example * const nbuilder = require('josm/builder').NodeBuilder * * // a new global node with the global id 12345 at position (34,45) * const n1 = nbuilder.withPosition(34,45).create(12345) * * // a new local node at position (23.2, 87.33) * const n2 = nbuilder.withPosition(23.3,87.33).create() * * @param {Number} lat the latitude. A number in the range [-90..90]. * @param {Number} lon the longitude. A number in the range [-180..180]. * @returns {module:josm/builder~NodeBuilder} a node builder (for method chaining) * @summary Declares the node position. * @function * @memberof module:josm/builder~NodeBuilder * @name withPosition * @instance */ function withPosition (lat, lon) { const builder = receiver(this) util.assert(util.isNumber(lat), 'Expected a number for lat, got {0}', lat) util.assert(util.isNumber(lon), 'Expected a number for lon, got {0}', lon) util.assert(LatLon.isValidLat(lat), 'Invalid lat, got {0}', lat) util.assert(LatLon.isValidLon(lon), 'Invalid lon, got {0}', lon) builder.lat = lat builder.lon = lon return builder } exports.NodeBuilder.prototype.withPosition = withPosition exports.NodeBuilder.withPosition = withPosition /** * Declares the tags to be assigned to the new node. * * The method can be used in a static and in an instance context. * * @example * const nbuilder = require('josm/builder').NodeBuilder * * // a new global node with the global id 12345 and tags name=test and * // highway=road * const n1 = nbuilder.withTags({'name':'test', 'highway':'road'}).global(12345) * * // a new local node tags name=test and highway=road * const tags = { * 'name' : 'test', * 'highway' : 'road' * } * const n2 = nbuilder.withTags(tags).local() * * @param {object} [tags] the tags * @returns {module:josm/builder~NodeBuilder} the node builder (for method chaining) * @summary Declares the node tags. * @function * @memberof module:josm/builder~NodeBuilder * @name withTags * @instance */ function withTags (tags) { const builder = typeof this === 'object' ? this : new exports.NodeBuilder() rememberTags(builder, tags) return builder } exports.NodeBuilder.prototype.withTags = withTags exports.NodeBuilder.withTags = withTags /** * Declares the global node id and the global node version. * * The method can be used in a static and in an instance context. * * @param {number} id (mandatory) the global node id. A number &gt; 0. * @param {number} version (optional) the global node version. If present, * a number &gt; 0. If missing, the version 1 is assumed. * @returns {module:josm/builder~NodeBuilder} the node builder (for method chaining) * @summary Declares the node id and version. * @function * @memberof module:josm/builder~NodeBuilder * @name withId * @instance */ function withId (id, version) { const builder = typeof this === 'object' ? this : new exports.NodeBuilder() rememberId(builder, id, version) return builder } exports.NodeBuilder.prototype.withId = withId exports.NodeBuilder.withId = withId }()); // end submodul NodeBuilder // ---------------------------------------------------------------------------- // WayBuilder // ---------------------------------------------------------------------------- (function () { // start submodul WayBuilder function receiver (that) { return typeof that === 'object' ? that : new exports.WayBuilder() } /** * WayBuilder helps to create OSM * {@class org.openstreetmap.josm.data.osm.Way}s. * * Methods of WayBuilder can be used in a static and in an instance context. * It isn't necessary to create an instance of WayBuilder, unless it is * configured with a {@class org.openstreetmap.josm.data.osm.DataSet}, * to which created ways are added. * @example * const WayBuilder = require('josm/builder').WayBuilder * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const ds = new DataSet() * // create a way builder without and underlying dataset ... * let wbuilder = new WayBuilder() * // ... with an underlying dataset .... * wbuilder = new WayBuilder(ds) * // ... or using this factory method * wbuilder = WayBuilder.forDataSet(ds) * * * // create a new local way * const w1 = wbuilder.create() * * // create a new global way * const w2 = wbuilder.withTags({highway: 'residential'}).create(123456) * * // create a new proxy for a global way * // (an 'incomplete' node in JOSM terminology) * const w3 = wbuilder.createProxy(123456) * * @class * @param {org.openstreetmap.josm.data.osm.DataSet} [ds] a JOSM * dataset which created ways are added to. If missing, the created ways * aren't added to a dataset. * @summary Helps to create OSM {@class org.openstreetmap.josm.data.osm.Way}s * @name WayBuilder */ /** * Creates a new builder for OSM ways * * @return {module:josm/builder~WayBuilder} the way builder * @param {org.openstreetmap.josm.data.osm.DataSet} ds the dataset which * created objects are added to * @summary Creates a new WayBuilder with an underlying dataset. * @function * @memberof module:josm/builder~WayBuilder * @name forDataSet */ exports.WayBuilder = function (ds) { if (util.isSomething(ds)) { util.assert(ds instanceof DataSet, 'Expected a DataSet, got {0}', ds) this.ds = ds } this.nodes = [] } /** * Creates or configures a WayBuilder which will add created nodes * to the dataset &lt;code&gt;ds&lt;/code&gt;. * * @example * const builder = require('josm/builder') * * // create a new way builder building to a data set * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet()') * const ds = new DataSet() * let wb = builder.WayBuilder.forDataSet(ds) * * // configure an existing way builder * wb = new builder.WayBuilder() * wb = wb.forDataSet(ds) * * @return {module:josm/builder~WayBuilder} the way builder * @param {org.openstreetmap.josm.data.osm.DataSet} ds the dataset which * created objects are added to * @summary Creates a new WayBuilder with an underlying dataset. * @function * @name forDataSet * @memberof module:josm/builder~WayBuilder */ function forDataSet (ds) { const builder = receiver(this) util.assert(util.isSomething(ds), 'Expected a non-null defined object, got {0}', ds) util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) builder.ds = ds return builder } exports.WayBuilder.prototype.forDataSet = forDataSet exports.WayBuilder.forDataSet = forDataSet /** * Declares the global way id and the global way version. * * The method can be used in a static and in an instance context. * * @example * const wbuilder = require('josm/builder').WayBuilder * // creates a global way with id 12345 an version 12 * const wb = wbuilder.withId(12345, 12).create() * * @param {number} id (mandatory) the global way id. A number &gt; 0. * @param {number} [version] the global way version. If present, * a number &gt; 0. If missing, the version 1 is assumed. * @return {module:josm/builder~WayBuilder} the way builder (for method chaining) * @summary Declares the global way id and the global way version. * @function * @memberof module:josm/builder~WayBuilder * @name withId * @instance */ function withId (id, version) { const builder = receiver(this) rememberId(builder, id, version) return builder } exports.WayBuilder.prototype.withId = withId exports.WayBuilder.withId = withId /** * Declares the tags to be assigned to the new way. * * The method can be used in a static and in an instance context. * * @example * const wbuilder = require('josm/builder').WayBuilder * // a new global way with the global id 12345 and tags name='Laubeggstrasse' * // and highway=residential * const w1 = wbuilder.withTags({name:'Laubeggstrasse', highway:'residential'}) * .create(12345) * * // a new local node tags name=test and highway=road * const tags = { * name : 'Laubeggstrasse', * highway : 'residential' * } * const w2 = wbuilder.withTags(tags).create() * * @param {object} [tags] the tags * @return {module:josm/builder~WayBuilder} the way builder (for method chaining) * @summary Declares the tags to be assigned to the new way. * @function * @memberof module:josm/builder~WayBuilder * @name withTags * @instance */ function withTags (tags) { const builder = receiver(this) rememberTags(builder, tags) return builder } exports.WayBuilder.prototype.withTags = withTags exports.WayBuilder.withTags = withTags /** * Declares the nodes of the way. * * Accepts either a vararg list of * {@class org.openstreetmap.josm.data.osm.Node}, * an array of {@class org.openstreetmap.josm.data.osm.Node}s or a Java list * of {@class org.openstreetmap.josm.data.osm.Node}s. At least &lt;strong&gt;two * non-identical nodes&lt;/strong&gt; have to be supplied. * The same node can occure more than once in the list, but a consecutive * sequence of the same node is collapsed to one node. * * * The method can be used in a static and in an instance context. * * @example * oonst wbuilder = require('josm/builder').WayBuilder * const nbuilder = require('josm/builder').NodeBuilder * // creates a new local way with two local nodes * const way = builder.withNodes( * nbuilder.create(), nbuilder.create() * ).create() * * @param nodes the list of nodes. See description and examples. * @return {module:josm/builder~WayBuilder} the way builder (for method chaining) * @summary Declares the nodes of the way. * @function * @memberof module:josm/builder~WayBuilder * @name withNodes * @instance */ function withNodes () { const builder = receiver(this) let nodes switch (arguments.length) { case 0: return builder case 1: nodes = arguments[0] if (util.isNothing(nodes)) return builder if (nodes instanceof Node) { nodes = [nodes] } else if (util.isArray(nodes)) { // OK } else if (nodes instanceof List) { const temp = [] for (let it = nodes.iterator(); it.hasNext();) temp.push(it.next()) nodes = temp } else { util.assert(false, 'Argument 0: expected a Node or a list of nodes, got {0}', nodes) } break default: nodes = Array.prototype.slice.call(arguments, 0) break } const newnodes = [] let last for (let i = 0; i &lt; nodes.length; i++) { const n = nodes[i] if (util.isNothing(n)) continue util.assert(n instanceof Node, 'Expected instances of Node only, got {0} at index {1}', n, i) // skip sequence of identical nodes if (last &amp;&amp; last.getUniqueId() === n.getUniqueId()) continue newnodes.push(n) last = n } builder.nodes = newnodes return builder } exports.WayBuilder.withNodes = exports.WayBuilder.prototype.withNodes = withNodes /** * Creates a new &lt;em&gt;proxy&lt;/em&gt; way. A proxy way is a way, for which we * only know its global id. In order to know more details (nodes, tags, etc.), * we would have to download it from the OSM server. * * The method can be used in a static and in an instance context. * * @example * const wbuilder = require('josm/builder').WayBuilder * * // a new proxy way for the global way with id 12345 * const w1 = wbuilder.createProxy(12345) * * @return {org.openstreetmap.josm.data.osm.Way} the new proxy way * @summary Creates a new proxy way * @function * @memberof module:josm/builder~WayBuilder * @name createProxy * @instance */ function createProxy (id) { const builder = receiver(this) if (util.isDef(id)) { util.assert(util.isNumber(id) &amp;&amp; id &gt; 0, 'Expected a number &gt; 0, got {0}', id) builder.id = id } util.assert(util.isNumber(builder.id), 'way id is not a number. Use .createProxy(id) or ' + '.withId(id).createProxy()') util.assert(builder.id &gt; 0, 'Expected way id &gt; 0, got {0}', builder.id) const way = new Way(builder.id) if (builder.ds) builder.ds.addPrimitive(way) return way } exports.WayBuilder.createProxy = exports.WayBuilder.prototype.createProxy = createProxy function rememberNodesFromObject (builder, args) { if (!util.hasProp(args, 'nodes')) return const o = args.nodes if (!util.isSomething(o)) return util.assert(util.isArray(o) || o instanceof List, 'Expected an array or an instance of java.util.List, got {0}', o) builder.withNodes(o) } function initFromObject (builder, args) { rememberIdFromObject(builder, args) rememberVersionFromObject(builder, args) rememberTagsFromObject(builder, args) rememberNodesFromObject(builder, args) } /** * Creates a new way. * * Can be used in an instance or in a static context. * * Optional named arguments in the parameters &lt;code&gt;options&lt;/code&gt;: * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;id&lt;/code&gt;:number&lt;/dt&gt; * &lt;dd&gt;the id of a global way (number &gt; 0)&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;version&lt;/code&gt;:number&lt;/dt&gt; * &lt;dd&gt;the version of a global way (number &gt; 0)&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;nodes&lt;/code&gt;:array|list&lt;/dt&gt; * &lt;dd&gt;an array or a list of nodes&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;tags&lt;/code&gt;:object&lt;/dt&gt; * &lt;dd&gt;an object with tags. Null values and undefined values are ignored. * Any other value is converted to a string. Leading and trailing white * space in keys is removed.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const wb = require('josm/builder').WayBuilder * // create a new local way * const w1 = wb.create() * * // create a new global way * const w2 = wb.create(12345) * * // create a new global way with version 3 at a specific position and with * // some tags * const w3 = wb.create(12345, { * version: 3, * tags: {amenity: 'restaurant'}, * nodes: [n1,n2,n3] * }) * * @param {number} [id] a global way id. If missing and not set * before using &lt;code&gt;withId(..)&lt;/code&gt;, creates a new local id. * @param {object} [options] additional parameters for creating the way * @returns {org.openstreetmap.josm.data.osm.Way} the created way * @summary Creates a new way * @function * @memberof module:josm/builder~WayBuilder * @name create * @instance */ function create () { const builder = receiver(this) let arg switch (arguments.length) { case 0: break case 1: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') if (util.isNumber(arg)) { util.assert(arg &gt; 0, 'Argument 0: expected an id &gt; 0, got {0}', arg) builder.id = arg } else if (typeof arg === 'object') { initFromObject(builder, arg) } else { util.assert(false, \"Argument 0: unexpected type, got ''{0}''\", arg) } break case 2: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(arg), 'Argument 0: must be a number') util.assert(arg &gt; 0, 'Expected an id &gt; 0, got {0}', arg) builder.id = arg arg = arguments[1] if (util.isSomething(arg)) { util.assert(typeof arg === 'object', 'Argument 1: must be an object') initFromObject(builder, arg) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } let way if (util.isNumber(builder.id)) { if (util.isNumber(builder.version)) { way = new Way(builder.id, builder.version) } else { way = new Way(builder.id, 1) } } else { way = new Way(0) // creates a new local way } assignTags(way, builder.tags || {}) if (builder.nodes &amp;&amp; builder.nodes.length &gt; 0) { way.setNodes(builder.nodes) } if (builder.ds) { if (builder.ds.getPrimitiveById(way) == null) { builder.ds.addPrimitive(way) } else { throw new Error( 'Failed to add primitive, primitive already included ' + 'in dataset. \\n' + 'primitive=' + way ) } } return way } exports.WayBuilder.create = create exports.WayBuilder.prototype.create = create }()); // end submodul WayBuilder // ---------------------------------------------------------------------------- // RelationBuilder // ---------------------------------------------------------------------------- (function () { // start submodul Relation Builder function receiver (that) { return typeof that === 'object' ? that : new exports.RelationBuilder() } /** * RelationBuilder helps to create OSM * {@class org.openstreetmap.josm.data.osm.Relation}s. * * Methods of RelationBuilder can be used in a static and in an instance * context. * It isn't necessary to create an instance of RelationBuilder, unless it is * configured with a {@class org.openstreetmap.josm.data.osm.DataSet}, * which created ways are added to. * @example * const RelationBuilder = require('josm/builder').RelationBuilder * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const ds = new DataSet() * // create a relation builder without and underlying dataset ... * const rbuilder = new RelationBuilder() * // ... with an underlying dataset ... * rbuilder = new RelationBuilder(ds) * // ... or using this factory method * rbuilder = RelationBuilder.forDataSet(ds) * * // create a new local relation * const r1 = rbuilder.create() * * // create a new global way * const r2 = rbuilder.withTags({route: 'bicycle'}).create(123456) * * // create a new proxy for a global relation * // (an 'incomplete' node in JOSM terminology) * const r3 = rbuilder.createProxy(123456) * * @class * @param {org.openstreetmap.josm.data.osm.DataSet} ds (optional) a JOSM * dataset which created ways are added to. If missing, the created ways * aren't added to a dataset. * @name RelationBuilder * @summary Helps to create {@class org.openstreetmap.josm.data.osm.Relation}s */ exports.RelationBuilder = function (ds) { if (util.isSomething(ds)) { util.assert(ds instanceof DataSet, 'Expected a DataSet, got {0}', ds) this.ds = ds } this.members = [] } /** * Creates or configures a RelationBuilder which will add created nodes * to the dataset &lt;code&gt;ds&lt;/code&gt;. * * @example * const builder = require('josm/builder') * * // create a new relation builder building to a data set * const DataSet = Java.type('org.openstreetmap.josm.data.osm') * const ds = new DataSet() * const rb = builder.RelationBuilder.forDataSet(ds) * * // configure an existing relation builder * let wb = new builder.RelationBuilder() * wb = wb.forDataSet(ds) * * @return {module:josm/builder.RelationBuilder} the relation builder * @summary Creates a new RelationBuilder which adds created relations to a * dataset * @param {org.openstreetmap.josm.data.osm.DataSet} ds a JOSM * dataset which created ways are added to. * @function * @name forDataSet * @memberof module:josm/builder~RelationBuilder */ function forDataSet (ds) { const builder = receiver(this) util.assert(util.isSomething(ds), 'Expected a non-null defined object, got {0}', ds) util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) builder.ds = ds return builder } exports.RelationBuilder.prototype.forDataSet = forDataSet exports.RelationBuilder.forDataSet = forDataSet /** * Create a RelationMember * * &lt;dl&gt; * &lt;dt&gt;member(role, obj)&lt;/dt&gt; * &lt;dd&gt;Create a relation member with role &lt;var&gt;role&lt;/var&gt; and member object * &lt;var&gt;obj&lt;/var&gt;. &lt;var&gt;role&lt;/var&gt; can be null or undefined, obj must neither * be null nor undefinde. &lt;var&gt;role&lt;/var&gt; is a string, &lt;var&gt;obj&lt;/var&gt; is an * OSM node, a way, or a relation. * &lt;/dd&gt; * &lt;dt&gt;member(obj)&lt;/dt&gt; * &lt;dd&gt;Create a relation member for the member object &lt;var&gt;obj&lt;/var&gt;. * &lt;var&gt;obj&lt;/var&gt; must neither be null nor undefinde. &lt;var&gt;obj&lt;/var&gt; is an * OSM node, a way, or a relation. The created relation member has no role. * &lt;/dd&gt; * &lt;/dl&gt; * * @example * const member = require('josm/builder').RelationBuilder.member * const nb = require('josm/builder').NodeBuilder * * // create a new RelationMember with role 'house' for a new node * const m1 = member('house', nb.create()) * // create a new RelationMember with an empty role for a new node * const m2 = member(nb.create()) * * @static * @returns {org.openstreetmap.josm.data.osm.RelationMember} the relation member * @summary Utility function - creates a relation member * @memberof module:josm/builder~RelationBuilder * @name member * @function * @param {string} [role] the member role * @param {primitive} primitive the member primitive */ function member () { function normalizeObj (obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined') util.assert(obj instanceof OsmPrimitive, 'obj: expected an OsmPrimitive, got {0}', obj) return obj } function normalizeRole (role) { if (util.isNothing(role)) return null util.assert(util.isString(role), 'role: expected a string, got {0}', role) return role } let obj let role switch (arguments.length) { case 0: util.assert(false, 'Expected arguments (object) or (role, object), got 0 arguments') break case 1: obj = normalizeObj(arguments[0]) return new RelationMember(null /* no role */, obj) case 2: role = normalizeRole(arguments[0]) obj = normalizeObj(arguments[1]) return new RelationMember(role, obj) default: util.assert(false, 'Expected arguments (object) or (role, object), got {0} arguments', arguments.length) } } exports.RelationBuilder.member = member /** * Declares the global relation id and the global relation version. * * The method can be used in a static and in an instance context. * * @example * const rbuilder = require('josm/builder').RelationBuilder * // creates a global relation with id 12345 an version 12 * const r = rbuilder.withId(12345, 12).create() * * @param {number} id (mandatory) the global relation id. A number &gt; 0. * @param {number} version (optional) the global relation version. If present, * a number &gt; 0. If missing, the version 1 is assumed. * @returns {module:josm/builder~RelationBuilder} the relation builder (for method chaining) * @summary Declares the relation id and version. * @memberof module:josm/builder~RelationBuilder * @name withId * @function * @instance */ function withId (id, version) { const builder = receiver(this) rememberId(builder, id, version) return builder } exports.RelationBuilder.prototype.withId = withId exports.RelationBuilder.withId = withId /** * Declares the tags to be assigned to the new relation. * * The method can be used in a static and in an instance context. * * @example * const rbuilder = require('josm/builder').RelationBuilder * // a new global relation with the global id 12345 and tags route='bicycle' * //and name='n8' * const r1 = rbuilder.withTags({name:'n8', route:'bicycle'}).create(12345) * * // a new local node tags name=test and highway=road * const tags = { * name : 'n8', * route : 'bicycle' * } * const r2 = rbuilder.withTags(tags).create() * * @param {object} [tags] the tags * @returns {module:josm/builder~RelationBuilder} a relation builder (for method chaining) * @summary Declares the tags to be assigned to the new relation. * @memberof module:josm/builder~RelationBuilder * @name withTags * @function * @instance */ function withTags (tags) { const builder = receiver(this) rememberTags(builder, tags) return builder } exports.RelationBuilder.prototype.withTags = withTags exports.RelationBuilder.withTags = withTags /** * Creates a new &lt;em&gt;proxy&lt;/em&gt; relation. A proxy relation is a relation, * for which we only know its global id. In order to know more details * (members, tags, etc.), we would have to download it from the OSM server. * * * The method can be used in a static and in an instance context. * * @example * const rbuilder = require('josm/builder').RelationBuilder * * // a new proxy relation for the global way with id 12345 * const r1 = rbuilder.createProxy(12345) * * @returns {org.openstreetmap.josm.data.osm.Relation} the new proxy relation * @summary Creates a new &lt;em&gt;proxy&lt;/em&gt; relation. * @memberof module:josm/builder~RelationBuilder * @function * @name createProxy * @instance * @param {number} id the id for the proxy relation */ function createProxy (id) { const builder = receiver(this) if (util.isDef(id)) { util.assert(util.isNumber(id) &amp;&amp; id &gt; 0, 'Expected a number &gt; 0, got {0}', id) builder.id = id } util.assert(util.isNumber(builder.id), 'way id is not a number. Use .createProxy(id) or ' + '.withId(id).createProxy()') util.assert(builder.id &gt; 0, 'Expected id &gt; 0, got {0}', builder.id) const relation = new Relation(builder.id) if (builder.ds) builder.ds.addPrimitive(relation) return relation } exports.RelationBuilder.createProxy = createProxy exports.RelationBuilder.prototype.createProxy = createProxy /** * Declares the members of a relation. * * Accepts either a vararg list of relation members, nodes, ways or * relations, an array of relation members, nodes ways or relations, or a * Java list of members, nodes, ways or relation. * * * The method can be used in a static and in an instance context. * * @example * const rbuilder = require('josm/builder').RelationBuilder * const nbuilder = require('josm/builder').NodeBuilder * const wbuilder = require('josm/builder').WayBuilder * const member = require('josm/builder').RelationBuilder.member * * const r1 = rbuilder.withMembers( * member('house', nbuilder.create()), * member('house', nbuilder.create()), * member('street', wbuilder.create()) * ).create() * * * @param nodes the list of members. See description and examples. * @returns {module:josm/builder~RelationBuilder} the relation builder (for method chaining) * @summary Declares the members of a relation. * @memberof module:josm/builder~RelationBuilder * @function * @name withMembers * @instance */ function withMembers () { const builder = receiver(this) const members = [] function remember (obj) { if (util.isNothing(obj)) return if (obj instanceof OsmPrimitive) { members.push(new RelationMember(null, obj)) } else if (obj instanceof RelationMember) { members.push(obj) } else if (util.isArray(obj)) { for (let i = 0; i &lt; obj.length; i++) remember(obj[i]) } else if (obj instanceof List) { for (let it = obj.iterator(); it.hasNext();) remember(it.next()) } else { util.assert(false, \"Can''t add object ''{0}'' as relation member\", obj) } } for (let i = 0; i &lt; arguments.length; i++) { remember(arguments[i]) } builder.members = members return builder } exports.RelationBuilder.withMembers = withMembers exports.RelationBuilder.prototype.withMembers = withMembers function rememberMembersFromObject (builder, args) { if (!util.hasProp(args, 'members')) return const o = args.members if (!util.isSomething(o)) return util.assert(util.isArray(o) || o instanceof List, 'members: Expected an array or an instance of java.util.List, got {0}', o) builder.withMembers(o) } function initFromObject (builder, args) { rememberIdFromObject(builder, args) rememberVersionFromObject(builder, args) rememberTagsFromObject(builder, args) rememberMembersFromObject(builder, args) } /** * Creates a new relation. * * Can be used in an instance or in a static context. * * &lt;strong&gt;Optional named arguments in the parameters &lt;code&gt;args&lt;/code&gt; * &lt;/strong&gt; * &lt;ul&gt; * &lt;li&gt;&lt;var&gt;id&lt;/var&gt; - the id of a global relation (number &gt; 0)&lt;/li&gt; * &lt;li&gt;&lt;var&gt;version&lt;/var&gt; - the version of a global relation (number &gt; 0) * &lt;/li&gt; * &lt;li&gt;&lt;var&gt;members&lt;/var&gt; - an array or a list of relation members, nodes, * ways, or relation&lt;/li&gt; * &lt;li&gt;&lt;var&gt;tags&lt;/var&gt; - an object with tags. Null values and undefined * values are ignored. Any other value * is converted to a string. Leading and trailing white space in keys is * removed.&lt;/li&gt; * &lt;/ul&gt; * * * @example * const { NodeBuilder, RelationBuilder } = require('josm/builder') * const member = RelationBuilder.member * // create a new local relation * const r1 = rb.create() * * // create a new global relation * const r2 = rb.create(12345) * * // create a new global relation with version 3 with some tags and two * // members * const r3 = rb.create(12345, { * version: 3, * tags: {type: 'route'}, * members: [member('house', nb.create()), member(nb.create())] * }) * * @param {number} [id] a global way id. If missing and not set * before using &lt;code&gt;withId(..)&lt;/code&gt;, creates a new local id. * @param {object} [args] additional parameters for creating the relation * @returns {org.openstreetmap.josm.data.osm.Relation} the relation * @summary Creates a new relation. * @memberof module:josm/builder~RelationBuilder * @function * @name create * @instance */ function create () { const builder = receiver(this) let arg switch (arguments.length) { case 0: break case 1: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') if (util.isNumber(arg)) { util.assert(arg &gt; 0, 'Argument 0: expected an id &gt; 0, got {0}', arg) builder.id = arg } else if (typeof arg === 'object') { initFromObject(builder, arg) } else { util.assert(false, \"Argument 0: unexpected type, got ''{0}''\", arg) } break case 2: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(arg), 'Argument 0: must be a number') util.assert(arg &gt; 0, 'Expected an id &gt; 0, got {0}', arg) builder.id = arg arg = arguments[1] if (util.isSomething(arg)) { util.assert(typeof arg === 'object', 'Argument 1: must be an object') initFromObject(builder, arg) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } let relation if (util.isNumber(builder.id)) { if (util.isNumber(builder.version)) { relation = new Relation(builder.id, builder.version) } else { relation = new Relation(builder.id, 1) } } else { relation = new Relation(0) // creates a new local reöatopm } assignTags(relation, builder.tags || {}) if (builder.members &amp;&amp; builder.members.length &gt; 0) { relation.setMembers(builder.members) } if (builder.ds) { if (builder.ds.getPrimitiveById(relation) == null) { builder.ds.addPrimitive(relation) } else { throw new Error( 'Failed to add primitive, primitive already included ' + 'in dataset. \\n' + 'primitive=' + relation ) } } return relation } exports.RelationBuilder.create = create exports.RelationBuilder.prototype.create = create }()) // end submodul Relation Builder × Search results Close "},"josm_command.js.html":{"id":"josm_command.js.html","title":"Source: josm/command.js","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/command.js /** * A collection of functions to create commands which can be applied, undone * and redone on {@class org.openstreetmap.josm.gui.layer.OsmDataLayer}s. * * @module josm/command */ // org.openstreetmap.josm.plugins.scripting.js.api.AddMultiCommand is populated // in the context /* global AddMultiCommand */ // org.openstreetmap.josm.plugins.scripting.js.api.ChangeMultiCommand is populated // in the context /* global ChangeMultiCommand */ // org.openstreetmap.josm.plugins.scripting.js.api.Change is populated in the // context /* global Change */ /* global Java */ /* global require */ const util = require('josm/util') const layers = require('josm/layers') const OsmPrimitive = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitive') const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') const Layer = Java.type('org.openstreetmap.josm.gui.layer.Layer') const UndoRedoHandler = Java.type('org.openstreetmap.josm.data.UndoRedoHandler') const CombineWayAction = Java.type('org.openstreetmap.josm.actions.CombineWayAction') const DeleteCommand = Java.type('org.openstreetmap.josm.command.DeleteCommand') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const RelationMember = Java.type('org.openstreetmap.josm.data.osm.RelationMember') const ArrayList = Java.type('java.util.ArrayList') const Map = Java.type('java.util.Map') const HashMap = Java.type('java.util.HashMap') const HashSet = Java.type('java.util.HashSet') const Collection = Java.type('java.util.Collection') const Command = Java.type('org.openstreetmap.josm.command.Command') const System = Java.type('java.lang.System') function checkAndFlatten (primitives) { const ret = new HashSet() function visit (value) { if (util.isNothing(value)) return if (util.isCollection(value)) { util.each(value, visit) } else if (value instanceof OsmPrimitive) { ret.add(value) } else { util.assert(false, 'Unexpected object to add as OSM primitive, got {0}', value) } } visit(primitives) return ret } function applyTo (layer) { util.assert(util.isSomething(layer), 'layer: must not be null or undefined') util.assert(layer instanceof OsmDataLayer, 'layer: expected OsmDataLayer, got {0}', layer) const cmd = this.createJOSMCommand(layer) try { layer.getDataSet().beginUpdate() UndoRedoHandler.getInstance().add(cmd) } finally { layer.getDataSet().endUpdate() } } function toArray (collection) { if (util.isArray(collection)) return collection if (collection instanceof Collection) { const ret = [] for (const it = collection.iterator(); it.hasNext();) ret.push(it.next()) return ret } } /** * A command to add a collection of objects to a data layer. * * @class * @name AddCommand * @summary A command to add a collection of objects to a data layer * @param { java.util.Collection| array } objs the objects to add */ exports.AddCommand = function (objs) { util.assert(objs, 'objs: mandatory parameter missing') this._objs = toArray(checkAndFlatten(objs)) } /** * Applies the command to a layer. * * @function * @summary Applies the command to a layer. * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @instance * @memberof module:josm/command.AddCommand * @name applyTo */ exports.AddCommand.prototype.applyTo = applyTo /** * Creates the internal JOSM command for this command * * @function * @summary Creates the internal JOSM command for this command * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @returns {org.openstreetmap.josm.command.Command} the command * @memberof module:josm/command.AddCommand * @name createJOSMCommand * @instance */ exports.AddCommand.prototype.createJOSMCommand = function (layer) { util.assert(util.isSomething(layer), 'layer: must not be null or undefined') util.assert(layer instanceof OsmDataLayer, 'layer: expected OsmDataLayer, got {0}', layer) const list = new ArrayList() for (let i = 0; i &lt; this._objs.length; i++) { const o = this._objs[i] list.add(o) } return new AddMultiCommand(layer, list) } /** * Creates a command to add a collection of objects to a data layer. * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;add(obj, obj, ...)&lt;/code&gt; &lt;/dt&gt; * &lt;dd&gt;&lt;code&gt;obj&lt;/code&gt; are {@class org.openstreetmap.josm.data.osm.Node}s, * {@class org.openstreetmap.josm.data.osm.Way}s, or * {@class org.openstreetmap.josm.data.osm.Relations}s. Or javascript array * or Java collections thereof.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const cmd = require('josm/command') * const layers = require('josm/layer') * const layer = layers.get('Data Layer 1') * * // add two nodes * cmd.add(n1,n1).applyTo(layer) * * // add an array of two nodes and a way * layer.apply( * cmd.add([n1,n2,w2]) * ) * * @function * @summary Creates a command to add a collection of objects * @param {...(primitive | primitive[] | java.lang.Collection )} primitives the primitives to add * @name add * @static * @returns {module:josm/command.AddCommand} the command object */ exports.add = function () { const objs = checkAndFlatten(arguments) return new exports.AddCommand(objs) } /** * A command to delete a collection of objects in a data layer. * * @class * @param {java.util.Collection|array} objs the objects to add * @summary A command to delete a collection of objects in a data layer. * @param {java.util.Collection|array} objs the objects to add */ exports.DeleteCommand = function (objs) { this._objs = checkAndFlatten(objs) } /** * Applies the command to a layer. * * @function * @summary Applies the command to a layer. * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @memberof module:josm/command.DeleteCommand * @instance * @name applyTo */ exports.DeleteCommand.prototype.applyTo = applyTo /** * Creates the internal JOSM command for this command * * @function * @summary Creates the internal JOSM command for this command * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @returns {org.openstreetmap.josm.command.Command} the command object * @instance * @name createJOSMCommand * @memberof module:josm/command.DeleteCommand */ exports.DeleteCommand.prototype.createJOSMCommand = function (layer) { util.assert(util.isSomething(layer), 'layer: must not be null or undefined') util.assert(layer instanceof OsmDataLayer, 'layer: expected OsmDataLayer, got {0}', layer) return DeleteCommand.delete(this._objs, true /* alsoDeleteNodesInWay */, true /* silent */) } /** * Creates a command to delete a collection of objects in a data layer. * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;delete(obj,obj,..., ?options)&lt;/code&gt; &lt;/dt&gt; * &lt;dd&gt;&lt;code&gt;obj&lt;/code&gt; are {@class org.openstreetmap.josm.data.osm.Node}s, * {@class org.openstreetmap.josm.data.osm.Way}s, or * {@class org.openstreetmap.josm.data.osm.Relations}s. Or javascript array * or Java collections thereof.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const cmd = require('josm/command') * const layers= require('josm/layer') * const layer = layers.get('Data Layer 1') * * // delete two nodes * cmd.delete(n1,n1).applyTo(layer) * * // delete an array of two nodes and a way * layer.apply( * cmd.delete([n1,n2,w2]) * ) * * @function * @summary Creates a command to delete a collection of objects * @param {...(primitive | primitive[] | java.lang.Collection )} primitives the primitives to delete * @static * @name delete * @returns {module:josm/command.DeleteCommand} the command object */ exports.delete = function () { return new exports.DeleteCommand(checkAndFlatten(arguments)) } function scheduleLatChangeFromPara (para, change) { if (!para || !util.isDef(para.lat)) return util.assert(util.isNumber(para.lat), 'lat: lat must be a number, got {0}', para.lat) util.assert(LatLon.isValidLat(para.lat), 'lat: expected a valid lat, got {0}', para.lat) change.withLatChange(para.lat) } function scheduleLonChangeFromPara (para, change) { if (!para || !util.isDef(para.lon)) return util.assert(util.isNumber(para.lon), 'lon: lon must be a number, got {0}', para.lon) util.assert(LatLon.isValidLon(para.lon), 'lon: expected a valid lon, got {0}', para.lon) change.withLonChange(para.lon) } function buildLatLon (obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined') util.assert(typeof obj === 'object', 'obj: expected an object, got {0}', obj) util.assert(util.isNumber(obj.lat), 'obj.lat: expected a number, got {0}', obj.lat) util.assert(util.isNumber(obj.lon), 'obj.lon: expected a number, got {0}', obj.lon) util.assert(LatLon.isValidLat(obj.lat), 'obj.lat: expected a valid lat in the range [-90,90], got {0}', obj.lat) util.assert(LatLon.isValidLon(obj.lon), 'obj.lon: expected a valid lon in the range [-180,180], got {0}', obj.lon) return new LatLon(obj.lat, obj.lon) } function schedulePosChangeFromPara (para, change) { if (!para || !util.isDef(para.pos)) return util.assert(para.pos, 'pos must no be null') let pos = para.pos if (pos instanceof LatLon) { // OK } else if (typeof pos === 'object') { pos = buildLatLon(pos) } else { util.assert(false, 'pos: unexpected value, expected LatLon or object, got {0}', pos) } change.withPosChange(pos) } function scheduleNodeChangeFromPara (para, change) { if (!para || !util.isDef(para.nodes)) return // convert to a Java List ... const l = new ArrayList() for (let i = 0; i &lt; para.nodes.length; i++) { l.add(para.nodes[i]) } // ... and pass it to the change command change.withNodeChange(l) } function scheduleMemberChangeFromPara (para, change) { if (!para || !util.isDef(para.members)) return const l = new ArrayList() if (para.members instanceof RelationMember) { l.add(para.members) } else if (para.members instanceof Collection) { l.addAll(para.members) } else if (util.isArray(para.members)) { for (let i = 0; i &lt; para.members.length; i++) { l.add(para.members[i]) } } else { util.assert(false, 'Expected RelationMember, array or collection ' + 'of RelationMembers, got {0}', para.members) } change.withMemberChange(l) } function scheduleTagsChangeFromPara (para, change) { if (!para || !util.isDef(para.tags)) return util.assert(para.tags, 'tags must no be null') let tags = para.tags if (tags instanceof Map) { // OK } else if (typeof tags === 'object') { const map = new HashMap() for (let key in tags) { if (!util.hasProp(tags, key)) continue const value = tags[key] key = util.trim(key) map.put(key, value) } tags = map } else { util.assert(false, 'tags: unexpected value, expected Map or object, got {0}', tags) } change.withTagsChange(tags) } function changeFromParameters (para) { const change = new Change() scheduleLatChangeFromPara(para, change) scheduleLonChangeFromPara(para, change) schedulePosChangeFromPara(para, change) scheduleTagsChangeFromPara(para, change) scheduleNodeChangeFromPara(para, change) scheduleMemberChangeFromPara(para, change) return change } /** * A command to change a collection of objects in a data layer. * * @class * @param {java.util.Collection|array} objs the objects to change * @param {org.openstreetmap.josm.plugins.scripting.js.api.Change} change the change specification * @summary A command to change a collection of objects in a data layer. */ exports.ChangeCommand = function (objs, change) { this._objs = checkAndFlatten(objs) this._change = change } /** * Applies the command to a layer. * * @function * @summary Applies the command to a layer. * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @memberof module:josm/command.ChangeCommand * @instance * @name applyTo */ exports.ChangeCommand.prototype.applyTo = applyTo /** * Creates the internal JOSM command for this command * * @summary Creates the internal JOSM command for this command * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @returns {org.openstreetmap.josm.command.Command} the command object * @instance * @function * @name createJOSMCommand * @memberof module:josm/command.ChangeCommand */ exports.ChangeCommand.prototype.createJOSMCommand = function (layer) { util.assert(util.isSomething(layer), 'layer: must not be null or undefined') util.assert(layer instanceof OsmDataLayer, 'layer: expected OsmDataLayer, got {0}', layer) return new ChangeMultiCommand(layer, this._objs, this._change) } /** * Creates a command to change a collection of objects in a data layer. * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;change(obj,obj,..., options)&lt;/code&gt; &lt;/dt&gt; * &lt;dd&gt;&lt;code&gt;obj&lt;/code&gt; are {@class org.openstreetmap.josm.data.osm.Node}s, * {@class org.openstreetmap.josm.data.osm.Way}s, or * {@class org.openstreetmap.josm.data.osm.Relations}s. Or javascript array * or Java collections thereof.&lt;/dd&gt; * &lt;/dl&gt; * * The mandatory last argument is an object with named parameters. It accepts * the following named parameters: * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;lat:number&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Changes the latitude of the target nodes to &lt;code&gt;lat&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;lon:number&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Changes the longitude of the target nodes to &lt;code&gt;lon&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;pos: * {@class org.openstreetmap.josm.data.coor.LatLon}|object&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Changes the position of the target nodes to &lt;code&gt;pos&lt;/code&gt;. * pos is either a {@class org.openstreetmap.josm.data.coor.LatLon} or an * object &lt;code&gt;{lat:..., lon:...}&lt;/code&gt; * &lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;tags:{@class java.util.Map}|object&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Changes the tags of the target objects to &lt;code&gt;tags&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;nodes:{@class java.util.List}|array&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Changes the nodes of the target way sto &lt;code&gt;nodes&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;members:{@class java.util.List}|array&lt;/code&gt; * &lt;/dt&gt; * &lt;dd&gt;Changes the nodes of the target relations to &lt;code&gt;members&lt;/code&gt;.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const cmd = require(\"josm/command\") * const layers = require(\"josm/layer\") * const layer = layers.get(\"Data Layer 1\") * * // change the position of a node * cmd.change(n1,n1, {lat: 123.45, lon: 44.234}).applyTo(layer) * * // change the nodes of a way * layer.apply( * cmd.change(w2, {nodes: [n1,n2,3]}) * ) * * // change the tags of a collection of primitives * cmd.change(n1,n3, w1,r1, { * tags: {'mycustommtag': 'value'} * }).applyTo(layer) * * @function * @summary Creates a command to change a collection of objects * @name change * @returns {module:josm/command.ChangeCommand} the change command object * @static */ exports.change = function () { let objs = [] let change switch (arguments.length) { case 0: util.assert(false, 'Unexpected number of arguments, got {0} arguments', arguments.length) break default: { const a = arguments[arguments.length - 1] if (a instanceof OsmPrimitive) { util.assert(false, 'Argument {0}: unexpected last argument, expected named ' + 'parameters, got {0}', a) } else if (typeof a === 'object') { // last argument is an object with named parameters objs = Array.prototype.slice.call(arguments, 0, -1) change = changeFromParameters(a) } else { util.assert(false, 'Argument {0}: unexpected type of value, got {1}', arguments.length - 1, a) } } } const tochange = checkAndFlatten(objs) return new exports.ChangeCommand(tochange, change) } /** * Accessor to the global command history. * &lt;p&gt; * Provides static methods to redo and undo commands. * * @class * @summary Accessor to the global command history */ exports.CommandHistory = function() {} /** * Undoes the last &lt;code&gt;depth&lt;/code&gt; commands. * * @static * @summary Undoes the last &lt;code&gt;depth&lt;/code&gt; commands. * @param {number} [depth=1] the number of commands to be undone * @memberof module:josm/command.CommandHistory * @function * @name undo */ exports.CommandHistory.undo = function (depth) { if (util.isDef(depth)) { util.assert(util.isNumber(depth), 'depth: expected a number, got {0}', depth) util.assert(depth &gt; 0, 'depth: expected number &gt; 0, got {0}', depth) } const undoRedoHandler = UndoRedoHandler.getInstance() if (depth) { undoRedoHandler.undo(depth) } else { undoRedoHandler.undo() } } /** * Redoes the last &lt;code&gt;depth&lt;/code&gt; commands. * * @static * @summary Redoes the last &lt;code&gt;depth&lt;/code&gt; commands. * @param {number} [depth=1] the number of commands to be redone. * @memberof module:josm/command.CommandHistory * @function * @name redo */ exports.CommandHistory.redo = function (depth) { if (util.isDef(depth)) { util.assert(util.isNumber(depth), 'depth: expected a number, got {0}', depth) util.assert(depth &gt; 0, 'depth: expected number &gt; 0, got {0}', depth) } const undoRedoHandler = UndoRedoHandler.getInstance() if (depth) { undoRedoHandler.redo(depth) } else { undoRedoHandler.redo() } } /** * Removes commands in the command history, either all commands, or only the * commands applied to a specific layer. * * @static * @summary Removes commands in the command history * @param {org.openstreetmap.josm.gui.layer.Layer} [layer] the * reference layer. Only commands applied to this layer are removed. Default * if missing: &lt;strong&gt;all&lt;/strong&gt; commands are removed. * @memberof module:josm/command.CommandHistory * @function * @name clear */ exports.CommandHistory.clear = function (layer) { const undoRedoHandler = UndoRedoHandler.getInstance() function clearAll () { undoRedoHandler.clean() } function clearForLayer (layer) { undoRedoHandler.clean(layer) } switch (arguments.length) { case 0: clearAll(); break case 1: { const layer = arguments[0] util.assert(layer instanceof Layer, 'Expected a Layer, got {0}', layer) clearForLayer(layer) break } default: util.assert(false, 'Unexpected number of arguments') } } /** * Combines two or more ways into one resulting way. * &lt;p&gt; * Reuses the logic behind the JOSM standard menu entry Tools-&amp;gt;Combine Ways. * If invoked from a script, this may trigger modal dialogs which are presented * to the user, in particular if the direction of the ways has to be reversed * because otherwise they could not be combined. * * @param ways the ways to be combined * @example * const cmd = require('josm/command') * const layers = require('josm/layer') * const ds = layers.activeLayer.data * const ways = [ds.way(1), ds.way(2), ds.way(3)] * * // pass in an array ... * cmd.combineWays(ways) * // ... or the individual ways ... * cmd.combineWays(ds.way(1), ds.way(2), ds.way(3)) * // ... or any combination thereof. * * @function * @summary Combines two or more ways into one resulting way. * @param {...org.openstreetmap.josm.data.osm.Way | array} ways the ways to be combined * @static * @name combineWays */ exports.combineWays = function () { // ways becomes a java.util.HashSet const ways = checkAndFlatten(arguments) // remove any primitives which are not nodes from the arguments const it = ways.iterator() while (it.hasNext()) { const primitive = it.next() if (primitive == null || !primitive.isWay) { it.remove() } } // at least two remaining ways required to combine them. If less, just // return, don't throw if (ways.size() &lt;= 1) return const activeLayer = layers.activeLayer if (activeLayer == null) return const ret = CombineWayAction.combineWaysWorker(ways) // happens, if combineWayWorkers presents a modal dialog and the user // aborts it if (ret == null) return // ret.b is the SequenceCommand which combines the ways into one // resulting ways. Apply this command to the active layer. activeLayer.apply(ret.b) } /** * Combines the currently selected ways in the active layer into one resulting * way. * * Returns without effect if * &lt;ul&gt; * &lt;li&gt;there is no active layer&lt;/li&gt; * &lt;li&gt;the active layer is not a data layer&lt;/li&gt; * &lt;li&gt;there are less than two selected ways in the active layer&lt;/li&gt; * &lt;/ul&gt; * * Reuses the logic behind the JOSM standard menu entry Tools-&amp;gt;Combine Ways. * If invoked from a script, this may trigger modal dialogs which are presented * to the user, in particular if the direction of the ways has to be reversed * because otherwise they could not be combined. * * @example * const cmd = require('josm/command') * const layers = require('josm/layer') * const ds = layers.activeLayer.data * const ways = [ds.way(1), ds.way(2), ds.way(3)] * cmd.combineWays(ways) * * @summary Combines the currently selected ways. * @static * @name combineSelectedWays * @function */ exports.combineSelectedWays = function () { const activeLayer = layers.activeLayer if (activeLayer == null) return const ways = activeLayer.data.selection.ways if (ways == null || ways.length &lt;= 1) return exports.combineWays(ways) } × Search results Close "},"josm_ds.js.html":{"id":"josm_ds.js.html","title":"Source: josm/ds.js","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/ds.js /** * Provides utitly methods for data sets * * @module josm/ds */ /* global Java */ /* global require */ const util = require('josm/util') const { NodeBuilder, WayBuilder, RelationBuilder } = require('josm/builder') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') const PrimitiveId = Java.type('org.openstreetmap.josm.data.osm.PrimitiveId') const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') const Collection = Java.type('java.util.Collection') const HashSet = Java.type('java.util.HashSet') const File = Java.type('java.io.File') const FileWriter = Java.type('java.io.FileWriter') const PrintWriter = Java.type('java.io.PrintWriter') const FileInputStream = Java.type('java.io.FileInputStream') const OsmImporter = Java.type('org.openstreetmap.josm.gui.io.importexport.OsmImporter') const OsmChangeImporter = Java.type('org.openstreetmap.josm.gui.io.importexport.OsmChangeImporter') const OsmReader = Java.type('org.openstreetmap.josm.io.OsmReader') const OsmChangeReader = Java.type('org.openstreetmap.josm.io.OsmChangeReader') const Utils = Java.type('org.openstreetmap.josm.tools.Utils') const GZIPInputStream = Java.type('java.util.zip.GZIPInputStream') const OsmWriterFactory = Java.type('org.openstreetmap.josm.io.OsmWriterFactory') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') const System = Java.type('java.lang.System') function log (msg) { System.out.println(msg) } function normalizeType (type) { if (util.isString(type)) { type = type.trim().toLowerCase() if ('node'.startsWith(type)) { return OsmPrimitiveType.NODE } else if ('way'.startsWith(type)) { return OsmPrimitiveType.WAY } else if ('relation'.startsWith(type)) { return OsmPrimitiveType.RELATION } else { util.assert(false, 'expected type as string, i.e. \"node\", \"way\", or \"relation\", got \"{0}\"', type) } } else if (type instanceof OsmPrimitiveType) { return type } else { util.assert(false, 'expected String or OsmPrimitiveType, got \"{0}\", type') } } function normalizeId (id) { if (util.isNumber(id)) { if (Number.isInteger(id)) { return id } else { util.assert(false, 'expected integer number, got \"{0}\"', id) } } else if (util.isString(id)) { util.println(`id before parseInt: ${id}`) id = parseInt(id.trim()) if (isNaN(id)) { util.assert(false, 'expected valid string encoding of id, got \"{0}\"', id) } } else { util.assert(false, 'expected number (an int value) or a string, got \"{0}\"', id) } } function buildId (id, type) { function buildId2 (id, type) { id = normalizeId(id) type = normalizeType(type) if (id === 0) { util.assert(false, 'expected id != 0, got 0') } return new SimplePrimitiveId(id, type) } function buildId1 (id) { util.assert(id instanceof PrimitiveId, 'expected PrimtiveId, got \"{0}\"', id) return id } util.assert(arguments.length &gt; 0, 'expected at least 1 argument, got 0') switch (arguments.length) { case 1: return buildId1(...arguments) case 2: return buildId2(...arguments) default: util.assert(false, 'expected 1 or 2 arguments, got {0}', arguments.length) } } function each (collection, delegate) { if (util.isArray(collection) || util.isArguments(collection)) { for (let i = 0; i &lt; collection.length; i++) { delegate(collection[i]) } } else if (collection instanceof Collection) { for (let it = collection.iterator(); it.hasNext();) { delegate(it.next()) } } else { util.assert(false, 'Expected list or collection, got {0}', collection) } } function collect (collection, predicate) { const ret = [] each(collection, (obj) =&gt; { if (predicate(obj)) ret.push(obj) }) return ret } function isCollection (collection) { return util.isArray(collection) || util.isArguments(collection) || collection instanceof Collection } function normalizeIds () { function walk (set, ids) { if (util.isNothing(ids)) return if (ids instanceof PrimitiveId) { set.add(ids) } else if (isCollection(ids)) { each(ids, (that) =&gt; walk(set, that)) } else { util.assert(false, 'PrimitiveId or collection required, got {0}', ids) } } const set = new HashSet() for (let i = 0; i &lt; arguments.length; i++) { walk(set, arguments[i]) } return set } /** * &lt;code&gt;DataSetUtil&lt;/code&gt; provides methods to build OSM primitive IDs and to * manipulate data in a {@class org.openstreetmap.josm.data.osm.DataSet}. * */ class DataSetUtil { /** * Creates an instane of &lt;code&gt;DataSetUtil&lt;/code&gt; for a given {@class org.openstreetmap.josm.data.osm.DataSet} * * @example * const { DataSetUtil, DataSet } = require('josm/ds') * const dsutil = new DataSetUtil(new DataSet()) * * @summary Build an utility object wrapping the dataset &lt;code&gt;ds&lt;/code&gt; * @param {org.openstreetmap.josm.data.osm.DataSet} [ds] the dataset. Creates a new dataset if missing */ constructor (ds) { ds = ds || new DataSet() this.ds = ds } /** * Replies an OSM object from the dataset, or undefined, if no such object * exists. * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;get(id, type)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Replies an object given by its unique numeric id and a type. * The type is either a string \"node\", \"way\", or \"relation\", or one of * the symbols * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, or * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;get(id)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Replies an object given an ID. &lt;code&gt;id&lt;/code&gt; is either an instance * of * {@class org.openstreetmap.josm.data.osm.PrimitiveId} or an object with * the properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, i.e. * &lt;code&gt;{id: 1234, type: \"node\"}&lt;/code&gt;.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { buildId , DataSetUtil, DataSet, OsmPrimitiveType} = require('josm/ds') * * const dsutil = new DataSetUtil(new DataSet()) * // get a node * const n1 = dsutil.get(1234, 'node') * * // get a way * const w1 = dsutil.get(3333, OsmPrimitiveType.WAY) * * // get a relation * const r1 = dsutil.get({id: 5423, type: \"relation\"}) * * // pass in a SimplePrimitiveId * const id = buildId(-5, OsmPrimitiveType.NODE) * const n2 = dsutil.get(id) * * // pass in a primitive to get it * const w2 = dsutil.wayBuilder().create(987) * const w3 = dsutil.get(w2) * * @param args see description */ get () { const id = buildId(...arguments) return this.ds.getPrimitiveById(id) } /** * Replies the node with id &lt;code&gt;id&lt;/code&gt;, or null. * * @example * const { DataSet, DataSetUtil } = require('josm/ds') * * const dsutil = new DataSetUtil(new DataSet()) * // get a node * const n = dsutil.node(1234) * * @param {number} id the unique numeric id. Must not be 0. * @returns {org.openstreetmap.josm.data.osm.Node} the node */ node (id) { util.assert(util.isSomething(id), 'expected defined id, got \"{0}\"', id) return this.get(id, 'node') } /** * Replies the way with id &lt;code&gt;id&lt;/code&gt;, or null * * @example * const { DataSet, DataSetUtil } = require('josm/ds') * * const dsutil = new DataSetUtil(new DataSet()) * // get a way * const w = dsutil.way(1234) * @param {number} id the unique numeric id. Must not be 0. * @returns {org.openstreetmap.josm.data.osm.Way} the way */ way (id) { util.assert(util.isSomething(id), 'expected defined id, got \"{0}\"', id) return this.get(id, 'way') } /** * Replies the relation with id &lt;code&gt;id&lt;/code&gt;. * * @example * const { DataSet, DataSetUtil } = require('josm/ds') * * const dsutil = new DataSetUtil(new DataSet()) * // get a relation * const r = dsutil.relation(1234) * * @param {number} id the unique numeric id. Must not be 0. * @returns {org.openstreetmap.josm.data.osm.Relation} the relation */ relation (id) { util.assert(util.isSomething(id), 'expected defined id, got \"{0}\"', id) return this.get(id, 'relation') } /** * Run a sequence of operations against the dataset in \"batch mode\". * * Listeners to data set events are only notified at the end of the batch. * * @example * const { DataSet, DataSetUtil } = require('josm/ds') * const dsutil = new DataSetUtil(new DataSet()) * // creates and adds two nodes and a way in batch operation * // to the dataset * dsutil.batch(() =&gt; { * const n1 = dsutil.nodeBuilder().create() * const n2 = dsutil.nodeBuilder().create() * dsutil.wayBuilder().withNodes(n1,n2).create() * }) * * @param {function} delegate the function implementing the batch process. * Ignored if null or undefined. */ batch (delegate) { if (!(util.isSomething(delegate))) { return } util.assert(util.isFunction(delegate), 'expected a function, got \"{0}\"', delegate) this.ds.beginUpdate() try { delegate() } finally { this.ds.endUpdate() } } /** * Removes objects from the dataset * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;remove(id, type)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Removes a single object given by its unique numeric ID (nid) and a * type. The type is either a string \"node\", \"way\", or \"relation\", or one * of the symbols * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, or * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;remove(id, id, ...)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Removes a collection of objects given by the ids. &lt;code&gt;id&lt;/code&gt; is * either an instance of * {@class org.openstreetmap.josm.data.osm.PrimitiveId} or an object with * the properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, i.e. * &lt;code&gt;{id: 1234, type: \"node\"}&lt;/code&gt;. * null and undefined are ignored.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;remove(array|collection)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Removes a collection of objects given by the an array or a * java.util.Collection of ids. * The collection elemeents are either instances of * {@class org.openstreetmap.josm.data.osm.PrimitiveId} or an object with * the properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, i.e. * &lt;code&gt;{id: 1234, type: \"node\"}&lt;/code&gt;. * null or undefined elements are ignored. * &lt;/dd&gt; * &lt;/dl&gt; * * @example * const { DataSet, DataSetUtil, OsmPrimitiveType, buildId} = require('josm/ds') * const HashSet = Java.type('java.util.HashSet') * const dsutil = new DataSetUtil(new DataSet()) * * // remove a node with a global id * dsutil.remove(1234, \"node\") * * // remove a node and a way * const id1 = buildId(1234, \"node\") * const id2 = buildId(3333, OsmPrimitiveType.WAY) * dsutil.remove(id1, id2) * * // remove a relation and a node * dsutil.remove({id: 1234, type: \"relation\"}, id1) * * // remove an array of nodes * dsutil.remove([id1,id2]) * * // remove a set of primitives * const ids = new HashSet() * ids.add(id1) * ids.add(id1) * dsutil.remove(ids) * * @param args see description */ remove () { // we have exactly two arguments, id and type. If we succeed // to convert them to a primitive id, then we are done if (arguments.length === 2) { let id try { id = buildId(normalizeId(arguments[0]), normalizeType(arguments[1])) } catch (e) { id = null } if (id) { this.ds.removePrimitive(id) return } } // we have a list of ids or collections of ids to remove. // First build a flat list of the ids, then remove them // in a batch operation from the dataset const ids = normalizeIds(...arguments) const ds = this.ds this.batch(() =&gt; { each(ids, (id) =&gt; { ds.removePrimitive(id) }) }) } /** * Replies a node builder to create {@class org.openstreetmap.josm.data.osm.Node}s in this dataset. * * @example * const { DataSet, DataSetUtil } = require('josm/ds') * const dsutil = new DataSetUtil(new DataSet()) * const n = dsutil.nodeBuilder * .withId(1234,4567) * .withTags({amenity: 'restaurant'}) * .create() * dsutil.has(n) * * @property {module:josm/builder~NodeBuilder} nodeBuilder * @readOnly */ get nodeBuilder () { return NodeBuilder.forDataSet(this.ds) } /** * Replies a way builder to create ways in this dataset. * * @example * const { DataSet, DataSetUtil } = require('josm/ds') * * const dsutil = new DataSetUtil(new DataSet()) * const nb = dsutil.nodeBuilder() * const w = dsutil.wayBuilder() * .withNodes(nb.create(), nb.create()) * .create(1234, {tags: {highway: \"residential\"}}) * dsutil.has(w) * * @property {module:josm/builder~WayBuilder} wayBuilder * @readOnly */ get wayBuilder () { return WayBuilder.forDataSet(this.ds) } /** * Replies a relation builder to create relations in this dataset. * * @example * const { DataSet, DataSetUtil } = require('josm/ds') * * const dsutil = new DataSetUtil(new DataSet()) * const r = dsutil.relationBuilder() * .withId(8765,1234) * .create({tags: {type: \"network\"}}) * ds.has(r) // --&gt; true * * @property {module:josm/builder~RelationBuilder} relationBuilder * @readOnly */ get relationBuilder () { return RelationBuilder.forDataSet(this.ds) } /** * Loads a dataset from a file. * &lt;p&gt; * Derives the format of the file from the file suffix, unless the named * option &lt;code&gt;options.format&lt;/code&gt; is set. * &lt;p&gt; * &lt;code&gt;options&lt;/code&gt; can contain the following named options: * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;format&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;one of the strings &lt;code&gt;osm&lt;/code&gt; (Open Street Map XML data), * &lt;code&gt;osc&lt;/code&gt; (Open Street Map change format), or * &lt;code&gt;osm.gz&lt;/code&gt; (Open Street Map XML data, * compressed with gzip). format is normalized by removing leading and * trailing whitespace and conversion to lower case.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { DataSetUtil } = require('josm/ds') * * // loads an OSM file * const dsutil1 = DataSetUtil.load('/path/to/my/file.osm') * * // loads an OSM file, expli * const dsutil2 = DataSetUtil.load( * '/path/to/my/file.any-suffix', { format 'osm' }) * * @param {string|java.io.File} source the data source * @param {object} [options] optional named parameters */ static load (source, options) { function normalizeFile (source) { if (source instanceof File) { return source } else if (util.isString(source)) { return new File(source) } else { util.assert(false, 'source: illegal value, expected string or File, got {0}', source) } } function normalizeFormat (source, options) { const FORMATS = { osm: true, osc: true, 'osm.gz': true } if (util.isSomething(options.format)) { // convert to string const format = util.trim(options.format + '').toLowerCase() if (FORMATS[format]) { return format } util.assert(false, `options.format: unknown format '${format}'`) } else { if (source.getPath().endsWith('.osm.gz')) { return 'osm.gz' } if (new OsmImporter().acceptFile(source)) { return 'osm' } if (new OsmChangeImporter().acceptFile(source)) { return 'osc' } util.assert(false, `Failed to derive format from file name. file is '${source}'`) } } util.assert(util.isSomething(source), 'source: must not be null or undefined') options = options || {} source = normalizeFile(source) const format = normalizeFormat(source, options) log(`format: ${format}`) let is try { switch (format) { // load an OSM file case 'osm': { is = new FileInputStream(source) const other = OsmReader.parseDataSet(is, null /* null progress monitor */) return new DataSetUtil(other) } // load an OSC file case 'osc': { is = new FileInputStream(source) const other = OsmChangeReader.parseDataSet(is, null /* null progress monitor */) return new DataSetUtil(other) } // load a compressed OSM file case 'osm.gz': { is = new GZIPInputStream(new FileInputStream(source)) const other = OsmReader.parseDataSet(is, null /* null progress monitor */) return new DataSetUtil(other) } default: util.assert(false, `unknown format '${format}'. Failed to load from ${source}`) } } finally { is &amp;&amp; Utils.close(is) } } /** * Saves the dataset to a file (in OSM XML format). * &lt;p&gt; * * &lt;code&gt;options&lt;/code&gt; can contain the following named options: * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;version&lt;/code&gt;: string&lt;/dt&gt; * &lt;dd&gt;the value of the attribute &lt;code&gt;version&lt;/code&gt; in the OSM file * header. Default: \"0.6\"&lt;/dd&gt; * * &lt;dt&gt;&lt;codeclass=\"signature\"&gt;changeset&lt;/code&gt;: Changeset&lt;/dt&gt; * &lt;dd&gt;the changeset whose id is included in the attribute * &lt;code&gt;changeset&lt;/code&gt; on every OSM object. If undefined, includes the * individual &lt;code&gt;changeset&lt;/code&gt; attribute of the OSM object. * Default: undefined&lt;/dd&gt; * &lt;dt&gt;&lt;codeclass=\"signature\"&gt;osmConform&lt;/code&gt;: bool&lt;/dt&gt; * &lt;dd&gt;if true, prevents modification attributes to be written * Default: true&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { DataSetUtil } = require('josm/ds') * * const dsutil = new DataSetUtil() * // create a node in the dataset * dsutil.nodeBuilder() * .withId(1, 1) * .withPosition({ lat: 1.0, lon: 1.0 }) * .create() * * // save the dataset * dsutil.save('/tmp/my-dataset.osm') * * @param {string|java.io.File} target the target file * @param {object} [options] optional named parameters * @instance */ save (target, options) { function normalizeTarget (target) { util.assert(util.isSomething(target), 'target: must not be null or undefined') if (util.isString(target)) { return new File(target) } else if (target instanceof File) { return target } else { util.assert(false, 'target: unexpected type of value, got {0}', target) } } function normalizeOptions (options) { options = options || {} util.assert( !util.isDef(options.version) || util.isString(options.version), 'options.version: expected a string, got {0}', options.version) options.version = options.version ? util.trim(options.version) : null /* default version */ /// true, if not explicity set to false options.osmConform = options.osmConform !== false const changeset = options.changeset util.assert( !util.isDef(changeset) || changeset instanceof Changeset, 'options.changeset: expected a changeset, got {0}', changeset) return options } target = normalizeTarget(target) options = normalizeOptions(options) let pw try { pw = new PrintWriter(new FileWriter(target)) const writer = OsmWriterFactory.createOsmWriter( pw, options.osmConform, options.version) if (options.changeset) { writer.setChangeset(options.changeset) } try { this.ds.getReadLock().lock() writer.header() writer.writeContent(this.ds) writer.footer() } finally { this.ds.getReadLock().unlock() } } finally { pw &amp;&amp; pw.close() } } /** * Queries the dataset * &lt;p&gt; * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;query(josmSearchExpression,?options)&lt;/code&gt; * &lt;/dt&gt; * &lt;dd&gt;Queries the dataset using the JOSM search expression * &lt;code&gt;josmSearchExpression&lt;/code&gt;. * &lt;code&gt;josmSearchExpression&lt;/code&gt; is a string as you would enter it in * the JOSM search dialog. &lt;code&gt;options&lt;/code&gt; is an (optional) object * with named parameters, see below.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;query(predicate,?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Queries the dataset using a javascript predicate function * &lt;code&gt;predicate&lt;/code&gt;. &lt;code&gt;predicate&lt;/code&gt; is a javascript * function which accepts a object as parameter and replies * true, when it matches for the object ans false otherwise. * &lt;code&gt;options&lt;/code&gt; is an (optional) object with named parameters, * see below.&lt;/dd&gt; * &lt;/dl&gt; * * The parameter &lt;code&gt;options&lt;/code&gt; consist of the following (optional) * named parameters: * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;allElements&lt;/code&gt; : boolean * (Deprecated parameter names: * &lt;code class=\"signature\"&gt;all&lt;/code&gt;)&lt;/dt&gt; * &lt;dd&gt;If true, searches &lt;em&gt;all&lt;/em&gt; objects in the dataset. If false, * ignores incomplete or deleted * objects. Default: false.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;caseSensitive&lt;/code&gt; : boolean&lt;/dt&gt; * &lt;dd&gt;&lt;strong&gt;Only applicable for searches with a JOSM search * expression&lt;/strong&gt;. If true, searches case sensitive. If false, * searches case insensitive. Default: false.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;regexSearch&lt;/code&gt; : boolean (Deprecated * parameter names: * &lt;code class=\"signature\"&gt;withRegexp&lt;/code&gt;, * &lt;code class=\"signature\"&gt;regexpSearch&lt;/code&gt;)&lt;/dt&gt; * &lt;dd&gt;&lt;strong&gt;Only applicable for searches with a JOSM search * expression&lt;/strong&gt;. If true, the search expression contains regular * expressions. If false, it includes only plain strings for searching. * Default: false.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;mapCSSSearch&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;&lt;strong&gt;Only applies for searches with a JOSM search * expression&lt;/strong&gt;. * Default: false.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const { DataSetUtil } = require('josm/ds') * const dsutil = new DataSetUtil() * // add or load primitives to query * // ... * * // query restaurants * const result1 = dsutil.query('amenity=restaurant') * * // query all nodes with a type query * const result2 = dsutil.query('type:node') * * // query using a custom predicate - all primitives * // with exactly two tags * const result3 = dsutil.query((primitive) =&gt; { * primitive.getKeys().size() ===2 * }) * * @param {string|function} expression the match expression * @param {object} [options] additional named parameters * @instance */ query (expression, options) { const SearchSetting = Java.type('org.openstreetmap.josm.data.osm.search.SearchSetting') const SearchCompiler = Java.type('org.openstreetmap.josm.data.osm.search.SearchCompiler') options = options || {} switch (arguments.length) { case 0: return [] case 1: case 2: if (util.isString(expression)) { const ss = new SearchSetting() ss.caseSensitive = Boolean(options.caseSensitive) ss.regexSearch = Boolean(options.regexSearch) || Boolean(options.regexpSearch) || Boolean(options.withRegexp) ss.allElements = Boolean(options.all) || Boolean(options.allElements) ss.mapCSSSearch = Boolean(options.mapCSSSearch) ss.text = expression const matcher = SearchCompiler.compile(ss) let predicate if (ss.allElements) { predicate = (matcher) =&gt; (obj) =&gt; { return matcher.match(obj) } } else { predicate = (matcher) =&gt; (obj) =&gt; { return obj.isUsable() &amp;&amp; matcher.match(obj) } } return collect(this.ds.allPrimitives(), predicate(matcher)) } else if (util.isFunction(expression)) { const all = Boolean(options.all) || Boolean(options.allElements) let predicate = expression if (!all) { predicate = (obj) =&gt; { return obj.isUsable() &amp;&amp; expression(obj) } } return collect(this.ds.allPrimitives(), predicate) } else { util.assert(false, 'expression: Unexpected type of argument, got {0}', arguments[0]) } break default: util.assert(false, 'Expected a predicate, got {0} arguments', arguments.length) } } } module.exports = { DataSetUtil: DataSetUtil, buildId: buildId, DataSet: DataSet, OsmPrimitiveType: OsmPrimitiveType } × Search results Close "},"josm_layers.js.html":{"id":"josm_layers.js.html","title":"Source: josm/layers.js","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/layers.js /** * Provides access to the JOSM layers. * * @module josm/layers */ /* global Java */ /* global require */ // -- imports const MainApplication = Java.type('org.openstreetmap.josm.gui.MainApplication') const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const Layer = Java.type('org.openstreetmap.josm.gui.layer.Layer') const util = require('josm/util') /** * Replies the number of currently open layers. * * @readOnly * @property {number} length the number of layers * @summary Replies the number of currently open layers. * @name length * @static */ Object.defineProperty(exports, 'length', { get: function () { return MainApplication.getLayerManager().getLayers().size() } }) /** * Set or get the active layer. * * &lt;dl&gt; * &lt;dt&gt;get&lt;/dt&gt; * &lt;dd&gt;Replies the active layer or undefined.&lt;/dd&gt; * * &lt;dt&gt;set&lt;/dt&gt; * &lt;dd&gt;Assign either an existing {@class org.openstreetmap.josm.layer.Layer}, * the name of a layer as string, or a layer index as number.&lt;/dd&gt; * &lt;/dl&gt; * * @property {org.openstreetmap.josm.layer.Layer} activeLayer the active layer * @name activeLayer * @summary Set or get the active layer. * @static */ Object.defineProperty(exports, 'activeLayer', { get: function () { return MainApplication.getLayerManager().getActiveLayer() }, set: function (value) { util.assert(util.isSomething(value), 'Value must not be null or undefined)') let layer = null if (value instanceof Layer) { layer = value } else if (util.isNumber(value) || util.isString(value)) { layer = exports.get(value) } else { util.assert(false, 'Unexpected type of value, got {0}', value) } util.assert(util.isSomething(layer), 'Layer \\'\\'{0}\\'\\' doesn\\'\\'t exist. It can\\'\\'t be set as active layer.', value) MainApplication.getLayerManager().setActiveLayer(layer) } }) function getLayerByName (key) { key = util.trim(key).toLowerCase() if (exports.length === 0) return undefined const layers = MainApplication.getLayerManager().getLayers() for (let it = layers.iterator(); it.hasNext();) { const l = it.next() if (l.getName().trim().toLowerCase() === key) return l } return undefined } function getLayerByIndex (idx) { if (idx &lt; 0 || idx &gt;= exports.length) return undefined const layers = MainApplication.getLayerManager().getLayers() return layers.get(idx) } /** * Replies one of the layers given a key. * * &lt;ul&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a number, replies the layer with index key, or * undefined, if no layer for this index exists.&lt;/li&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a string, replies the first layer whose name * is identical to key (case insensitive, without leading/trailing * whitespace), or undefined, if no layer with such a name exists.&lt;/li&gt; * &lt;/ul&gt; * * @example * const layers = require('josm/layers') * * // get the first layer * const layer1 = layers.get(0) * * // get the first layer with name \"data layer\" * const layer2 = layers.get('data layer') * * @param {number|string} key the key to retrieve the layer * @summary Replies one of the layers given a key. * @function * @returns {org.openstreetmap.josm.layer.Layer} * @name get * @static */ exports.get = function (key) { if (util.isNothing(key)) return undefined if (util.isString(key)) return getLayerByName(key) if (util.isNumber(key)) return getLayerByIndex(key) return undefined } /** * Checks whether &lt;code&gt;layer&lt;/code&gt; is a currently registered layer. * * @example * const layers = require('josm/layers') * * // is there a layer with name \"my layer\"? * let b = layers.has('my layer') * * // is there a layer at index position 2 * b = layers.has(2) * * // is there a specific layer? * let l = layers.get(0) * b = layers.has(l) * * @param {org.openstreetmap.josm.gui.layer.Layer|string|number} layer a layer, * a layer name, or a layer index * @returns {boolean }true, if the layer or at least one layer with the given name exists. * False, otherwise. * @summary Checks whether &lt;code&gt;layer&lt;/code&gt; is currently registered layer. * @function * @name has * @static */ exports.has = function (layer) { if (util.isNothing(layer)) return false const layerManager = MainApplication.getLayerManager() if (layer instanceof Layer) { return layerManager.getLayers().contains(layer) } else if (util.isString(layer)) { return util.isSomething(exports.get(layer)) } else if (util.isNumber(layer)) { return layer &gt;= 0 &amp;&amp; layer &lt; exports.length } else { return false } } /** * Adds a layer. * &lt;p&gt; * Either pass in a layer object or a data set. In the later case, an * {@class org.openstreetmap.josm.gui.layer.OsmDataLayer} is * automatically created. * * @example * const layers = require('josm/layers') * const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const dataLayer = new OsmDataLayer(new DataSet(), null, null); * // add a layer ... * layers.add(dataLayer) * * // or add a dataset, which will create a data layer * const ds = new DataSet() * layer.add(ds) * * @param {org.openstreetmap.josm.gui.layer.Layer * |org.openstreetmap.josm.data.osm.DataSet} obj a layer to add, * or a dataset. Ignored if null or undefined. * @summary Adds a layer. * @returns {org.openstreetmap.josm.gui.layer.Layer} the added layer * @name add * @function * @static */ exports.add = function (obj) { if (util.isNothing(obj)) return const layerManager = MainApplication.getLayerManager() if (obj instanceof Layer) { layerManager.addLayer(obj) } else if (obj instanceof DataSet) { layerManager.addLayer(new OsmDataLayer(obj, null, null)) } else { util.assert(false, 'Expected an instance of Layer or DataSet, got {0}', obj) } } function removeLayerByIndex (idx) { const layer = exports.get(idx) if (util.isNothing(layer)) return MainApplication.getLayerManager().removeLayer(layer) } function removeLayerByName (name) { const layer = exports.get(name) if (util.isNothing(layer)) return MainApplication.getLayerManager().removeLayer(layer) } /** * Removes a layer with the given key. * * &lt;ul&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Number&lt;/code&gt;, removes the layer with * the index key. If the index doesn't isn't a valid layer index, nothing * is removed.&lt;/li&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, removes the layer with * the name &lt;code&gt;key&lt;/code&gt;. Leading and trailing white space is removed, * matching is a case-insensitive sub-string match.&lt;/li&gt; * &lt;/ul&gt; * @example * const josm = require('josm') * * // remove the first layer * josm.layers.remove(0) * * // remove the first layer matching with the supplied name * josm.layers.remove('myLayerName') * * @param {number|string} key indicates the layer to remove * @summary Removes a layer. * @function * @name remove * @static */ exports.remove = function (key) { if (util.isNothing(key)) return if (util.isNumber(key)) { removeLayerByIndex(key) } else if (util.isString(key)) { removeLayerByName(key) } else { util.assert(false, 'Expected a number or a string, got {0}', key) } } /** * Creates and adds a new data layer. The new layer becomes the new edit * layer. * &lt;p&gt; * * &lt;string&gt;Signatures&lt;/string&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer()&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;create data layer with a new dataset and default name&lt;/dd&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer(ds)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;create data layer with dataset ds and default name&lt;/dd&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer(name)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;create data layer with a new dataset and name &lt;code&gt;name&lt;/code&gt;&lt;/dd&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer({name: ..., ds: ...})&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;create data layer with a new dataset and name &lt;code&gt;name&lt;/code&gt;&lt;/dd&gt; * &lt;/dl&gt; * @example * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * // creates a new data layer * const l1 = josm.layers.addDataLayer() * * // creates a new data layer with name 'test' * const l2 = josm.layers.addDataLayer('test') * * // creates a new data layer for the dataset ds * const ds = new DataSet() * const l3 = josm.layers.addDataLayer(ds) * * @returns {org.openstreetmap.josm.gui.layer.OsmDataLayer} the added layer * @summary Adds a data layer * @function * @name addDataLayer * @param {string | org.openstreetmap.josm.data.osm.DataSet | object } args see description * @static */ exports.addDataLayer = function () { let name, ds switch (arguments.length) { case 0: break case 1: if (util.isString(arguments[0])) { name = util.trim(arguments[0]) } else if (arguments[0] instanceof DataSet) { ds = arguments[0] } else if (typeof arguments[0] === 'object') { if (util.isString(arguments[0].name)) { name = util.trim(arguments[0].name) } if (arguments[0].ds instanceof DataSet) { ds = arguments[0].ds } } else { util.assert(false, 'unsupported type of argument, got {0}', arguments[0]) } break default: util.assert(false, 'Unsupported number of arguments, got {0}', arguments.length) } ds = ds || new DataSet() name = name || OsmDataLayer.createNewName() const layer = new OsmDataLayer(ds, name, null /* no file */) exports.add(layer) return layer } × Search results Close "},"josm_scriptingconsole.js.html":{"id":"josm_scriptingconsole.js.html","title":"Source: josm/scriptingconsole.js","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/scriptingconsole.js /** * Provides a set of functions to write to the built-in scripting * console. * * @module josm/scriptingconsole */ /* global Java */ /* global ScriptingConsole */ // -- imports const MessageFormat = Java.type('java.text.MessageFormat') function consoleWriter () { return ScriptingConsole.static.getInstance().getScriptLog().getLogWriter() } /** * Prints a string to the console * * @example * const console = require('josm/scriptingconsole') * console.print('Hello world!') * * // or use formatting * console.print('Hello world! My name is {0}', 'foo') * * @summary Prints a string to the console * @param {string} message the message * @param {...object} [values] optional values * @static * @name print * @function */ exports.print = function () { const args = Array.prototype.slice.call(arguments, 0) switch (args.length) { case 0: return case 1: consoleWriter().print(args[0] + '') return default: { args[0] = args[0] + '' // make sure first argument is a string const msg = MessageFormat.format(args[0], args.slice(1)) consoleWriter().print(msg) } } } /** * Prints a string to the console, including newline * * @example * const console = require('josm/scriptingconsole') * console.println('Hello world!') * * // or use formatting * console.println('Hello world! My name is {0}', 'foo'); * * @summary Prints a string to the console, including newline * @static * @name println * @function * @param {string} message the message * @param {...object} [values] optional values */ exports.println = function () { var args = Array.prototype.slice.call(arguments, 0) switch (args.length) { case 0: return case 1: consoleWriter().println(args[0] + '') return default: { args[0] = args[0] + '' // make sure first argument is a string const msg = MessageFormat.format(args[0], args.slice(1)) consoleWriter().println(msg) } } } /** * Clears the scripting console. * * @example * const console = require('josm/scriptingconsole') * console.clear() * * @summary Clears the scripting console. * @function * @name clear * @static */ exports.clear = function () { const action = ScriptingConsole.getInstance().getScriptLog().getClearAction() action.actionPerformed(null) } /** * Shows the scripting console * * @example * const console = require('josm/scriptingconsole') * console.show() * * @summary Shows the scripting console * @function * @name show * @static */ exports.show = function () { ScriptingConsole.showScriptingConsole() } /** * Hides the scripting console * * @example * var console = require('josm/scriptingconsole') * console.hide() * * @summary Hides the scripting console * @function * @name hide * @static */ exports.hide = function () { ScriptingConsole.hideScriptingConsole() } /** * Toggles the visibility of the scripting console * * @example * const console = require('josm/scriptingconsole') * console.toggle() * * @summary Toggles the visibility of the scripting console * @function * @name toggle * @static */ exports.toggle = function () { ScriptingConsole.toggleScriptingConsole() } × Search results Close "},"josm_ui_menu.js.html":{"id":"josm_ui_menu.js.html","title":"Source: josm/ui/menu.js","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/ui/menu.js /** * Provides a collection of namespaces, classes and functions to work with * JOSMs menu system. * * @module josm/ui/menu */ /* global Java */ // NOTE: // the class 'org.openstreetmap.josm.plugins.scripting.graalvm.JSAction' // is automatically bound to the scripting context. It can be loaded using // const JSAction = Java.type('org.openstreetmap.josm.plugins.scripting.graalvm.JSAction') // because of class loading issues. /* global JSAction */ const MainApplication = Java.type('org.openstreetmap.josm.gui.MainApplication') const util = require('josm/util') /** * Represents JOSMs global menu bar. * * @class * @name MenuBar */ exports.MenuBar = function () {} /** * Replies the number of menus in the JOSM menu bar. * * @example * // display the number of menus * josm.alert(josm.menu.length) * * @property {number} length the number of menues * @name length * @summary the number of menus in the JOSM menu bar * @memberof module:josm/ui/menu~MenuBar * @static */ Object.defineProperty(exports.MenuBar, 'length', { enumerable: true, get: function () { if (!MainApplication.getMenu()) return 0 return MainApplication.getMenu().getMenuCount() } }) /** * Replies a menu in the JOSM menu bar. * * &lt;code&gt;key&lt;/code&gt; is either a numberic index or one of the following * symbolic names as string: * &lt;ul&gt; * &lt;li&gt;&lt;code&gt;file&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;edit&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;view&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;tools&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;presets&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;imagery&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;window&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;help&lt;/code&gt;&lt;/li&gt; * &lt;/ul&gt; * * @example * // get the edit menu with a numeric index * const editmenu = josm.menu.get(1) * * // get the file menu with a symbolic name * const filemenu = josm.menu.get('file') * * @return {javax.swing.JMenu} the menu * @summary Replies a menu in the JOSM menu bar. * @param {number|string} key the key denoting the menu * @memberof module:josm/ui/menu~MenuBar * @name get * @function * @instance */ exports.MenuBar.get = function (key) { util.assert(util.isSomething(key), 'key: must not be null or undefined') const mainMenu = MainApplication.getMenu() if (util.isNumber(key)) { util.assert(key &gt;= 0 &amp;&amp; key &lt; exports.MenuBar.length, 'key: index out of range, got {0}', key) return mainMenu.getMenu(key) } else if (util.isString(key)) { key = util.trim(key).toLowerCase() switch (key) { case 'file': return mainMenu.fileMenu case 'edit': return mainMenu.editMenu case 'view': return mainMenu.viewMenu case 'tools': return mainMenu.toolsMenu case 'presets': return mainMenu.presetsMenu case 'imagery': return mainMenu.imageryMenu case 'window': return mainMenu.windowMenu case 'help': return mainMenu.helpMenu default: util.assert(false, 'Unsupported key to access a menu, got {0}', key) } } else { util.assert(false, 'Unexpected value, got {0}', key) } } /** * Replies an array with the symbolic menu names. * * @memberof module:josm/ui/menu~MenuBar * @name menuNames * @property {array} menuNames the names of the menues in the menu bar * @readOnly * @summary Replies an array with the symbolic menu names. * */ Object.defineProperty(exports.MenuBar, 'menuNames', { enumerable: true, get: function () { return ['file', 'edit', 'view', 'tools', 'presets', 'imagery', 'window', 'help'] } }) /** * JSAction is an action for which a menu item or a toolbar item can be * added to JOSMs menu or JOSMs toolbar respectively. * * This is just a shortcut for the Java class * {@class org.openstreetmap.josm.plugins.scripting.js.JSAction}. * * The constructor accepts an object with the following optional named * parameters. * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;name:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;The optional name of the action. Default: an auto generated named.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;tooltip:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;The optional tooltip of the action. Default: empty string.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;iconName:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;The optional name of an icon. Default: null.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;toolbarId:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;The optional name of the tooblar, this action is going to be added to * later. Note, that it isn't added automatically, when this action is * created. Default: null.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;onExecute:function&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;The (optional) function which is called when the action is executed. * Default: null.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;onInitEnabled:function&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;The (optional) function which is called when the &lt;em&gt;enabled&lt;/em&gt; * state of the function is evaluated the first time. Default: null.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;onUpdateEnabled:function&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;The (optional) function which is called when the &lt;em&gt;enabled&lt;/em&gt; * state of the function is reevaluated, in particular, when layer change * events or selection change events occur. Default: null.&lt;/dd&gt; * &lt;/dl&gt; * * @example * const JSAction = require(\"josm/ui/menu\").JSAction; * const action = new JSAction({ * name: \"My Action\", * tooltip: \"This is my action\", * onInitEnabled: function() { * this.enabled = false * } * }) * * action.onExecute = function() { * josm.alert(\"Action is executing ...\") * } * * @property {org.openstreetmap.josm.plugins.scripting.js.JSAction} JSAction * @static * @name JSAction * @memberof module:josm/ui/menu~MenuBar */ exports.JSAction = JSAction × Search results Close "},"josm_util.js.html":{"id":"josm_util.js.html","title":"Source: josm/util.js","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/util.js /** * Provides a set of static utility functions. * * @module josm/util */ /* global Java */ // -- imports const MessageFormat = Java.type('java.text.MessageFormat') /** global exports */ /** * Checks whether a value is null or undefined. * * @param {object} value the value to check * @return {boolean} false, if &lt;code&gt;value&lt;/code&gt; is null or undefined; true, otherwise * @summary Checks whether a value is null or undefined. * @function * @name isNothing */ exports.isNothing = function (value) { return value === null || value === undefined } /** * Checks whether a value is neither null nor undefined. * * @param {object} value the value to check * @return {boolean} false, if &lt;code&gt;value&lt;/code&gt; is null or undefined; true, otherwise * @summary Checks whether a value is neither null nor undefined. * @function * @name isSomething */ exports.isSomething = function (val) { return !exports.isNothing(val) } /** * Trims leading and trailing whitespace from &lt;code&gt;s&lt;/code&gt;. * &lt;p&gt; * * Replies s, if s is null or undefined. Any other value is converted to a * string, then leading and trailing white space is removed. * * @param {string} s the string to be trimmed * @return {string} * @summary Trims leading and trailing whitespace from &lt;code&gt;s&lt;/code&gt;. * @function * @name trim */ exports.trim = function (s) { if (exports.isNothing(s)) { return s } return (s + '').replace(/^\\s+/, '').replace(/\\s+$/, '') } /** * Assert a condition and throw an Error if the condition isn't met. * * &lt;p&gt;&lt;strong&gt;Usage:&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code&gt;assert()&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Does nothing&lt;/dd&gt; * * &lt;dt&gt;&lt;code&gt;assert(cond)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Checks the condition &lt;code&gt;cond&lt;/code&gt;. If it is false, throws an * Error.&lt;/dd&gt; * * &lt;dt&gt;&lt;code&gt;assert(cond, msg)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Checks the condition &lt;code&gt;cond&lt;/code&gt;. If it is false, throws an * Error, whose &lt;code&gt;description&lt;/code&gt; property * is set to &lt;code&gt;msg&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code&gt;assert(cond, msg, objs...)&lt;/code&gt;&lt;/dt&gt; * &lt;dd&gt;Checks the condition &lt;code&gt;cond&lt;/code&gt;. If it is false, throws an * Error, whose &lt;code&gt;description&lt;/code&gt; property * is set to the formatted message &lt;code&gt;msg&lt;/code&gt;. Internally uses * &lt;code&gt;java.text.MessageFormat&lt;/code&gt; to format the message.&lt;/dd&gt; * * &lt;/dl&gt; * * @example * const util = require(\"josm/util\") * // throws an Error * util.assert(false) * * // throws an Error e, with e.description == \"My message\" * util.assert(false, \"My message\") * * // throws an Error e, with e.description == \"My message: test\" * util.assert(false, \"My message: {0}\", \"test\") * * @summary Assert a condition and throw an Error if the condition isn't met. * @function * @name assert * @static * @param {boolean} condition * @param {string} [message] the message * @param {...object} [values] an optional list of values */ exports.assert = function () { let message, name switch (arguments.length) { case 0: return case 1: if (arguments[0]) return name = 'AssertionError' message = 'An assertion failed' break case 2: if (arguments[0]) return name = 'AssertionError' message = arguments[1] break default: { if (arguments[0]) return name = 'AssertionError' const args = Array.prototype.slice.call(arguments, 0) message = MessageFormat.format( args[1], args.slice(2) ) break } } const error = new Error(message) error.name = name throw error } /** * Asserts that &lt;code&gt;val&lt;/code&gt; is defined and non-null. * * @example * const util = require(\"josm/util\"); * util.assertSomething(null); // -&gt; throws an exception * util.assertSomething(void 0); // -&gt; throws an exception * * util.assertSomting(\"test\"); // -&gt; OK * util.assertSomething(5); // -&gt; OK * * @param {any} val the value to check * @param {string} [msg] message if the assertion fails * @param {...object} [values] additional values used in &lt;code&gt;msg&lt;/code&gt; * placeholders * @summary Asserts that &lt;code&gt;val&lt;/code&gt; is defined and non-null. * @function * @static * @name assertSomething */ exports.assertSomething = function (val) { let args if (arguments.length &lt;= 1) { args = [exports.isSomething(val), 'Expected a defined non-null value, got {0}', val] } else { args = [exports.isSomething(val)].concat( Array.prototype.slice.call(arguments, 1)) } exports.assert.apply(args) } /** * Asserts that &lt;code&gt;val&lt;/code&gt; is a number. * * @param {Anything} value the value to check * @param {String} [msg] message if the assertion fails * @param {...object} [values] values used in &lt;code&gt;msg&lt;/code&gt; placeholders * @summary Asserts that &lt;code&gt;val&lt;/code&gt; is a number. * @function * @name assertNumber * @static */ exports.assertNumber = function (val) { let args = [] if (arguments.length &lt;= 1) { args = [exports.isSomething(val), 'Expected a number, got {0}', val] } else { args = [exports.isSomething(val)] .concat(Array.prototype.slice.call(arguments, 1)) } exports.assert.apply(args) } /** * Returns true if &lt;code&gt;val&lt;/code&gt; is defined. * * @param {any} value the value to check * @summary Returns true if &lt;code&gt;val&lt;/code&gt; is defined. * @return {boolean} true if &lt;code&gt;val&lt;/code&gt; is defined * @function * @name isDef * @static */ exports.isDef = function (val) { return val !== undefined } /** * Returns true if &lt;code&gt;val&lt;/code&gt; is a number. * * @param {any} value the value to check * @summary Returns true if &lt;code&gt;val&lt;/code&gt; is a number. * @return {boolean} true if &lt;code&gt;val&lt;/code&gt; is a number * @function * @name isNumber * @static */ exports.isNumber = function (val) { return typeof val === 'number' } /** * Returns true if &lt;code&gt;val&lt;/code&gt; is a string. * * @param {any} value the value to check * @return {boolean} true, if val is a string or a String object * @summary Returns true if &lt;code&gt;val&lt;/code&gt; is a string. * @function * @name isString * @static */ exports.isString = function (val) { return exports.isDef(val) &amp;&amp; (typeof val === 'string' || val instanceof String) } /** * Replies true if &lt;code&gt;val&lt;/code&gt; is an array. * * @param {anything} value the value to check * @return {boolean} true, if val is an array * @summary Replies true if &lt;code&gt;val&lt;/code&gt; is an array. * @function * @name isArray * @static */ exports.isArray = function (val) { return Object.prototype.toString.call(val) === '[object Array]' } /** * Replies true if &lt;code&gt;val&lt;/code&gt; is a list of arguments. * * @param {anything} value the value to check * @return {boolean} true, if val is a list of arguments * @summary Replies true if &lt;code&gt;val&lt;/code&gt; is a list of arguments. * @function * @name isArguments * @static */ exports.isArguments = function (val) { return Object.prototype.toString.call(val) === '[object Arguments]' } /** * Replies the number of properties owned by &lt;code&gt;o&lt;/code&gt;. * * @example * const util = require(\"josm/util\") * let o = {p1: \"v1\", p2: \"v2\"} * let c = util.countProperties(o) // -&gt; 2 * * o = {} * c = util.countProperties(o) // -&gt; 0 * * o = undefined * c = util.countProperties(o) // -&gt; undefined * * @param {any} o the object * @summary Replies the number of properties owned by &lt;code&gt;o&lt;/code&gt;. * @return {number} the number of properties owned by &lt;code&gt;o&lt;/code&gt;. * @function * @name countProperties * @static */ exports.countProperties = function (o) { if (exports.isNothing(o)) return undefined if (!(typeof o === 'object')) return undefined let count = 0 for (const p in o) { if (exports.hasProp(o, p)) count++ } return count } /** * Replies true, if &lt;code&gt;o&lt;/code&gt; owns at least one property. * * @example * const util = require(\"josm/util\"); * let o = {p1: \"v1\", p2: \"v2\"}; * let c = util.hasProperties(o); // -&gt; true * * o = {}; * c = util.hasProperties(o); // -&gt; false * * o = undefined; * c = util.hasProperties(o); // -&gt; false * * @param {any} o the object * @summary Replies true, if &lt;code&gt;o&lt;/code&gt; owns at least one property. * @return {boolean} true, if &lt;code&gt;o&lt;/code&gt; owns at least one property. * @function * @name hasProperties * @static */ exports.hasProperties = function (o) { const count = exports.countProperties(o) if (count === undefined) return false return count &gt; 0 } /** * Replies true, if f is a function. * * @param {any} f the object * @summary Replies true, if f is a function. * @return {boolean} true, if f is a function. * @function * @name isFunction * @static */ exports.isFunction = function (f) { return typeof f === 'function' } /** * Mixes the properties of a list of objects into one object. * * @return a new object which includes the combined properties of the * argument objects * @return {object} * @summary Mixes the properties of a list of objects into one object. * @function * @name mix * @static */ exports.mix = function () { const mixin = {} function copyProperties (other) { for (const p in other) { if (!exports.hasProp(other, p)) continue mixin[p] = other[p] } } for (let i = 0; i &lt; arguments.length; i++) { const template = arguments[i] if (exports.isNothing(template)) continue if (!(typeof template === 'object')) continue copyProperties(template) } return mixin } /** * Prints a message to stdout (including newline). * &lt;p&gt; * * Supports the same string templates as {@class java.text.MessageFormat}. * * @example * var myname = \"...\"; * util.println(\"Hello world! My name is {0}\", myname); * // escape meta characters like {, } or ' with a leading apostrophe * util.println(\" a pair of curly braces '{'}\"); * * @summary Prints a message to stdout (including newline). * @param {string} message * @param {...object} [args] * @function * @name println * @static */ exports.println = function () { const args = Array.prototype.slice.call(arguments, 0) if (args.length === 0) return '' args[0] = args[0] + '' // make sure first argument is a string const System = Java.type('java.lang.System') System.out.println(MessageFormat.format(args[0], args.slice(1))) } /** * Prints a message to stdout (without newline). * &lt;p&gt; * Supports the same string templates as {@class java.text.MessageFormat} * * @example * * const myname = \"...\" * util.print(\"Hello world! My name is {0}\", myname) * // escape meta characters like {, } or ' with a leading apostrophe * util.print(\" a pair of curly braces '{'}\") * * @summary Prints a message to stdout (without newline). * @param {string} message * @param {...object} [args] * @function * @name print * @static */ exports.print = function () { const args = Array.prototype.slice.call(arguments, 0) if (args.length === 0) return '' args[0] = args[0] + '' // make sure first argument is a string const System = Java.type('java.lang.System') System.out.print(MessageFormat.format(args[0], args.slice(1))) } /** * Checks whether two java objects are either both null or equal by calling * o1.equals(o2). * * @param {object} o1 a java object or null * @param {object} o2 a java object or null * @summary Are two java objects equal. * @return {boolean} * @function * @name javaEquals * @static */ exports.javaEquals = function (o1, o2) { exports.assert(typeof o1 === 'object' &amp;&amp; typeof o1.equals === 'function') exports.assert(typeof o2 === 'object' &amp;&amp; typeof o2.equals === 'function') if (o1 === null &amp;&amp; o2 === null) return true if (o1 === null &amp;&amp; o2 !== null) return false return o1.equals(o2) } /** * Iterates over the elements in &lt;code&gt;collection&lt;/code&gt; and invokes * &lt;code&gt;delegate()&lt;/code&gt; on each element. * * @param {array|arguments|java.util.Collection} collection the collection of * elements * @param {function} delegate the function to call on each elemennt * @summary Iteraties over the elements of a collection * @function * @name each * @static */ exports.each = function (collection, delegate) { const Collection = Java.type('java.util.Collection') if (exports.isNothing(collection) || exports.isNothing(delegate)) return if (exports.isArray(collection) || exports.isArguments(collection)) { const len = collection.length for (let i = 0; i &lt; len; i++) delegate(collection[i]) } else if (collection instanceof Collection) { for (let it = collection.iterator(); it.hasNext();) delegate(it.next()) } else { exports.assert(false, 'collection: unexpected type of value, got {0}\"', collection) } } /** * Replies true, if a value is an array, an arguments list or a Java * collection. * * @param {object} value the value to check * @summary Is a value a collection? * @return {boolean} true, if &lt;code&gt;value&lt;/code&gt; is a collection * @function * @name isCollection * @static */ exports.isCollection = function (value) { const Collection = Java.type('java.util.Collection') return exports.isArray(value) || exports.isArguments(value) || value instanceof Collection } exports.hasProp = function (o, name) { return Object.prototype.hasOwnProperty.call(o, name) } × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Modules Classes Api Collection of static methods to download objects from and upload objects to the OSM server ApiConfig ApiConfig provides methods and properties for configuring API parameters ChangesetApi Provides methods to open, close, get, and update changesets on the OSM API server NodeBuilder NodeBuilder helps to create OSM nodes RelationBuilder Helps to create Relations WayBuilder Helps to create OSM Ways ChangeCommand A command to change a collection of objects in a data layer. CommandHistory Accessor to the global command history DeleteCommand A command to delete a collection of objects in a data layer. AddCommand A command to add a collection of objects to a data layer DataSetUtil Build an utility object wrapping the dataset ds MenuBar NodeBuilder × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Classes Classes Api Collection of static methods to download objects from and upload objects to the OSM server ApiConfig ApiConfig provides methods and properties for configuring API parameters ChangesetApi Provides methods to open, close, get, and update changesets on the OSM API server NodeBuilder NodeBuilder helps to create OSM nodes RelationBuilder Helps to create Relations WayBuilder Helps to create OSM Ways ChangeCommand A command to change a collection of objects in a data layer. CommandHistory Accessor to the global command history DeleteCommand A command to delete a collection of objects in a data layer. AddCommand A command to add a collection of objects to a data layer DataSetUtil Build an utility object wrapping the dataset ds MenuBar NodeBuilder × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder × Search results Close "},"module-clipboard.html":{"id":"module-clipboard.html","title":"Module: clipboard","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: clipboard Provides access to the system clipboard Source: clipboard.js, line 1 Members &lt;static&gt; text Set or get the clipboard content as text Set or get the clipboard content as text get Replies the clipboard content as text or undefined, if no clipboard content is available or if it can't be converted to a string. set Sets the clipboard content Properties: Name Type Description text string clipboard content as text Source: clipboard.js, line 9 Example const clipboard = require('clipboard') // set the clipboard content clipboard.text = 'Hello World!' × Search results Close "},"module-josm.html":{"id":"module-josm.html","title":"Module: josm","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm This module is auto-loaded by the scripting plugin. It provides the implementation of the global josm object. Source: josm.js, line 1 Members &lt;static, readonly&gt; commands the global command history Replies the global command history. Use this object to undo/redo commands, or to clear the command history. Properties: Name Type Description commands module:josm/command.CommandHistory Source: josm.js, line 213 Example // undoes the last command josm.commands.undo() // redoes two commands josm.commands.redo(2) &lt;static, readonly&gt; layers accessor for JOSM layers Replies the layers object. Properties: Name Type Description layers module:josm/layers the layers object Source: josm.js, line 40 Example josm.alert('num layers: ' + josm.layers.length) // name of first layer josm.alert('num layers: ' + josm.layers.get(0).name) &lt;static, readonly&gt; menu Replies an accessor for JOSMs menu bar. Replies an accessor for JOSMs menu bar. Use this object to inspect or modify the menu bar, i.e. to add additional menu items. Properties: Name Type Description menu module:josm/ui/menu~MenuBar accessor for JOSMs menu bar Source: josm.js, line 239 &lt;static, readonly&gt; version JOSM version string Replies the current JOSM version string. Properties: Name Type Description version string the JOSM version Source: josm.js, line 21 Example josm.alert(josm.version); Methods &lt;static&gt; alert(message) display a message Displays an alert window with a message Signatures alert(message) Displays an information message with an OK button. alert(message, ?options) Displays a message. The look and feel of the alert window depends on the options. The following options are supported: title:string (optional) the window title. A string is expected. Empty string if missing. messageType (optional) the message type. Use one of the following values: JOptionPane.INFORMATION_MESSAGE, \"info\",\"information\" JOptionPane.ERROR_MESSAGE, \"error\" JOptionPane.WARNING_MESSAGE, \"warning\", \"warn\" JOptionPane.QUESTION_MESSAGE, \"question\" JOptionPane.PLAIN_MESSAGE, \"plain\" Default value is JOptionPane.INFORMATION_MESSAGE. String values are not case sensitive and leading and trailing white space is removed. Parameters: Name Type Description message string the message Source: josm.js, line 116 Example // display an information alert josm.alert('Hello World!') // display an error alert josm.alert('Got an error', { title: 'Error Alert', messageType: 'error' }) &lt;static&gt; open(files) Opens one or more files in JOSM Opens one or more files in JOSM. Accepts a variable number of files. Each argument is either a string (a file name) or a File. Creates and opens layers in JOSM, depending on the kind of file opened: creates a data layer for data files creates a gpx layer for gpx files creates an image layer for a directory with images etc. * @example // open a data file in a new data layer josm.open('/my/data/file.osm') Parameters: Name Type Argument Description files java.io.File | string &lt;repeatable&gt; files to open Source: josm.js, line 192 × Search results Close "},"module-josm_api.html":{"id":"module-josm_api.html","title":"Module: josm/api","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/api This module provides functions to retrieve data from and upload data to an OSM server. Source: josm/api.js, line 1 Classes Api Collection of static methods to download objects from and upload objects to the OSM server ApiConfig ApiConfig provides methods and properties for configuring API parameters ChangesetApi Provides methods to open, close, get, and update changesets on the OSM API server Methods &lt;static&gt; buildBounds(obj) Creates a {@ org.openstreetmap.josm.data.Bounds} instance from a javascript object. Parameters: Name Type Description obj object a javascript object Source: josm/api.js, line 61 Returns: the bounds Type org.openstreetmap.josm.data.Bounds Example let { buildBounds } = require('josm/api') const bounds1 = buildBounds({minlat: 46.9479186, minlon: 7.4619484, maxlat: 46.9497642, maxlon: 7.4660683}) const bounds2 = buildBounds({ min: {lat: 46.9479186, lon: 7.4619484}, max: {lat: 46.9497642, lon: 7.4660683} }) &lt;static&gt; buildLatLon(obj) Create a LatLon from a javascript object. Creates a LatLon from a javascript object. Parameters: Name Type Description obj object a javascript object with two number properties lat: and lon: Source: josm/api.js, line 27 Returns: Type org.openstreetmap.josm.data.coor.LatLon Example const { buildLatLon } = require('josm/api') const pos = buildLatLon({lat: 1, lon: 2}); × Search results Close "},"module-josm_api-Api.html":{"id":"module-josm_api-Api.html","title":"Class: Api","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: Api josm/api~ Api new Api() Collection of static methods to download objects from and upload objects to the OSM server Collection of static methods to download objects from and upload objects to the OSM server. Note: this class doesn't provide a constructor. Methods and properties are 'static'. Source: josm/api.js, line 394 Example // load the api const { Api } = require('josm/api') // download node 12345 const ds = Api.downloadObject(12345, 'node') Methods &lt;static&gt; downloadArea(bounds) Downloads the objects within a bounding box Downloads the objects within a bounding box. Parameters: Name Type Description bounds org.openstreetmap.josm.data.Bounds | object the bounding box Source: josm/api.js, line 802 Returns: the downloaded primitives Type org.openstreetmap.josm.data.osm.DataSet Example const { Api } = require('josm/api') const ds1 = Api.downloadArea(new Bounds( new LatLon(46.9479186,7.4619484), // min new LatLon(46.9497642, 7.4660683) // max )) const ds2 = Api.downloadArea({ min: {lat: 46.9479186, lon: 7.4619484}, max: {lat: 46.9497642, lon: 7.4660683} }) &lt;static&gt; downloadObjects(args) Downloads an object from the server. Downloads an object from the server. There are multiple options to specify what object to download. In addition, the function accepts a set of optional named parameters as last argument. downloadObject(id, type, ?options) id is the global numeric id. type is either one of the strings 'node', 'way', or 'relation', or one of the enumeration OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION downloadObject(id, ?options) id is a PrimitiveId or an object with the (mandatory) properties id and type, i.e. an object {id: ..., type: ...}. id is again a number, type is again either one of the strings 'node', 'way', or 'relation', or one of the enumeration OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. In both cases, ?options is an (optional) object with the following two (optional) properties: full: boolean If true, the object and its immediate children are downloaded, i.e. the nodes of a way and the relation members of a relation. Default if missing is false. version: number If present, the specified version of the object is downloaded. If missing, the current version is downloaded. If present, the option full is ignored. Parameters: Name Type Description args see description and examples Source: josm/api.js, line 539 Returns: the downloaded primitives Type org.openstreetmap.josm.data.osm.DataSet Example const { Api } = require('josm/api') const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') // download the node with id 12345 const ds1 = Api.downloadObject(12345, 'node') // download the node with id 12345 const ds2 = Api.downloadObject({id: 12345, type: 'node'}) // download the full relation (including its members) with id 12345 const id = new SimplePrimitiveId(12345, OsmPrimitiveType.RELATION) const ds3 = Api.downloadObject(id, {full: true}) // download version 5 of the full way 12345 (including its nodes) const ds4 = Api.downloadObject(12345, OsmPrimitiveType.WAY, {version: 5}) &lt;static&gt; downloadReferrer(args) Downloads the objects referring to another object from the server. Downloads the objects referring to another object from the server. Downloads primitives from the OSM server which refer to a specific primitive. Given a node, the referring ways and relations are downloaded. Given a way or a relation, only referring relations are downloaded. The default behaviour is to reply proxy objects only. If you set the option {full: true}, every referring object is downloaded in full. There are multiple options to specify what referrers to download. In addition, the function accepts a set of optional named parameters as last argument. downloadReferrer(id, type, ?options) id is the global numeric id. type is either one of the strings 'node', 'way', or 'relation', or one of the enumeration OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. downloadReferrer(id, ?options) id is a PrimitiveId or an object with the (mandatory) properties id and type, i.e. an object {id: ..., type: ...}. id is again a number, type is again either one of the strings 'node', 'way', or 'relation', or one of the enumeration OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. In both cases, ?options is an (optional) object with the following (optional) property: full:boolean If true, the the full objects are retrieved using multi-gets. If missing or false, only proxy objects are downloaded. Default: false Parameters: Name Type Description args see description and examples Source: josm/api.js, line 699 Returns: the downloaded primitives Type org.openstreetmap.josm.data.osm.DataSet Example const { Api } = require('josm/api') const { NodeBuilder } = require('josm/builder') const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') // download the objects referring to the node with id 12345 const ds1 = Api.downloadReferrer(12345, 'node') // download the objects referring to the node with id 12345 const ds2 = Api.downloadReferrer({id: 12345, type: 'node'}) // download the relations referring to the relation with id 12345. // Referring relations are downloaded in full. const id = new SimplePrimitiveId(12345, OsmPrimitiveType.RELATION) const ds3 = Api.downloadReferrer(id, { full: true }) // create the global node 12345 ... const node = NodeBuilder.create(12345) // ... and downloads its referrers in full const ds = Api.downloadReferrer(node, { full: true }) &lt;static&gt; upload(data, comment [, options]) Uploads objects Uploads objects to the server. You can submit data either as DataSet, APIDataSet, javascript array of OsmPrimitives or a Collection of OsmPrimitives. This method supports the same upload strategy as the JOSM upload dialog. Supply the named parameter {strategy: ...} to choose the strategy. Be careful when uploading data to the OSM server! Do not upload copyright protected or test data. The method takes care to update the primitives in the uploaded data when the upload succeeds. For instance, uploaded new primitives become global objects and get assigned their new id and version, successfully deleted objects become invisible, etc. Even if the entire upload of a dataset fails, a subset therefore may have been uploaded successfully. In order to keep track, which pritives have been uploaded successfully in case of an error, the method replies a collection of the successfully uploaded objects. Named options strategy: string| UploadStrategy Indicates how the data is uploaded. Either one of the strings individualobjects chunked singlerequest or one of the enumeration values in UploadStrategy. Default falue: UploadStrategy.DEFAULT_UPLOAD_STRATEGY changeset: number|Changeset The changeset to which the data is uploaded. Either a number (the changeset id) or a Changeset instance. Default: creates a new changeset. chunkSize: number The size of an upload chunk, if the data is uploaded with the upload strategy UploadStrategy.CHUNKED_DATASET_STRATEGY. closeChangeset: boolean If true, closes the changeset after the upload. Default: true Parameters: Name Type Argument Description data org.openstreetmap.josm.data.osm.DataSet | org.openstreetmap.josm.data.APIDataSet | array | java.util.Collection the data to upload comment string the upload comment options object &lt;optional&gt; various options (see above) Source: josm/api.js, line 849 Returns: Type java.util.Collection Example const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const { WayBuilder } = require('josm/builder') const { Api }= require('josm/api') const ds = new DataSet() WayBuilder .forDataSet(ds) .withNodes( ds.nodeBuilder.withTags({name: 'node1'}).create(), ds.nodeBuilder.withTags({name: 'node2'}.create() ) .withTags({name: 'way1'}) .create() // uploads the data in a new changeset in one chunk const processed = Api.upload(ds, 'just testing') × Search results Close "},"module-josm_api-ApiConfig.html":{"id":"module-josm_api-ApiConfig.html","title":"Class: ApiConfig","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: ApiConfig josm/api~ ApiConfig new ApiConfig() ApiConfig provides methods and properties for configuring API parameters ApiConfig provides methods and properties for configuring API parameters. Source: josm/api.js, line 1031 Members &lt;static&gt; authMethod :string Get or set the authentication method. Get or set the authentication method. JOSM uses two authentication methods: basic Basic authentication with a username and a password oauth Authentication with the OAuth protocol. Type: string Properties: Name Type Description authMethod string the authentication method Source: josm/api.js, line 1134 Example const { ApiConfig } = require('josm/api') ApiConfig.authMethod // -&gt; the current authentication method // set OAuth as authentication method ApiConfig.authMethod = 'oauth' &lt;static, readonly&gt; defaultServerUrl Get the default server URL Get the default server URL. Properties: Name Type Description defaultServerUrl string the default server URL Source: josm/api.js, line 1104 Example const { ApiConfig } = require('josm/api') ApiConfig.defaultServerUrl // -&gt; the default server url &lt;static&gt; serverUrl Get or set the API server URL. Get or set the API server URL. get Replies the currently configured server URL or undefinend, if no server URL is configured. set Sets the current server URL. If null or undefined, removes the current configuration. Accepts either a string or a URL. Only accepts http or https URLs. Properties: Name Type Description serverUrl string Source: josm/api.js, line 1043 Example const { ApiConfig } = require('josm/api') ApiConfig.serverUrl // -&gt; the current server url // set a new API url ApiConfig.serverUrl = 'http://api06.dev.openstreetmap.org' Methods &lt;static&gt; getCredentials(authMethod, options) Gets the credentials. Gets the credentials, i.e. username and password for the basic authentication method. Named options host:string The host name of the API server for which credentials are retrieved. If missing, the host name of the currently configured OSM API server is used. Parameters: Name Type Description authMethod string the authentication method. Either basic or oauth options object (optional) additional options (see above) Source: josm/api.js, line 1176 Returns: the credentials Type object Example const { ApiConfig } = require('josm/api') // get username/password for the current OSM API server const credentials = ApiConfig.getCredentials('basic') &lt;static&gt; setCredentials(authMethod, credentials, options) Set the credentials. Set the credentials, i.e. username and password for the basic authentication method. Basic authentication credentials are either an instance of java.net.PasswordAuthentication or an object {user: string, password: string}. OAuth authentication credentials are either an instance of OAuthToken or an object {key: string, secret: string}. Named options host:string The host name of the API server for which credentials are set. If missing, the host name of the currently configured OSM API server is used. Parameters: Name Type Description authMethod string the authentication method. Either 'basic' or 'oauth'. credentials object | org.openstreetmap.josm.data.oauth.OAuthToken | java.net.PasswordAuthentication the credentials. options object (optional) additional options (see above) Source: josm/api.js, line 1278 Returns: the credentials Type object Example const { ApiConfig } = require('josm/api') // set the credentials ApiConfig.setCredentials('basic', { user:'test', password:'apassword' }) × Search results Close "},"module-josm_api-ChangesetApi.html":{"id":"module-josm_api-ChangesetApi.html","title":"Class: ChangesetApi","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: ChangesetApi josm/api~ ChangesetApi new ChangesetApi() Provides methods to open, close, get, and update changesets on the OSM API server Provides methods to open, close, get, update, etc. changesets on the OSM API server. Note: this class doesn't provide a constructor. Methods and properties are static. Source: josm/api.js, line 123 Example // load the changeset api const { ChangesetApi } = require('josm/api') // create a new changeset on the server const cs = ChangesetApi.open() Methods &lt;static&gt; close(changeset) Closes a changeset Closes a changeset close(id) closes the changeset with the given id close(aChangeset) Xloses the changeset given by aChangeset Parameters: Name Type Description changeset number | org.openstreetmap.josm.data.osm.Changeset the changeset to close Source: josm/api.js, line 214 Returns: the changeset Type org.openstreetmap.josm.data.osm.Changeset Example const { ChangesetApi } = require('josm/api') const util = require('josm/util') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // closs the changeset 12345 ChangesetApi.close(12345) // open a new changeset with the tags given by the supplied changeset const cs2 = new Changeset(12345) cs2 = ChangesetApi.close(cs2) util.assert(cs2.closed) // the changeset is now closed &lt;static&gt; get(changeset, changeset) Get a changeset from the server Get a changeset from the server get(id) gets the changeset for the id. id must be a number &gt; 0. Parameters: Name Type Description changeset number | org.openstreetmap.josm.data.osm.Changeset the changeset to close changeset number | org.openstreetmap.josm.data.osm.Changeset Source: josm/api.js, line 329 Returns: the changeset Type org.openstreetmap.josm.data.osm.Changeset Example const { ChangesetApi } = require('josm/api') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // get the changeset with id 12345 const cs1 = ChangesetApi.get(12345) // get the changeset with id 12345 const cs2 = new Changeset(12345) cs2 = ChangesetApi.get(cs2) &lt;static&gt; open( [changeset]) Creates and opens a changeset Creates and opens a changeset open() - open a new changeset with no tags open(aChangeset) - open a new changeset with the tags from aChangeset open(anObject) - open a new changeset with the tags given by the properties of anObject Parameters: Name Type Argument Description changeset org.openstreetmap.josm.data.osm.Changeset | object &lt;optional&gt; the changeset to open Source: josm/api.js, line 143 Returns: the changeset Type org.openstreetmap.josm.data.osm.Changeset Example const { ChangesetApi } = require('josm/api') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // open a new changeset with no tags const cs1 = ChangesetApi.open() // open a new changeset with the tags given by the supplied changeset const cs2 = new Changeset() cs2.put('comment', 'a test comment') cs2 = ChangesetApi.open(cs2) // open a new changeset with the tags given by the object var cs3 = ChangesetApi.open({comment: 'a test comment'}) &lt;static&gt; update(changeset) Updates a changeset Updates a changeset update(aChangeset) Updates the changeset aChangeset Parameters: Name Type Description changeset org.openstreetmap.josm.data.osm.Changeset the changeset to update Source: josm/api.js, line 277 Returns: the changeset Type org.openstreetmap.josm.data.osm.Changeset Example const { ChangesetApi } = require('josm/api') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // update the comment of a changeset const cs2 = new Changeset(12345) cs2.put('comment', 'an updated comment') cs2 = ChangesetApi.update(cs2) × Search results Close "},"module-josm_builder.html":{"id":"module-josm_builder.html","title":"Module: josm/builder","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/builder Collection of builders for creating OSM nodes, ways and relations. Source: josm/builder.js, line 1 Classes NodeBuilder NodeBuilder helps to create OSM nodes RelationBuilder Helps to create Relations WayBuilder Helps to create OSM Ways × Search results Close "},"module-josm_builder-NodeBuilder.html":{"id":"module-josm_builder-NodeBuilder.html","title":"Class: NodeBuilder","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: NodeBuilder josm/builder~ NodeBuilder new NodeBuilder( [ds]) NodeBuilder helps to create OSM nodes NodeBuilder helps to create OSM nodes. Methods of NodeBuilder can be used in a static and in an instance context. It isn't necessary to create an instance of NodeBuilder, unless it is configured with a DataSet, to which created nodes are added. Parameters: Name Type Argument Description ds org.openstreetmap.josm.data.osm.DataSet &lt;optional&gt; the dataset which created objects are added to Source: josm/builder.js, line 176 Example const NodeBuilder = require('josm/builder').NodeBuilder const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() // create a node builder without and underlying dataset ... let nbuilder = new NodeBuilder() // ... with an underlying dataset .... nbuilder = new NodeBuilder(ds) // ... or using this factory method nbuilder = NodeBuilder.forDataSet(ds) // create a new local node at position (0,0) without tags const n1 = nbuilder.create() // create a new global node at a specific position with tags const n2 = nbuilder.withPosition(1,1).withTags({name: 'test'}).create(123456) // create a new proxy for a global node // (an 'incomplete' node in JOSM terminology) const n3 = nbuilder.createProxy(123456) Methods &lt;static&gt; forDataSet(ds) Creates a new NodeBuilder for a specific DataSet. Creates or configures a NodeBuilder which will add created nodes to the dataset ds. Parameters: Name Type Description ds org.openstreetmap.josm.data.osm.DataSet the dataset which created objects are added to Source: josm/builder.js, line 255 Returns: the node builder Type module:josm/builder.NodeBuilder Example const builder = require('josm/builder') // create a new node builder building to a data set const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() // ... using a static method ... const nb1 = builder.NodeBuilder.forDataSet(ds) // ... or the instance method let nb2 = new builder.NodeBuilder() nb = nb.forDataSet(ds) create( [id] [, options]) Creates a new Node Creates a new Node. Can be used in an instance or in a static context. Optional named arguments in the parameter options version - the version of a global node (number &gt; 0) lat - a valide latitude (number in the range [-90,90]) lon - a valide longitude (number in the range [-180,180]) pos - either an array [lat,lon], an object {lat: ..., lon: ...}, or an instance of LatLon tags - an object with tags. Null values and undefined values are ignored. Any other value is converted to a string. Leading and trailing white space in keys is removed. Parameters: Name Type Argument Description id number &lt;optional&gt; a global node id. If missing and not set before using withId(..), creates a new local id. options object &lt;optional&gt; additional options for creating the node Source: josm/builder.js, line 277 Returns: the created node Type org.openstreetmap.josm.data.osm.Node Example const nb = require('josm/builder').NodeBuilder // create a new local node at position [0,0] const n1 = nb.create() // create a new global node at position [0,0] const n2 = nb.create(12345) // create a new global way with version 3 at a specific position // and with some tags const n3 = nb.create(12345, { version: 3, lat: 23.45, lon: 87.23, tags: {amenity: 'restaurant'} }) createProxy(id) Creates a new proxy Node Creates a new proxy Node. A proxy node is a node, for which we only know its global id. In order to know more details (position, tags, etc.), we would have to download it from the OSM server. The method can be used in a static and in an instance context. Parameters: Name Type Description id number the node id (not null, number &gt; 0 expected) Source: josm/builder.js, line 397 Returns: the new proxy node Type org.openstreetmap.josm.data.osm.Node Example const nbuilder = require('josm/builder').NodeBuilder // a new proxy node for the global node with id 12345 cons n1 = nbuilder.createProxy(12345) withId(id, version) Declares the node id and version. Declares the global node id and the global node version. The method can be used in a static and in an instance context. Parameters: Name Type Description id number (mandatory) the global node id. A number &gt; 0. version number (optional) the global node version. If present, a number &gt; 0. If missing, the version 1 is assumed. Source: josm/builder.js, line 508 Returns: the node builder (for method chaining) Type module:josm/builder~NodeBuilder withPosition(lat, lon) Declares the node position. Declares the node position. The method can be used in a static and in an instance context. Parameters: Name Type Description lat Number the latitude. A number in the range [-90..90]. lon Number the longitude. A number in the range [-180..180]. Source: josm/builder.js, line 437 Returns: a node builder (for method chaining) Type module:josm/builder~NodeBuilder Example const nbuilder = require('josm/builder').NodeBuilder // a new global node with the global id 12345 at position (34,45) const n1 = nbuilder.withPosition(34,45).create(12345) // a new local node at position (23.2, 87.33) const n2 = nbuilder.withPosition(23.3,87.33).create() withTags( [tags]) Declares the node tags. Declares the tags to be assigned to the new node. The method can be used in a static and in an instance context. Parameters: Name Type Argument Description tags object &lt;optional&gt; the tags Source: josm/builder.js, line 473 Returns: the node builder (for method chaining) Type module:josm/builder~NodeBuilder Example const nbuilder = require('josm/builder').NodeBuilder // a new global node with the global id 12345 and tags name=test and // highway=road const n1 = nbuilder.withTags({'name':'test', 'highway':'road'}).global(12345) // a new local node tags name=test and highway=road const tags = { 'name' : 'test', 'highway' : 'road' } const n2 = nbuilder.withTags(tags).local() × Search results Close "},"module-josm_builder-RelationBuilder.html":{"id":"module-josm_builder-RelationBuilder.html","title":"Class: RelationBuilder","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: RelationBuilder josm/builder~ RelationBuilder new RelationBuilder(ds) Helps to create Relations RelationBuilder helps to create OSM Relations. Methods of RelationBuilder can be used in a static and in an instance context. It isn't necessary to create an instance of RelationBuilder, unless it is configured with a DataSet, which created ways are added to. Parameters: Name Type Description ds org.openstreetmap.josm.data.osm.DataSet (optional) a JOSM dataset which created ways are added to. If missing, the created ways aren't added to a dataset. Source: josm/builder.js, line 962 Example const RelationBuilder = require('josm/builder').RelationBuilder const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() // create a relation builder without and underlying dataset ... const rbuilder = new RelationBuilder() // ... with an underlying dataset ... rbuilder = new RelationBuilder(ds) // ... or using this factory method rbuilder = RelationBuilder.forDataSet(ds) // create a new local relation const r1 = rbuilder.create() // create a new global way const r2 = rbuilder.withTags({route: 'bicycle'}).create(123456) // create a new proxy for a global relation // (an 'incomplete' node in JOSM terminology) const r3 = rbuilder.createProxy(123456) Methods &lt;static&gt; forDataSet(ds) Creates a new RelationBuilder which adds created relations to a dataset Creates or configures a RelationBuilder which will add created nodes to the dataset ds. Parameters: Name Type Description ds org.openstreetmap.josm.data.osm.DataSet a JOSM dataset which created ways are added to. Source: josm/builder.js, line 1009 Returns: the relation builder Type module:josm/builder.RelationBuilder Example const builder = require('josm/builder') // create a new relation builder building to a data set const DataSet = Java.type('org.openstreetmap.josm.data.osm') const ds = new DataSet() const rb = builder.RelationBuilder.forDataSet(ds) // configure an existing relation builder let wb = new builder.RelationBuilder() wb = wb.forDataSet(ds) &lt;static&gt; member( [role], primitive) Utility function - creates a relation member Create a RelationMember member(role, obj) Create a relation member with role role and member object obj. role can be null or undefined, obj must neither be null nor undefinde. role is a string, obj is an OSM node, a way, or a relation. member(obj) Create a relation member for the member object obj. obj must neither be null nor undefinde. obj is an OSM node, a way, or a relation. The created relation member has no role. Parameters: Name Type Argument Description role string &lt;optional&gt; the member role primitive primitive the member primitive Source: josm/builder.js, line 1045 Returns: the relation member Type org.openstreetmap.josm.data.osm.RelationMember Example const member = require('josm/builder').RelationBuilder.member const nb = require('josm/builder').NodeBuilder // create a new RelationMember with role 'house' for a new node const m1 = member('house', nb.create()) // create a new RelationMember with an empty role for a new node const m2 = member(nb.create()) create( [id] [, args]) Creates a new relation. Creates a new relation. Can be used in an instance or in a static context. Optional named arguments in the parameters args id - the id of a global relation (number &gt; 0) version - the version of a global relation (number &gt; 0) members - an array or a list of relation members, nodes, ways, or relation tags - an object with tags. Null values and undefined values are ignored. Any other value is converted to a string. Leading and trailing white space in keys is removed. Parameters: Name Type Argument Description id number &lt;optional&gt; a global way id. If missing and not set before using withId(..), creates a new local id. args object &lt;optional&gt; additional parameters for creating the relation Source: josm/builder.js, line 1299 Returns: the relation Type org.openstreetmap.josm.data.osm.Relation Example const { NodeBuilder, RelationBuilder } = require('josm/builder') const member = RelationBuilder.member // create a new local relation const r1 = rb.create() // create a new global relation const r2 = rb.create(12345) // create a new global relation with version 3 with some tags and two // members const r3 = rb.create(12345, { version: 3, tags: {type: 'route'}, members: [member('house', nb.create()), member(nb.create())] }) createProxy(id) Creates a new proxy relation. Creates a new proxy relation. A proxy relation is a relation, for which we only know its global id. In order to know more details (members, tags, etc.), we would have to download it from the OSM server. The method can be used in a static and in an instance context. Parameters: Name Type Description id number the id for the proxy relation Source: josm/builder.js, line 1181 Returns: the new proxy relation Type org.openstreetmap.josm.data.osm.Relation Example const rbuilder = require('josm/builder').RelationBuilder // a new proxy relation for the global way with id 12345 const r1 = rbuilder.createProxy(12345) withId(id, version) Declares the relation id and version. Declares the global relation id and the global relation version. The method can be used in a static and in an instance context. Parameters: Name Type Description id number (mandatory) the global relation id. A number &gt; 0. version number (optional) the global relation version. If present, a number &gt; 0. If missing, the version 1 is assumed. Source: josm/builder.js, line 1119 Returns: the relation builder (for method chaining) Type module:josm/builder~RelationBuilder Example const rbuilder = require('josm/builder').RelationBuilder // creates a global relation with id 12345 an version 12 const r = rbuilder.withId(12345, 12).create() withMembers(nodes) Declares the members of a relation. Declares the members of a relation. Accepts either a vararg list of relation members, nodes, ways or relations, an array of relation members, nodes ways or relations, or a Java list of members, nodes, ways or relation. The method can be used in a static and in an instance context. Parameters: Name Type Description nodes the list of members. See description and examples. Source: josm/builder.js, line 1222 Returns: the relation builder (for method chaining) Type module:josm/builder~RelationBuilder Example const rbuilder = require('josm/builder').RelationBuilder const nbuilder = require('josm/builder').NodeBuilder const wbuilder = require('josm/builder').WayBuilder const member = require('josm/builder').RelationBuilder.member const r1 = rbuilder.withMembers( member('house', nbuilder.create()), member('house', nbuilder.create()), member('street', wbuilder.create()) ).create() withTags( [tags]) Declares the tags to be assigned to the new relation. Declares the tags to be assigned to the new relation. The method can be used in a static and in an instance context. Parameters: Name Type Argument Description tags object &lt;optional&gt; the tags Source: josm/builder.js, line 1147 Returns: a relation builder (for method chaining) Type module:josm/builder~RelationBuilder Example const rbuilder = require('josm/builder').RelationBuilder // a new global relation with the global id 12345 and tags route='bicycle' //and name='n8' const r1 = rbuilder.withTags({name:'n8', route:'bicycle'}).create(12345) // a new local node tags name=test and highway=road const tags = { name : 'n8', route : 'bicycle' } const r2 = rbuilder.withTags(tags).create() × Search results Close "},"module-josm_builder-WayBuilder.html":{"id":"module-josm_builder-WayBuilder.html","title":"Class: WayBuilder","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: WayBuilder josm/builder~ WayBuilder new WayBuilder( [ds]) Helps to create OSM Ways WayBuilder helps to create OSM Ways. Methods of WayBuilder can be used in a static and in an instance context. It isn't necessary to create an instance of WayBuilder, unless it is configured with a DataSet, to which created ways are added. Parameters: Name Type Argument Description ds org.openstreetmap.josm.data.osm.DataSet &lt;optional&gt; a JOSM dataset which created ways are added to. If missing, the created ways aren't added to a dataset. Source: josm/builder.js, line 540 Example const WayBuilder = require('josm/builder').WayBuilder const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() // create a way builder without and underlying dataset ... let wbuilder = new WayBuilder() // ... with an underlying dataset .... wbuilder = new WayBuilder(ds) // ... or using this factory method wbuilder = WayBuilder.forDataSet(ds) // create a new local way const w1 = wbuilder.create() // create a new global way const w2 = wbuilder.withTags({highway: 'residential'}).create(123456) // create a new proxy for a global way // (an 'incomplete' node in JOSM terminology) const w3 = wbuilder.createProxy(123456) Methods &lt;static&gt; forDataSet(ds) Creates a new WayBuilder with an underlying dataset. Creates a new builder for OSM ways Parameters: Name Type Description ds org.openstreetmap.josm.data.osm.DataSet the dataset which created objects are added to Source: josm/builder.js, line 579 Returns: the way builder Type module:josm/builder~WayBuilder &lt;static&gt; forDataSet(ds) Creates a new WayBuilder with an underlying dataset. Creates or configures a WayBuilder which will add created nodes to the dataset ds. Parameters: Name Type Description ds org.openstreetmap.josm.data.osm.DataSet the dataset which created objects are added to Source: josm/builder.js, line 598 Returns: the way builder Type module:josm/builder~WayBuilder Example const builder = require('josm/builder') // create a new way builder building to a data set const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet()') const ds = new DataSet() let wb = builder.WayBuilder.forDataSet(ds) // configure an existing way builder wb = new builder.WayBuilder() wb = wb.forDataSet(ds) create( [id] [, options]) Creates a new way Creates a new way. Can be used in an instance or in a static context. Optional named arguments in the parameters options: id:number the id of a global way (number &gt; 0) version:number the version of a global way (number &gt; 0) nodes:array|list an array or a list of nodes tags:object an object with tags. Null values and undefined values are ignored. Any other value is converted to a string. Leading and trailing white space in keys is removed. Parameters: Name Type Argument Description id number &lt;optional&gt; a global way id. If missing and not set before using withId(..), creates a new local id. options object &lt;optional&gt; additional parameters for creating the way Source: josm/builder.js, line 831 Returns: the created way Type org.openstreetmap.josm.data.osm.Way Example const wb = require('josm/builder').WayBuilder // create a new local way const w1 = wb.create() // create a new global way const w2 = wb.create(12345) // create a new global way with version 3 at a specific position and with // some tags const w3 = wb.create(12345, { version: 3, tags: {amenity: 'restaurant'}, nodes: [n1,n2,n3] }) createProxy() Creates a new proxy way Creates a new proxy way. A proxy way is a way, for which we only know its global id. In order to know more details (nodes, tags, etc.), we would have to download it from the OSM server. The method can be used in a static and in an instance context. Source: josm/builder.js, line 775 Returns: the new proxy way Type org.openstreetmap.josm.data.osm.Way Example const wbuilder = require('josm/builder').WayBuilder // a new proxy way for the global way with id 12345 const w1 = wbuilder.createProxy(12345) withId(id [, version]) Declares the global way id and the global way version. Declares the global way id and the global way version. The method can be used in a static and in an instance context. Parameters: Name Type Argument Description id number (mandatory) the global way id. A number &gt; 0. version number &lt;optional&gt; the global way version. If present, a number &gt; 0. If missing, the version 1 is assumed. Source: josm/builder.js, line 633 Returns: the way builder (for method chaining) Type module:josm/builder~WayBuilder Example const wbuilder = require('josm/builder').WayBuilder // creates a global way with id 12345 an version 12 const wb = wbuilder.withId(12345, 12).create() withNodes(nodes) Declares the nodes of the way. Declares the nodes of the way. Accepts either a vararg list of Node, an array of Nodes or a Java list of Nodes. At least two non-identical nodes have to be supplied. The same node can occure more than once in the list, but a consecutive sequence of the same node is collapsed to one node. The method can be used in a static and in an instance context. Parameters: Name Type Description nodes the list of nodes. See description and examples. Source: josm/builder.js, line 697 Returns: the way builder (for method chaining) Type module:josm/builder~WayBuilder Example oonst wbuilder = require('josm/builder').WayBuilder const nbuilder = require('josm/builder').NodeBuilder // creates a new local way with two local nodes const way = builder.withNodes( nbuilder.create(), nbuilder.create() ).create() withTags( [tags]) Declares the tags to be assigned to the new way. Declares the tags to be assigned to the new way. The method can be used in a static and in an instance context. Parameters: Name Type Argument Description tags object &lt;optional&gt; the tags Source: josm/builder.js, line 662 Returns: the way builder (for method chaining) Type module:josm/builder~WayBuilder Example const wbuilder = require('josm/builder').WayBuilder // a new global way with the global id 12345 and tags name='Laubeggstrasse' // and highway=residential const w1 = wbuilder.withTags({name:'Laubeggstrasse', highway:'residential'}) .create(12345) // a new local node tags name=test and highway=road const tags = { name : 'Laubeggstrasse', highway : 'residential' } const w2 = wbuilder.withTags(tags).create() × Search results Close "},"module-josm_command.html":{"id":"module-josm_command.html","title":"Module: josm/command","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/command A collection of functions to create commands which can be applied, undone and redone on OsmDataLayers. Source: josm/command.js, line 1 Classes ChangeCommand A command to change a collection of objects in a data layer. CommandHistory Accessor to the global command history DeleteCommand A command to delete a collection of objects in a data layer. AddCommand A command to add a collection of objects to a data layer Methods &lt;static&gt; add(primitives) Creates a command to add a collection of objects Creates a command to add a collection of objects to a data layer. Signatures add(obj, obj, ...) obj are Nodes, Ways, or Relationss. Or javascript array or Java collections thereof. Parameters: Name Type Argument Description primitives primitive | Array.&lt;primitive&gt; | java.lang.Collection &lt;repeatable&gt; the primitives to add Source: josm/command.js, line 132 Returns: the command object Type module:josm/command.AddCommand Example const cmd = require('josm/command') const layers = require('josm/layer') const layer = layers.get('Data Layer 1') // add two nodes cmd.add(n1,n1).applyTo(layer) // add an array of two nodes and a way layer.apply( cmd.add([n1,n2,w2]) ) &lt;static&gt; change() Creates a command to change a collection of objects Creates a command to change a collection of objects in a data layer. Signatures change(obj,obj,..., options) obj are Nodes, Ways, or Relationss. Or javascript array or Java collections thereof. The mandatory last argument is an object with named parameters. It accepts the following named parameters: lat:number Changes the latitude of the target nodes to lat. lon:number Changes the longitude of the target nodes to lon. pos: LatLon|object Changes the position of the target nodes to pos. pos is either a LatLon or an object {lat:..., lon:...} tags:Map|object Changes the tags of the target objects to tags. nodes:List|array Changes the nodes of the target way sto nodes. members:List|array Changes the nodes of the target relations to members. Source: josm/command.js, line 404 Returns: the change command object Type module:josm/command.ChangeCommand Example const cmd = require(\"josm/command\") const layers = require(\"josm/layer\") const layer = layers.get(\"Data Layer 1\") // change the position of a node cmd.change(n1,n1, {lat: 123.45, lon: 44.234}).applyTo(layer) // change the nodes of a way layer.apply( cmd.change(w2, {nodes: [n1,n2,3]}) ) // change the tags of a collection of primitives cmd.change(n1,n3, w1,r1, { tags: {'mycustommtag': 'value'} }).applyTo(layer) &lt;static&gt; combineSelectedWays() Combines the currently selected ways. Combines the currently selected ways in the active layer into one resulting way. Returns without effect if there is no active layer the active layer is not a data layer there are less than two selected ways in the active layer Reuses the logic behind the JOSM standard menu entry Tools-&gt;Combine Ways. If invoked from a script, this may trigger modal dialogs which are presented to the user, in particular if the direction of the ways has to be reversed because otherwise they could not be combined. Source: josm/command.js, line 649 Example const cmd = require('josm/command') const layers = require('josm/layer') const ds = layers.activeLayer.data const ways = [ds.way(1), ds.way(2), ds.way(3)] cmd.combineWays(ways) &lt;static&gt; combineWays(ways, ways) Combines two or more ways into one resulting way. Combines two or more ways into one resulting way. Reuses the logic behind the JOSM standard menu entry Tools-&gt;Combine Ways. If invoked from a script, this may trigger modal dialogs which are presented to the user, in particular if the direction of the ways has to be reversed because otherwise they could not be combined. Parameters: Name Type Description ways the ways to be combined ways org.openstreetmap.josm.data.osm.Way | array the ways to be combined Source: josm/command.js, line 594 Example const cmd = require('josm/command') const layers = require('josm/layer') const ds = layers.activeLayer.data const ways = [ds.way(1), ds.way(2), ds.way(3)] // pass in an array ... cmd.combineWays(ways) // ... or the individual ways ... cmd.combineWays(ds.way(1), ds.way(2), ds.way(3)) // ... or any combination thereof. &lt;static&gt; delete(primitives) Creates a command to delete a collection of objects Creates a command to delete a collection of objects in a data layer. Signatures delete(obj,obj,..., ?options) obj are Nodes, Ways, or Relationss. Or javascript array or Java collections thereof. Parameters: Name Type Argument Description primitives primitive | Array.&lt;primitive&gt; | java.lang.Collection &lt;repeatable&gt; the primitives to delete Source: josm/command.js, line 212 Returns: the command object Type module:josm/command.DeleteCommand Example const cmd = require('josm/command') const layers= require('josm/layer') const layer = layers.get('Data Layer 1') // delete two nodes cmd.delete(n1,n1).applyTo(layer) // delete an array of two nodes and a way layer.apply( cmd.delete([n1,n2,w2]) ) × Search results Close "},"module-josm_command.ChangeCommand.html":{"id":"module-josm_command.ChangeCommand.html","title":"Class: ChangeCommand","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: ChangeCommand josm/command. ChangeCommand new ChangeCommand(objs, change) A command to change a collection of objects in a data layer. A command to change a collection of objects in a data layer. Parameters: Name Type Description objs java.util.Collection | array the objects to change change org.openstreetmap.josm.plugins.scripting.js.api.Change the change specification Source: josm/command.js, line 368 Methods applyTo(layer) Applies the command to a layer. Applies the command to a layer. Parameters: Name Type Description layer org.openstreetmap.josm.gui.layer.OsmDataLayer the data layer Source: josm/command.js, line 373 createJOSMCommand(layer) Creates the internal JOSM command for this command Creates the internal JOSM command for this command Parameters: Name Type Description layer org.openstreetmap.josm.gui.layer.OsmDataLayer the data layer Source: josm/command.js, line 385 Returns: the command object Type org.openstreetmap.josm.command.Command × Search results Close "},"module-josm_command.CommandHistory.html":{"id":"module-josm_command.CommandHistory.html","title":"Class: CommandHistory","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: CommandHistory josm/command. CommandHistory new CommandHistory() Accessor to the global command history Accessor to the global command history. Provides static methods to redo and undo commands. Source: josm/command.js, line 507 Methods &lt;static&gt; clear( [layer]) Removes commands in the command history Removes commands in the command history, either all commands, or only the commands applied to a specific layer. Parameters: Name Type Argument Description layer org.openstreetmap.josm.gui.layer.Layer &lt;optional&gt; the reference layer. Only commands applied to this layer are removed. Default if missing: all commands are removed. Source: josm/command.js, line 557 &lt;static&gt; redo( [depth]) Redoes the last depth commands. Redoes the last depth commands. Parameters: Name Type Argument Default Description depth number &lt;optional&gt; 1 the number of commands to be redone. Source: josm/command.js, line 533 &lt;static&gt; undo( [depth]) Undoes the last depth commands. Undoes the last depth commands. Parameters: Name Type Argument Default Description depth number &lt;optional&gt; 1 the number of commands to be undone Source: josm/command.js, line 509 × Search results Close "},"module-josm_command.DeleteCommand.html":{"id":"module-josm_command.DeleteCommand.html","title":"Class: DeleteCommand","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: DeleteCommand josm/command. DeleteCommand new DeleteCommand(objs, objs) A command to delete a collection of objects in a data layer. A command to delete a collection of objects in a data layer. Parameters: Name Type Description objs java.util.Collection | array the objects to add objs java.util.Collection | array the objects to add Source: josm/command.js, line 177 Methods applyTo(layer) Applies the command to a layer. Applies the command to a layer. Parameters: Name Type Description layer org.openstreetmap.josm.gui.layer.OsmDataLayer the data layer Source: josm/command.js, line 181 createJOSMCommand(layer) Creates the internal JOSM command for this command Creates the internal JOSM command for this command Parameters: Name Type Description layer org.openstreetmap.josm.gui.layer.OsmDataLayer the data layer Source: josm/command.js, line 193 Returns: the command object Type org.openstreetmap.josm.command.Command × Search results Close "},"module-josm_command-AddCommand.html":{"id":"module-josm_command-AddCommand.html","title":"Class: AddCommand","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: AddCommand josm/command~ AddCommand new AddCommand(objs) A command to add a collection of objects to a data layer A command to add a collection of objects to a data layer. Parameters: Name Type Description objs java.util.Collection | array the objects to add Source: josm/command.js, line 83 × Search results Close "},"module-josm_ds.html":{"id":"module-josm_ds.html","title":"Module: josm/ds","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/ds Provides utitly methods for data sets Source: josm/ds.js, line 1 Classes DataSetUtil Build an utility object wrapping the dataset ds × Search results Close "},"module-josm_ds-DataSetUtil.html":{"id":"module-josm_ds-DataSetUtil.html","title":"Class: DataSetUtil","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: DataSetUtil josm/ds~ DataSetUtil DataSetUtil provides methods to build OSM primitive IDs and to manipulate data in a DataSet. new DataSetUtil( [ds]) Build an utility object wrapping the dataset ds Creates an instane of DataSetUtil for a given DataSet Parameters: Name Type Argument Description ds org.openstreetmap.josm.data.osm.DataSet &lt;optional&gt; the dataset. Creates a new dataset if missing Source: josm/ds.js, line 165 Example const { DataSetUtil, DataSet } = require('josm/ds') const dsutil = new DataSetUtil(new DataSet()) Members &lt;readonly&gt; nodeBuilder Replies a node builder to create Nodes in this dataset. Properties: Name Type Description nodeBuilder module:josm/builder~NodeBuilder Source: josm/ds.js, line 408 Example const { DataSet, DataSetUtil } = require('josm/ds') const dsutil = new DataSetUtil(new DataSet()) const n = dsutil.nodeBuilder .withId(1234,4567) .withTags({amenity: 'restaurant'}) .create() dsutil.has(n) &lt;readonly&gt; relationBuilder Replies a relation builder to create relations in this dataset. Properties: Name Type Description relationBuilder module:josm/builder~RelationBuilder Source: josm/ds.js, line 447 Example const { DataSet, DataSetUtil } = require('josm/ds') const dsutil = new DataSetUtil(new DataSet()) const r = dsutil.relationBuilder() .withId(8765,1234) .create({tags: {type: \"network\"}}) ds.has(r) // --&gt; true &lt;readonly&gt; wayBuilder Replies a way builder to create ways in this dataset. Properties: Name Type Description wayBuilder module:josm/builder~WayBuilder Source: josm/ds.js, line 428 Example const { DataSet, DataSetUtil } = require('josm/ds') const dsutil = new DataSetUtil(new DataSet()) const nb = dsutil.nodeBuilder() const w = dsutil.wayBuilder() .withNodes(nb.create(), nb.create()) .create(1234, {tags: {highway: \"residential\"}}) dsutil.has(w) Methods &lt;static&gt; load(source [, options]) Loads a dataset from a file. Derives the format of the file from the file suffix, unless the named option options.format is set. options can contain the following named options: format one of the strings osm (Open Street Map XML data), osc (Open Street Map change format), or osm.gz (Open Street Map XML data, compressed with gzip). format is normalized by removing leading and trailing whitespace and conversion to lower case. Parameters: Name Type Argument Description source string | java.io.File the data source options object &lt;optional&gt; optional named parameters Source: josm/ds.js, line 480 Example const { DataSetUtil } = require('josm/ds') // loads an OSM file const dsutil1 = DataSetUtil.load('/path/to/my/file.osm') // loads an OSM file, expli const dsutil2 = DataSetUtil.load( '/path/to/my/file.any-suffix', { format 'osm' }) batch(delegate) Run a sequence of operations against the dataset in \"batch mode\". Listeners to data set events are only notified at the end of the batch. Parameters: Name Type Description delegate function the function implementing the batch process. Ignored if null or undefined. Source: josm/ds.js, line 292 Example const { DataSet, DataSetUtil } = require('josm/ds') const dsutil = new DataSetUtil(new DataSet()) // creates and adds two nodes and a way in batch operation // to the dataset dsutil.batch(() =&gt; { const n1 = dsutil.nodeBuilder().create() const n2 = dsutil.nodeBuilder().create() dsutil.wayBuilder().withNodes(n1,n2).create() }) get(args) Replies an OSM object from the dataset, or undefined, if no such object exists. Signatures get(id, type) Replies an object given by its unique numeric id and a type. The type is either a string \"node\", \"way\", or \"relation\", or one of the symbols OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. get(id) Replies an object given an ID. id is either an instance of PrimitiveId or an object with the properties id and type, i.e. {id: 1234, type: \"node\"}. Parameters: Name Type Description args see description Source: josm/ds.js, line 215 Example const { buildId , DataSetUtil, DataSet, OsmPrimitiveType} = require('josm/ds') const dsutil = new DataSetUtil(new DataSet()) // get a node const n1 = dsutil.get(1234, 'node') // get a way const w1 = dsutil.get(3333, OsmPrimitiveType.WAY) // get a relation const r1 = dsutil.get({id: 5423, type: \"relation\"}) // pass in a SimplePrimitiveId const id = buildId(-5, OsmPrimitiveType.NODE) const n2 = dsutil.get(id) // pass in a primitive to get it const w2 = dsutil.wayBuilder().create(987) const w3 = dsutil.get(w2) node(id) Replies the node with id id, or null. Parameters: Name Type Description id number the unique numeric id. Must not be 0. Source: josm/ds.js, line 233 Returns: the node Type org.openstreetmap.josm.data.osm.Node Example const { DataSet, DataSetUtil } = require('josm/ds') const dsutil = new DataSetUtil(new DataSet()) // get a node const n = dsutil.node(1234) query(expression [, options]) Queries the dataset Signatures query(josmSearchExpression,?options) Queries the dataset using the JOSM search expression josmSearchExpression. josmSearchExpression is a string as you would enter it in the JOSM search dialog. options is an (optional) object with named parameters, see below. query(predicate,?options) Queries the dataset using a javascript predicate function predicate. predicate is a javascript function which accepts a object as parameter and replies true, when it matches for the object ans false otherwise. options is an (optional) object with named parameters, see below. The parameter options consist of the following (optional) named parameters: allElements : boolean (Deprecated parameter names: all) If true, searches all objects in the dataset. If false, ignores incomplete or deleted objects. Default: false. caseSensitive : boolean Only applicable for searches with a JOSM search expression. If true, searches case sensitive. If false, searches case insensitive. Default: false. regexSearch : boolean (Deprecated parameter names: withRegexp, regexpSearch) Only applicable for searches with a JOSM search expression. If true, the search expression contains regular expressions. If false, it includes only plain strings for searching. Default: false. mapCSSSearch Only applies for searches with a JOSM search expression. Default: false. Parameters: Name Type Argument Description expression string | function the match expression options object &lt;optional&gt; additional named parameters Source: josm/ds.js, line 733 Example const { DataSetUtil } = require('josm/ds') const dsutil = new DataSetUtil() // add or load primitives to query // ... // query restaurants const result1 = dsutil.query('amenity=restaurant') // query all nodes with a type query const result2 = dsutil.query('type:node') // query using a custom predicate - all primitives // with exactly two tags const result3 = dsutil.query((primitive) =&gt; { primitive.getKeys().size() ===2 }) relation(id) Replies the relation with id id. Parameters: Name Type Description id number the unique numeric id. Must not be 0. Source: josm/ds.js, line 268 Returns: the relation Type org.openstreetmap.josm.data.osm.Relation Example const { DataSet, DataSetUtil } = require('josm/ds') const dsutil = new DataSetUtil(new DataSet()) // get a relation const r = dsutil.relation(1234) remove(args) Removes objects from the dataset Signatures remove(id, type) Removes a single object given by its unique numeric ID (nid) and a type. The type is either a string \"node\", \"way\", or \"relation\", or one of the symbols OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. remove(id, id, ...) Removes a collection of objects given by the ids. id is either an instance of PrimitiveId or an object with the properties id and type, i.e. {id: 1234, type: \"node\"}. null and undefined are ignored. remove(array|collection) Removes a collection of objects given by the an array or a java.util.Collection of ids. The collection elemeents are either instances of PrimitiveId or an object with the properties id and type, i.e. {id: 1234, type: \"node\"}. null or undefined elements are ignored. Parameters: Name Type Description args see description Source: josm/ds.js, line 365 Example const { DataSet, DataSetUtil, OsmPrimitiveType, buildId} = require('josm/ds') const HashSet = Java.type('java.util.HashSet') const dsutil = new DataSetUtil(new DataSet()) // remove a node with a global id dsutil.remove(1234, \"node\") // remove a node and a way const id1 = buildId(1234, \"node\") const id2 = buildId(3333, OsmPrimitiveType.WAY) dsutil.remove(id1, id2) // remove a relation and a node dsutil.remove({id: 1234, type: \"relation\"}, id1) // remove an array of nodes dsutil.remove([id1,id2]) // remove a set of primitives const ids = new HashSet() ids.add(id1) ids.add(id1) dsutil.remove(ids) save(target [, options]) Saves the dataset to a file (in OSM XML format). options can contain the following named options: version: string the value of the attribute version in the OSM file header. Default: \"0.6\" changeset: Changeset the changeset whose id is included in the attribute changeset on every OSM object. If undefined, includes the individual changeset attribute of the OSM object. Default: undefined osmConform: bool if true, prevents modification attributes to be written Default: true Parameters: Name Type Argument Description target string | java.io.File the target file options object &lt;optional&gt; optional named parameters Source: josm/ds.js, line 601 Example const { DataSetUtil } = require('josm/ds') const dsutil = new DataSetUtil() // create a node in the dataset dsutil.nodeBuilder() .withId(1, 1) .withPosition({ lat: 1.0, lon: 1.0 }) .create() // save the dataset dsutil.save('/tmp/my-dataset.osm') way(id) Replies the way with id id, or null Parameters: Name Type Description id number the unique numeric id. Must not be 0. Source: josm/ds.js, line 250 Returns: the way Type org.openstreetmap.josm.data.osm.Way Example const { DataSet, DataSetUtil } = require('josm/ds') const dsutil = new DataSetUtil(new DataSet()) // get a way const w = dsutil.way(1234) × Search results Close "},"module-josm_layers.html":{"id":"module-josm_layers.html","title":"Module: josm/layers","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/layers Provides access to the JOSM layers. Source: josm/layers.js, line 1 Members &lt;static&gt; activeLayer Set or get the active layer. Set or get the active layer. get Replies the active layer or undefined. set Assign either an existing Layer, the name of a layer as string, or a layer index as number. Properties: Name Type Description activeLayer org.openstreetmap.josm.layer.Layer the active layer Source: josm/layers.js, line 32 &lt;static, readonly&gt; length Replies the number of currently open layers. Replies the number of currently open layers. Properties: Name Type Description length number the number of layers Source: josm/layers.js, line 17 Methods &lt;static&gt; add(obj) Adds a layer. Adds a layer. Either pass in a layer object or a data set. In the later case, an OsmDataLayer is automatically created. Parameters: Name Type Description obj org.openstreetmap.josm.gui.layer.Layer | org.openstreetmap.josm.data.osm.DataSet a layer to add, or a dataset. Ignored if null or undefined. Source: josm/layers.js, line 161 Returns: the added layer Type org.openstreetmap.josm.gui.layer.Layer Example const layers = require('josm/layers') const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const dataLayer = new OsmDataLayer(new DataSet(), null, null); // add a layer ... layers.add(dataLayer) // or add a dataset, which will create a data layer const ds = new DataSet() layer.add(ds) &lt;static&gt; addDataLayer(args) Adds a data layer Creates and adds a new data layer. The new layer becomes the new edit layer. Signatures addDataLayer() create data layer with a new dataset and default name addDataLayer(ds) create data layer with dataset ds and default name addDataLayer(name) create data layer with a new dataset and name name addDataLayer({name: ..., ds: ...}) create data layer with a new dataset and name name Parameters: Name Type Description args string | org.openstreetmap.josm.data.osm.DataSet | object see description Source: josm/layers.js, line 252 Returns: the added layer Type org.openstreetmap.josm.gui.layer.OsmDataLayer Example const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') // creates a new data layer const l1 = josm.layers.addDataLayer() // creates a new data layer with name 'test' const l2 = josm.layers.addDataLayer('test') // creates a new data layer for the dataset ds const ds = new DataSet() const l3 = josm.layers.addDataLayer(ds) &lt;static&gt; get(key) Replies one of the layers given a key. Replies one of the layers given a key. If key is a number, replies the layer with index key, or undefined, if no layer for this index exists. If key is a string, replies the first layer whose name is identical to key (case insensitive, without leading/trailing whitespace), or undefined, if no layer with such a name exists. Parameters: Name Type Description key number | string the key to retrieve the layer Source: josm/layers.js, line 88 Returns: Type org.openstreetmap.josm.layer.Layer Example const layers = require('josm/layers') // get the first layer const layer1 = layers.get(0) // get the first layer with name \"data layer\" const layer2 = layers.get('data layer') &lt;static&gt; has(layer) Checks whether layer is currently registered layer. Checks whether layer is a currently registered layer. Parameters: Name Type Description layer org.openstreetmap.josm.gui.layer.Layer | string | number a layer, a layer name, or a layer index Source: josm/layers.js, line 122 Returns: true, if the layer or at least one layer with the given name exists. False, otherwise. Type boolean Example const layers = require('josm/layers') // is there a layer with name \"my layer\"? let b = layers.has('my layer') // is there a layer at index position 2 b = layers.has(2) // is there a specific layer? let l = layers.get(0) b = layers.has(l) &lt;static&gt; remove(key) Removes a layer. Removes a layer with the given key. If key is a Number, removes the layer with the index key. If the index doesn't isn't a valid layer index, nothing is removed. If key is a string, removes the layer with the name key. Leading and trailing white space is removed, matching is a case-insensitive sub-string match. Parameters: Name Type Description key number | string indicates the layer to remove Source: josm/layers.js, line 215 Example const josm = require('josm') // remove the first layer josm.layers.remove(0) // remove the first layer matching with the supplied name josm.layers.remove('myLayerName') × Search results Close "},"module-josm_scriptingconsole.html":{"id":"module-josm_scriptingconsole.html","title":"Module: josm/scriptingconsole","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/scriptingconsole Provides a set of functions to write to the built-in scripting console. Source: josm/scriptingconsole.js, line 1 Methods &lt;static&gt; clear() Clears the scripting console. Clears the scripting console. Source: josm/scriptingconsole.js, line 90 Example const console = require('josm/scriptingconsole') console.clear() &lt;static&gt; hide() Hides the scripting console Hides the scripting console Source: josm/scriptingconsole.js, line 123 Example var console = require('josm/scriptingconsole') console.hide() &lt;static&gt; print(message [, values]) Prints a string to the console Prints a string to the console Parameters: Name Type Argument Description message string the message values object &lt;optional&gt; &lt;repeatable&gt; optional values Source: josm/scriptingconsole.js, line 18 Example const console = require('josm/scriptingconsole') console.print('Hello world!') // or use formatting console.print('Hello world! My name is {0}', 'foo') &lt;static&gt; println(message [, values]) Prints a string to the console, including newline Prints a string to the console, including newline Parameters: Name Type Argument Description message string the message values object &lt;optional&gt; &lt;repeatable&gt; optional values Source: josm/scriptingconsole.js, line 54 Example const console = require('josm/scriptingconsole') console.println('Hello world!') // or use formatting console.println('Hello world! My name is {0}', 'foo'); &lt;static&gt; show() Shows the scripting console Shows the scripting console Source: josm/scriptingconsole.js, line 107 Example const console = require('josm/scriptingconsole') console.show() &lt;static&gt; toggle() Toggles the visibility of the scripting console Toggles the visibility of the scripting console Source: josm/scriptingconsole.js, line 139 Example const console = require('josm/scriptingconsole') console.toggle() × Search results Close "},"module-josm_ui_menu.html":{"id":"module-josm_ui_menu.html","title":"Module: josm/ui/menu","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/ui/menu Provides a collection of namespaces, classes and functions to work with JOSMs menu system. Source: josm/ui/menu.js, line 1 Classes MenuBar × Search results Close "},"module-josm_ui_menu-MenuBar.html":{"id":"module-josm_ui_menu-MenuBar.html","title":"Class: MenuBar","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: MenuBar josm/ui/menu~ MenuBar new MenuBar() Represents JOSMs global menu bar. Source: josm/ui/menu.js, line 19 Members &lt;static&gt; JSAction JSAction is an action for which a menu item or a toolbar item can be added to JOSMs menu or JOSMs toolbar respectively. This is just a shortcut for the Java class JSAction. The constructor accepts an object with the following optional named parameters. name:string The optional name of the action. Default: an auto generated named. tooltip:string The optional tooltip of the action. Default: empty string. iconName:string The optional name of an icon. Default: null. toolbarId:string The optional name of the tooblar, this action is going to be added to later. Note, that it isn't added automatically, when this action is created. Default: null. onExecute:function The (optional) function which is called when the action is executed. Default: null. onInitEnabled:function The (optional) function which is called when the enabled state of the function is evaluated the first time. Default: null. onUpdateEnabled:function The (optional) function which is called when the enabled state of the function is reevaluated, in particular, when layer change events or selection change events occur. Default: null. Properties: Name Type Description JSAction org.openstreetmap.josm.plugins.scripting.js.JSAction Source: josm/ui/menu.js, line 124 Example const JSAction = require(\"josm/ui/menu\").JSAction; const action = new JSAction({ name: \"My Action\", tooltip: \"This is my action\", onInitEnabled: function() { this.enabled = false } }) action.onExecute = function() { josm.alert(\"Action is executing ...\") } &lt;static&gt; length the number of menus in the JOSM menu bar Replies the number of menus in the JOSM menu bar. Properties: Name Type Description length number the number of menues Source: josm/ui/menu.js, line 27 Example // display the number of menus josm.alert(josm.menu.length) &lt;static, readonly&gt; menuNames Replies an array with the symbolic menu names. Replies an array with the symbolic menu names. Properties: Name Type Description menuNames array the names of the menues in the menu bar Source: josm/ui/menu.js, line 106 Methods get(key) Replies a menu in the JOSM menu bar. Replies a menu in the JOSM menu bar. key is either a numberic index or one of the following symbolic names as string: file edit view tools presets imagery window help Parameters: Name Type Description key number | string the key denoting the menu Source: josm/ui/menu.js, line 48 Returns: the menu Type javax.swing.JMenu Example // get the edit menu with a numeric index const editmenu = josm.menu.get(1) // get the file menu with a symbolic name const filemenu = josm.menu.get('file') × Search results Close "},"module-josm_util.html":{"id":"module-josm_util.html","title":"Module: josm/util","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/util Provides a set of static utility functions. Source: josm/util.js, line 1 Methods &lt;static&gt; assert(condition [, message] [, values]) Assert a condition and throw an Error if the condition isn't met. Assert a condition and throw an Error if the condition isn't met. Usage: assert() Does nothing assert(cond) Checks the condition cond. If it is false, throws an Error. assert(cond, msg) Checks the condition cond. If it is false, throws an Error, whose description property is set to msg. assert(cond, msg, objs...) Checks the condition cond. If it is false, throws an Error, whose description property is set to the formatted message msg. Internally uses java.text.MessageFormat to format the message. Parameters: Name Type Argument Description condition boolean message string &lt;optional&gt; the message values object &lt;optional&gt; &lt;repeatable&gt; an optional list of values Source: josm/util.js, line 60 Example const util = require(\"josm/util\") // throws an Error util.assert(false) // throws an Error e, with e.description == \"My message\" util.assert(false, \"My message\") // throws an Error e, with e.description == \"My message: test\" util.assert(false, \"My message: {0}\", \"test\") &lt;static&gt; assertNumber(value [, msg] [, values]) Asserts that val is a number. Asserts that val is a number. Parameters: Name Type Argument Description value Anything the value to check msg String &lt;optional&gt; message if the assertion fails values object &lt;optional&gt; &lt;repeatable&gt; values used in msg placeholders Source: josm/util.js, line 170 &lt;static&gt; assertSomething(val [, msg] [, values]) Asserts that val is defined and non-null. Asserts that val is defined and non-null. Parameters: Name Type Argument Description val any the value to check msg string &lt;optional&gt; message if the assertion fails values object &lt;optional&gt; &lt;repeatable&gt; additional values used in msg placeholders Source: josm/util.js, line 138 Example const util = require(\"josm/util\"); util.assertSomething(null); // -&gt; throws an exception util.assertSomething(void 0); // -&gt; throws an exception util.assertSomting(\"test\"); // -&gt; OK util.assertSomething(5); // -&gt; OK &lt;static&gt; countProperties(o) Replies the number of properties owned by o. Replies the number of properties owned by o. Parameters: Name Type Description o any the object Source: josm/util.js, line 263 Returns: the number of properties owned by o. Type number Example const util = require(\"josm/util\") let o = {p1: \"v1\", p2: \"v2\"} let c = util.countProperties(o) // -&gt; 2 o = {} c = util.countProperties(o) // -&gt; 0 o = undefined c = util.countProperties(o) // -&gt; undefined &lt;static&gt; each(collection, delegate) Iteraties over the elements of a collection Iterates over the elements in collection and invokes delegate() on each element. Parameters: Name Type Description collection array | arguments | java.util.Collection the collection of elements delegate function the function to call on each elemennt Source: josm/util.js, line 439 &lt;static&gt; hasProperties(o) Replies true, if o owns at least one property. Replies true, if o owns at least one property. Parameters: Name Type Description o any the object Source: josm/util.js, line 294 Returns: true, if o owns at least one property. Type boolean Example const util = require(\"josm/util\"); let o = {p1: \"v1\", p2: \"v2\"}; let c = util.hasProperties(o); // -&gt; true o = {}; c = util.hasProperties(o); // -&gt; false o = undefined; c = util.hasProperties(o); // -&gt; false &lt;static&gt; isArguments(value) Replies true if val is a list of arguments. Replies true if val is a list of arguments. Parameters: Name Type Description value anything the value to check Source: josm/util.js, line 249 Returns: true, if val is a list of arguments Type boolean &lt;static&gt; isArray(value) Replies true if val is an array. Replies true if val is an array. Parameters: Name Type Description value anything the value to check Source: josm/util.js, line 235 Returns: true, if val is an array Type boolean &lt;static&gt; isCollection(value) Is a value a collection? Replies true, if a value is an array, an arguments list or a Java collection. Parameters: Name Type Description value object the value to check Source: josm/util.js, line 465 Returns: true, if value is a collection Type boolean &lt;static&gt; isDef(value) Returns true if val is defined. Returns true if val is defined. Parameters: Name Type Description value any the value to check Source: josm/util.js, line 192 Returns: true if val is defined Type boolean &lt;static&gt; isFunction(f) Replies true, if f is a function. Replies true, if f is a function. Parameters: Name Type Description f any the object Source: josm/util.js, line 321 Returns: true, if f is a function. Type boolean &lt;static&gt; isNumber(value) Returns true if val is a number. Returns true if val is a number. Parameters: Name Type Description value any the value to check Source: josm/util.js, line 206 Returns: true if val is a number Type boolean &lt;static&gt; isString(value) Returns true if val is a string. Returns true if val is a string. Parameters: Name Type Description value any the value to check Source: josm/util.js, line 220 Returns: true, if val is a string or a String object Type boolean &lt;static&gt; javaEquals(o1, o2) Are two java objects equal. Checks whether two java objects are either both null or equal by calling o1.equals(o2). Parameters: Name Type Description o1 object a java object or null o2 object a java object or null Source: josm/util.js, line 419 Returns: Type boolean &lt;static&gt; mix() Mixes the properties of a list of objects into one object. Mixes the properties of a list of objects into one object. Source: josm/util.js, line 335 Returns: a new object which includes the combined properties of the argument objects Type object &lt;static&gt; print(message [, args]) Prints a message to stdout (without newline). Prints a message to stdout (without newline). Supports the same string templates as MessageFormat Parameters: Name Type Argument Description message string args object &lt;optional&gt; &lt;repeatable&gt; Source: josm/util.js, line 392 Example const myname = \"...\" util.print(\"Hello world! My name is {0}\", myname) // escape meta characters like {, } or ' with a leading apostrophe util.print(\" a pair of curly braces '{'}\") &lt;static&gt; println(message [, args]) Prints a message to stdout (including newline). Prints a message to stdout (including newline). Supports the same string templates as MessageFormat. Parameters: Name Type Argument Description message string args object &lt;optional&gt; &lt;repeatable&gt; Source: josm/util.js, line 365 Example var myname = \"...\"; util.println(\"Hello world! My name is {0}\", myname); // escape meta characters like {, } or ' with a leading apostrophe util.println(\" a pair of curly braces '{'}\"); &lt;inner&gt; isNothing(value) Checks whether a value is null or undefined. Checks whether a value is null or undefined. Parameters: Name Type Description value object the value to check Source: josm/util.js, line 14 Returns: false, if value is null or undefined; true, otherwise Type boolean &lt;inner&gt; isSomething(value) Checks whether a value is neither null nor undefined. Checks whether a value is neither null nor undefined. Parameters: Name Type Description value object the value to check Source: josm/util.js, line 27 Returns: false, if value is null or undefined; true, otherwise Type boolean &lt;inner&gt; trim(s) Trims leading and trailing whitespace from s. Trims leading and trailing whitespace from s. Replies s, if s is null or undefined. Any other value is converted to a string, then leading and trailing white space is removed. Parameters: Name Type Description s string the string to be trimmed Source: josm/util.js, line 40 Returns: Type string × Search results Close "},"NodeBuilder.NodeBuilder.html":{"id":"NodeBuilder.NodeBuilder.html","title":"Class: NodeBuilder","body":" JOSM Scripting Plugin - JavaScript API V2 Modules clipboardjosmjosm/apijosm/builderjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/util Classes josm/api~Apijosm/api~ApiConfigjosm/api~ChangesetApijosm/builder~NodeBuilderjosm/builder~RelationBuilderjosm/builder~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds~DataSetUtiljosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: NodeBuilder NodeBuilder new NodeBuilder(ds) Creates a new node builder. Parameters: Name Type Description ds org.openstreetmap.josm.data.osm.DataSet (optional) the dataset, to which created objects are added Source: josm/builder.js, line 213 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
