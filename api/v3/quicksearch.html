<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"clipboard.mjs.html":{"id":"clipboard.mjs.html","title":"Source: clipboard.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: clipboard.mjs /** * Provides access to the system clipboard * * @module clipboard * * @example * import clipboard from 'clipboard' * */ /* global Java */ const clipboard = {} export default clipboard /** * Set or get the clipboard content as text * * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;get&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies the clipboard content as text or &lt;code&gt;undefined&lt;/code&gt;, * if no clipboard content is available or if it can't be converted to a * string.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;set&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Sets the clipboard content&lt;/dd&gt; * &lt;/dl&gt; * * @example * import clipboard from 'clipboard' * // set the clipboard content * clipboard.text = 'Hello World!' * * @property {string} text clipboard content as text * @name text * @summary Set or get the clipboard content as text * @static */ Object.defineProperty(clipboard, 'text', { enumerable: true, get: function () { const Toolkit = Java.type('java.awt.Toolkit') const DataFlavor = Java.type('java.awt.datatransfer.DataFlavor') const transferable = Toolkit.getDefaultToolkit() .getSystemClipboard().getContents(null) try { if (transferable &amp;&amp; transferable.isDataFlavorSupported(DataFlavor.stringFlavor)) { return transferable.getTransferData(DataFlavor.stringFlavor) } } catch (e) { } return undefined }, set: function (value) { const StringSelection = Java.type('java.awt.datatransfer.StringSelection') const Toolkit = Java.type('java.awt.Toolkit') Toolkit.getDefaultToolkit().getSystemClipboard().setContents( new StringSelection(String(value || '')), null ) } }) Ã— Search results Close "},"josm.mjs.html":{"id":"josm.mjs.html","title":"Source: josm.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm.mjs /** * This modules exports an objects with a set of properties and methods * to access JOSMs internals. * * @example * import josm from 'josm' * * @module josm */ /* global Java */ const Version = Java.type('org.openstreetmap.josm.data.Version') const JOptionPane = Java.type('javax.swing.JOptionPane') const HelpAwareOptionPane = Java.type('org.openstreetmap.josm.gui.HelpAwareOptionPane') const MainApplication = Java.type('org.openstreetmap.josm.gui.MainApplication') import * as util from 'josm/util' import layers from 'josm/layers' import {MenuBar} from 'josm/ui/menu' const josm = {} export default josm /** * Replies the current JOSM version string. * * @example * import josm from 'josm' * josm.alert(josm.version) * * @property {string} version the JOSM version * @readOnly * @static * @name version * @summary JOSM version string */ Object.defineProperty(josm, 'version', { enumerable: true, get: function () { return Version.getInstance().getVersionString() } }) /** * Replies the layers object. * * @example * import josm from 'josm' * josm.alert('num layers: ' + josm.layers.length) * * // name of first layer * josm.alert('num layers: ' + josm.layers.get(0).name) * * @readOnly * @name layers * @static * @property {module:josm/layers} layers the layers object * @summary accessor for JOSM layers */ Object.defineProperty(josm, 'layers', { enumerable: true, get: function () { return layers } }) /** * Displays an alert window with a message * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;alert(message)&lt;/code&gt;&lt;dt&gt; * &lt;dd class=\"param-desc\"&gt;Displays an information message with an OK button.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;alert(message, ?options)&lt;/code&gt;&lt;dt&gt; * &lt;dd class=\"param-desc\"&gt;Displays a message. The look and feel of the alert window depends on * the &lt;var&gt;options&lt;/var&gt;. The following options are supported: * &lt;dl&gt; * &lt;dt&gt;&lt;code&gt;title&lt;/code&gt;:string&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;(optional) the window title. A string is expected. Empty string * if missing.&lt;/dt&gt; * * &lt;dt class=\"param-desc\"&gt;&lt;code&gt;messageType&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;(optional) the message type. Use one of the following values: * &lt;ul&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.INFORMATION_MESSAGE, * \"info\",\"information\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.ERROR_MESSAGE, * \"error\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.WARNING_MESSAGE, * \"warning\", \"warn\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.QUESTION_MESSAGE, * \"question\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.PLAIN_MESSAGE, * \"plain\"&lt;/li&gt; * &lt;/ul&gt; * Default value is * {@class javax.swing.JOptionPane}.INFORMATION_MESSAGE. * String values are not case sensitive and leading and * trailing white space is removed. * &lt;/dd&gt; * &lt;/dl&gt; * &lt;/dd&gt; * &lt;/dl&gt; * * @example * import josm from 'josm' * * // display an information alert * josm.alert('Hello World!') * * // display an error alert * josm.alert('Got an error', { * title: 'Error Alert', * messageType: 'error' * }) * * @summary display a message * @param {string} message the message * @function * @static */ josm.alert = function () { const map = { information: JOptionPane.INFORMATION_MESSAGE, info: JOptionPane.INFORMATION_MESSAGE, error: JOptionPane.ERROR_MESSAGE, warning: JOptionPane.WARNING_MESSAGE, warn: JOptionPane.INFORMATION_MESSAGE, question: JOptionPane.QUESTION_MESSAGE, plain: JOptionPane.PLAIN_MESSAGE } function titleFromOptions (options) { return util.isString(options.title) ? options.title : '' } function messageTypeFromOptions (options) { if (util.isNumber(options.messageType)) { const mt = options.messageType for (const key in map) { if (!util.hasProp(map, key)) continue if (mt === map[key]) return mt } return JOptionPane.INFORMATION_MESSAGE } else if (util.isString(options.messageType)) { const opt = util.trim(options.messageType).toLowerCase() const ret = map[opt] return ret !== undefined ? ret : JOptionPane.INFORMATION_MESSAGE } return JOptionPane.INFORMATION_MESSAGE } switch (arguments.length) { case 0: return case 1: HelpAwareOptionPane.showOptionDialog(MainApplication.getMainFrame(), arguments[0], '', JOptionPane.INFORMATION_MESSAGE, null) return default: { if (typeof arguments[1] !== 'object') { HelpAwareOptionPane.showOptionDialog(MainApplication.getMainFrame(), arguments[0], '', JOptionPane.INFORMATION_MESSAGE, null) return } const title = titleFromOptions(arguments[1]) const messageType = messageTypeFromOptions(arguments[1]) HelpAwareOptionPane.showOptionDialog(MainApplication.getMainFrame(), arguments[0], title, messageType, null) } } } /** * Opens one or more files in JOSM. * * Accepts a variable number of files. Each argument is either a string * (a file name) or a {@class java.io.File}. * * Creates and opens layers in JOSM, depending on the kind of file opened: * * &lt;ul&gt; * &lt;li&gt;creates a data layer for data files&lt;/li&gt; * &lt;li&gt;creates a gpx layer for gpx files&lt;/li&gt; * &lt;li&gt;creates an image layer for a directory with images&lt;/li&gt; * &lt;li&gt;etc.&lt;/li&gt; * &lt;/ul&gt; * * @example * import josm from 'josm' * * // open a data file in a new data layer * josm.open('/my/data/file.osm') * * @summary Opens one or more files in JOSM * @param {...(java.io.File | string)} files files to open * @function * @static */ josm.open = function () { const OpenFileAction = Java.type('org.openstreetmap.josm.actions.OpenFileAction') const File = Java.type('java.io.File') const files = [] for (let i = 0; i &lt; arguments.length; i++) { const file = arguments[i] if (util.isNothing(file)) { continue } else if (util.isString(file)) { files.push(new File(file)) } else if (file instanceof File) { files.push(file) } else { util.assert(false, 'expected java.io.File or string, got {0}', file) } } // openFiles is async OpenFileAction.openFiles(files) } /** * Replies the global command history. * * * Use this object to undo/redo commands, or to clear the command * history. * * @example * import josm from 'josm' * * // undoes the last command * josm.commands.undo() * * // redoes two commands * josm.commands.redo(2) * * @readOnly * @name commands * @property {module:josm/command.CommandHistory} commands * @summary the global command history * @static */ const { CommandHistory } = require('josm/command') Object.defineProperty(josm, 'commands', { enumerable: true, value: CommandHistory }) /** * Replies an accessor for JOSMs menu bar. * * Use this object to inspect or modify the menu bar, i.e. to add additional * menu items. * * @readOnly * @property {module:josm/ui/menu~MenuBar} menu accessor for JOSMs menu bar * @name menu * @static * @summary Replies an accessor for JOSMs menu bar. */ Object.defineProperty(josm, 'menu', { enumerable: true, value: MenuBar }) Ã— Search results Close "},"josm_api.mjs.html":{"id":"josm_api.mjs.html","title":"Source: josm/api.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/api.mjs /** * This module provides functions to retrieve data from and upload data * to an OSM server. * * @example * import {Api, ChangesetApi, ApiConfig} from 'josm/api' * * @module josm/api */ /* global Java */ const URL = Java.type('java.net.URL') const OsmApi = Java.type('org.openstreetmap.josm.io.OsmApi') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') const PrimitiveId = Java.type('org.openstreetmap.josm.data.osm.PrimitiveId') const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') const NullProgressMonitor = Java.type('org.openstreetmap.josm.gui.progress.NullProgressMonitor') const OsmServerChangesetReader = Java.type('org.openstreetmap.josm.io.OsmServerChangesetReader') const OsmServerObjectReader = Java.type('org.openstreetmap.josm.io.OsmServerObjectReader') const OsmServerBackreferenceReader = Java.type('org.openstreetmap.josm.io.OsmServerBackreferenceReader') const Preferences = Java.type('org.openstreetmap.josm.data.Preferences') const Bounds = Java.type('org.openstreetmap.josm.data.Bounds') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') import * as util from 'josm/util' /** * Creates a {@class org.openstreetmap.josm.data.coor.LatLon} from a * javascript object. * * @example * import { buildLatLon } from 'josm/api' * const pos = buildLatLon({lat: 1, lon: 2}); * * @param {object} obj a javascript object with two number properties * &lt;code&gt;lat:&lt;/code&gt; and &lt;code&gt;lon:&lt;/code&gt; * @name buildLatLon * @static * @returns {org.openstreetmap.josm.data.coor.LatLon} * @summary Create a {@class org.openstreetmap.josm.data.coor.LatLon} * from a javascript object. * @function */ export function buildLatLon(obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined'); util.assert(typeof obj === 'object', 'obj: expected an object, got {0}', obj); util.assert(util.isNumber(obj.lat), 'obj.lat: expected a number, got {0}', obj.lat); util.assert(util.isNumber(obj.lon), 'obj.lon: expected a number, got {0}', obj.lon); util.assert(LatLon.isValidLat(obj.lat), 'obj.lat: expected a valid lat in the range [-90,90], got {0}', obj.lat); util.assert(LatLon.isValidLon(obj.lon), 'obj.lon: expected a valid lon in the range [-180,180], got {0}', obj.lon); return new LatLon(obj.lat, obj.lon); } /** * Creates a {@class org.openstreetmap.josm.data.Bounds} instance from a javascript object. * * @example * import { buildBounds } from 'josm/api' * const bounds1 = buildBounds({ * minlat: 46.9479186, minlon: 7.4619484, * maxlat: 46.9497642, maxlon: 7.4660683 * }) * * const bounds2 = buildBounds({ * min: {lat: 46.9479186, lon: 7.4619484}, * max: {lat: 46.9497642, lon: 7.4660683} * }) * * @param {object} obj a javascript object * @returns {org.openstreetmap.josm.data.Bounds} the bounds * @name buildBounds * @function * @static */ export function buildBounds(obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined') util.assert(typeof obj === 'object', 'obj: expected an object, got {0}', obj) function normalizeLat(obj,name) { util.assert(util.isDef(obj[name]), '{0}: missing mandatory property', name) util.assert(util.isNumber(obj[name]), '{0}: expected a number, got {1}', name, obj[name]) util.assert(LatLon.isValidLat(obj[name]), '{0}: expected a valid lat, got {1}', name, obj[name]) return obj[name] } function normalizeLon(obj,name) { util.assert(util.isDef(obj[name]), '{0}: missing mandatory property', name) util.assert(util.isNumber(obj[name]), '{0}: expected a number, got {1}', name, obj[name]) util.assert(LatLon.isValidLon(obj[name]), '{0}: expected a valid lon, got {1}', name, obj[name]) return obj[name] } if (util.isDef(obj.minlat)) { const minlat = normalizeLat(obj.minlat) const minlon = normalizeLat(obj.minlon) const maxlat = normalizeLat(obj.maxlat) const maxlon = normalizeLat(obj.maxlon) return new Bounds(minlat, minlon, maxlat, maxlon) } else if (util.isDef(obj.min)) { const min = buildLatLon(obj.min) const max = buildLatLon(obj.max) return new Bounds(min,max) } else { util.assert(false, 'obj: expected an object {min:.., max:..} or ' + '{minlat:, maxlat:, minlon:, maxlon:}, got {0}', obj) } } /** * Provides methods to open, close, get, update, etc. changesets on the OSM * API server. * * &lt;strong&gt;Note:&lt;/strong&gt; this class doesn't provide a constructor. Methods * and properties are &lt;code&gt;static&lt;/code&gt;. * * @example * // load the changeset api * import { ChangesetApi } from 'josm/api' * * // create a new changeset on the server * const cs = ChangesetApi.open() * * @summary Provides methods to open, close, get, update, etc. changesets on the OSM * API server. * */ export class ChangesetApi { /** * Creates and opens a changeset * * &lt;ul&gt; * &lt;li&gt;&lt;code&gt;open()&lt;/code&gt; - open a new changeset with no tags&lt;/li&gt; * &lt;li&gt;&lt;code&gt;open(aChangeset)&lt;/code&gt; - open a new changeset with the tags * from &lt;code&gt;aChangeset&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;open(anObject)&lt;/code&gt; - open a new changeset with the tags * given by the properties of &lt;code&gt;anObject&lt;/code&gt;&lt;/li&gt; * &lt;/ul&gt; * * @example * import { ChangesetApi } from 'josm/api' * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // open a new changeset with no tags * const cs1 = ChangesetApi.open() * * // open a new changeset with the tags given by the supplied changeset * const cs2 = new Changeset() * cs2.put('comment', 'a test comment') * cs2 = ChangesetApi.open(cs2) * * // open a new changeset with the tags given by the object * const cs3 = ChangesetApi.open({comment: 'a test comment'}) * * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset * @param {org.openstreetmap.josm.data.osm.Changeset | object} [changeset] the changeset to open */ static open() { let cs switch (arguments.length) { case 0: cs = new Changeset() break case 1: var o = arguments[0] if (o instanceof Changeset) { cs = o } else if (typeof o === 'object') { cs = new Changeset() for (var p in o) { if (!util.hasProp(o, p)) continue var key = p var value = o[p] key = util.trim(key) value = value + '' // convert to string cs.put(key, value) } } else { util.assert(false, 'Unexpected type of argument, expected Changeset or object, ' + 'got {0}', o) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } var api = OsmApi.getOsmApi() api.openChangeset(cs, NullProgressMonitor.INSTANCE) return cs } /** * Closes a changeset * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;close(id)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;closes the changeset with the given id&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;close(aChangeset)&lt;/code&gt;&lt;dt&gt; * &lt;dd class=\"param-desc\"&gt;Xloses the changeset given by &lt;code&gt;aChangeset&lt;/code&gt;&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { ChangesetApi } from 'josm/api' * import * as util from 'josm/util' * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // closs the changeset 12345 * ChangesetApi.close(12345) * * // open a new changeset with the tags given by the supplied changeset * const cs2 = new Changeset(12345) * cs2 = ChangesetApi.close(cs2) * util.assert(cs2.closed) // the changeset is now closed * * @param {number | org.openstreetmap.josm.data.osm.Changeset} changeset the changeset to close * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset */ static close() { let cs switch (arguments.length) { case 0: util.assert(false, 'Missing arguments. Expected a changeset it or a changeset') break case 1: { const o = arguments[0] if (o instanceof Changeset) { cs = o } else if (util.isNumber(o)) { util.assert(o &gt; 0, 'Expected a positive changeset id, got {0}', o) cs = new Changeset(o) } else { util.assert(false, 'Unexpected type of argument, expected Changeset or number, ' + 'got {0}', o) } break } default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } const api = OsmApi.getOsmApi() api.closeChangeset(cs, NullProgressMonitor.INSTANCE) return cs } /** * Updates a changeset * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;update(aChangeset)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Updates the changeset &lt;code&gt;aChangeset&lt;/code&gt;&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { ChangesetApi } from 'josm/api' * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // update the comment of a changeset * const cs2 = new Changeset(12345) * cs2.put('comment', 'an updated comment') * cs2 = ChangesetApi.update(cs2) * * @param {org.openstreetmap.josm.data.osm.Changeset} changeset the changeset to update * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset */ static update() { let cs switch (arguments.length) { case 0: util.assert(false, 'Missing arguments. Expected a changeset') break case 1: { const o = arguments[0] if (o instanceof Changeset) { cs = o } else { util.assert(false, 'Unexpected type of argument, expected Changeset, got {0}', o) } break } default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } const api = OsmApi.getOsmApi() api.updateChangeset(cs, NullProgressMonitor.INSTANCE) return cs } /** * Get a changeset from the server * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature&gt;get(aChangeset)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Gets the changeset specified by &lt;code&gt;aChangeset&lt;/code&gt;. aChangset * must be an instance of &lt;code&gt;Changeset&lt;/code&gt;. * aChangeset.id &amp;gt 0 expected.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;get(id)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;gets the changeset for the id. id must be a number &amp;gt 0.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { ChangesetApi } from 'josm/api' * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // get the changeset with id 12345 * const cs1 = ChangesetApi.get(12345) * * // get the changeset with id 12345 * lets cs2 = new Changeset(12345) * cs2 = ChangesetApi.get(cs2) * * @param {number|org.openstreetmap.josm.data.osm.Changeset} changeset the changeset to get * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset */ static get() { let cs switch (arguments.length) { case 0: util.assert(false, 'Missing arguments. Expected a changeset id or a changeset') break case 1: { const o = arguments[0] if (o instanceof Changeset) { cs = o } else if (util.isNumber(o)) { util.assert(o &gt; 0, 'Expected a positive changeset id, got {0}', o) cs = new Changeset(o) } else { util.assert(false, 'Unexpected type of argument, expected Changeset or number, ' + 'got {0}', o) } break } default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } const reader = new OsmServerChangesetReader() cs = reader.readChangeset(cs.id, NullProgressMonitor.INSTANCE) return cs } } /** * Collection of static methods to download objects from and upload objects * to the OSM server. * * &lt;strong&gt;Note:&lt;/strong&gt; this class doesn't provide a constructor. * Methods and properties are 'static'. * * @example * // load the api * import { Api } from 'josm/api' * * // download node 12345 * const ds = Api.downloadObject(12345, 'node') * * @class * @summary Collection of static methods to download objects from and upload objects * to the OSM server * @name Api */ export class Api { #normalizeType (type) { util.assert(util.isSomething(type), 'type must not be null or undefined') if (util.isString(type)) { try { type = OsmPrimitiveType.fromApiTypeName(type) } catch (e) { util.assert(false, 'Invalid primitive type, got \\'\\'{0}\\'\\'', type) } } else if (type instanceof OsmPrimitiveType) { if (![OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, OsmPrimitiveType.RELATION].contains(type)) { util.assert(false, 'Invalid primitive type, got {0}', type) } } else { util.assert(false, 'Invalid primitive type, got {0}', type) } return type } #normalizeId (id) { util.assert(util.isSomething(id), 'id must not be null or nothing') util.assert(util.isNumber(id), 'Expected a number as id, got {0}', id) util.assert(id &gt; 0, 'Expected a positive number as id, got {0}', id) return id } #primitiveIdFromObject(o) { util.assert(util.hasProp(o, 'id'), 'Mandatory property \\'\\'id\\'\\' is missing in object {0}', o) util.assert(util.hasProp(o, 'type'), 'Mandatory property \\'\\'type\\'\\' is missing in object {0}', o) return new SimplePrimitiveId(normalizeId(o.id), normalizeType(o.type)) } #downloadObject1() { let id const o = arguments[0] util.assert(util.isSomething(o), 'Argument 0: must not be null or undefined') if (o instanceof PrimitiveId) { id = o } else if (typeof o === 'object') { id = this.#primitiveIdFromObject(o) } else { util.assert(false, 'Argument 0: unexpected type, got {0}', o) } var reader = new OsmServerObjectReader(id, false) var ds = reader.parseOsm(null /* null progress monitor */) return ds } #optionFull(options) { if (!util.hasProp(options, 'full')) return undefined var o = options.full if (typeof o === 'boolean') return o util.assert('Expected a boolean value for option \\'\\'full\\'\\', got {0}', o) } #optionVersion(options) { if (!util.hasProp(options, 'version')) return undefined var o = options.version util.assert(util.isNumber(o), 'Expected a number for option \\'\\'version\\'\\', got {0}', o) util.assert(o &gt; 0, 'Expected a number &gt; 0 for option \\'\\'version\\'\\', got {0}', o) return o } #downloadObject2 () { let self = this function parseOptions (arg) { const options = { full: undefined, version: undefined } if (!(typeof arg === 'object')) { return options } options.full = self.#optionFull(arg) options.version = self.#optionVersion(arg) return options } let id let options = { full: undefined, version: undefined } if (util.isNumber(arguments[0])) { id = this.#normalizeId(arguments[0]) var type = this.#normalizeType(arguments[1]) id = new SimplePrimitiveId(id, type) } else if (arguments[0] instanceof PrimitiveId) { id = arguments[0] options = parseOptions(arguments[1]) } else if (typeof arguments[0] === 'object') { id = this.#primitiveIdFromObject(arguments[0]) options = parseOptions(arguments[1]) } else { util.assert(false, 'Unsupported types of arguments') } let reader if (util.isDef(options.version)) { reader = new OsmServerObjectReader(id, options.version) } else { reader = new OsmServerObjectReader(id, !!options.full) } var ds = reader.parseOsm(null /* null progress monitor */) return ds } #downloadObject3 () { const options = { full: undefined, version: undefined } let n = this.#normalizeId(arguments[0]) let type = this.#normalizeType(arguments[1]) let id = new SimplePrimitiveId(n, type) util.assert(typeof arguments[2] === 'object', 'Expected an object with named parameters, got {0}', arguments[2]) options.full = optionFull(arguments[2]) options.version = optionVersion(arguments[2]) let reader if (util.isDef(options.version)) { reader = new OsmServerObjectReader(id, options.version) } else { reader = new OsmServerObjectReader(id, !!options.full) } var ds = reader.parseOsm(null /* null progress monitor */) return ds } /** * Downloads an object from the server. * * There are multiple options to specify what object to download. * In addition, the function accepts a set of optional named parameters * as last argument. * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;downloadObject(id, type, ?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;id&lt;/code&gt; is the global numeric id. * &lt;code&gt;type&lt;/code&gt; is either one of the strings 'node', 'way', * or 'relation', or one of the enumeration OsmPrimitiveType.NODE, * OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION * &lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;downloadObject(id, ?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;id&lt;/code&gt; is a &lt;code&gt;PrimitiveId&lt;/code&gt; or an object * with the (mandatory) properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, * i.e. an object &lt;code&gt;{id: ..., type: ...}&lt;/code&gt;. * &lt;code&gt;id&lt;/code&gt; is again a number, &lt;code&gt;type&lt;/code&gt; is again either one * of the strings 'node', 'way', or 'relation', or one of the * enumeration OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, * or OsmPrimitiveType.RELATION. * &lt;/dd&gt; * &lt;/dl&gt; * * In both cases, &lt;code&gt;?options&lt;/code&gt; is an (optional) object with the * following two (optional) properties: * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;full&lt;/code&gt;: boolean&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;If &lt;code&gt;true&lt;/code&gt;, the object and its immediate children are * downloaded, i.e. the nodes of a way and * the relation members of a relation. Default if missing is * &lt;code&gt;false&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;version&lt;/code&gt;: number&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;If present, the specified version of the object is downloaded. * If missing, the current version is downloaded. If present, the * option &lt;code&gt;full&lt;/code&gt; is ignored.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { Api } from 'josm/api' * const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') * const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') * * // download the node with id 12345 * const ds1 = Api.downloadObject(12345, 'node') * * // download the node with id 12345 * const ds2 = Api.downloadObject({id: 12345, type: 'node'}) * * // download the full relation (including its members) with id 12345 * const id = new SimplePrimitiveId(12345, OsmPrimitiveType.RELATION) * const ds3 = Api.downloadObject(id, {full: true}) * * // download version 5 of the full way 12345 (including its nodes) * const ds4 = Api.downloadObject(12345, OsmPrimitiveType.WAY, {version: 5}) * * @returns {org.openstreetmap.josm.data.osm.DataSet} the downloaded primitives * @param args see description and examples */ static downloadObject() { switch (arguments.length) { case 0: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) break case 1: return downloadObject1.apply(this, arguments) case 2: return downloadObject2.apply(this, arguments) case 3: return downloadObject3.apply(this, arguments) default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } } #downloadReferrer1 () { let id const o = arguments[0] util.assert(util.isSomething(o), 'Argument 0: must not be null or undefined') if (o instanceof PrimitiveId) { id = o } else if (typeof o === 'object') { id = this.#primitiveIdFromObject(o) } else { util.assert(false, 'Argument 0: unexpected type, got {0}', o) } const reader = new OsmServerBackreferenceReader(id.getUniqueId(), id.getType()) const ds = reader.parseOsm(NullProgressMonitor.INSTANCE) return ds } #downloadReferrer2 () { let id let type const options = { full: undefined } if (util.isNumber(arguments[0])) { id = this.#normalizeId(arguments[0]) type = this.#normalizeType(arguments[1]) id = new SimplePrimitiveId(id, type) } else if (arguments[0] instanceof PrimitiveId) { id = arguments[0] const o = arguments[1] if (util.isSomething(o)) { util.assert(typeof o === 'object', 'Expected an object with named parameters, got {0}', o) options.full = optionFull(o) } } else if (typeof arguments[0] === 'object') { id = this.#primitiveIdFromObject(arguments[0]) const o = arguments[1] if (util.isSomething(o)) { util.assert(typeof o === 'object', 'Expected an object with named parameters, got {0}', o) options.full = optionFull(o) } } else { util.assert(false, 'Unsupported types of arguments') } const reader = new OsmServerBackreferenceReader(id.getUniqueId(), id.getType()) if (options.full) { reader.setReadFull(true) } const ds = reader.parseOsm(NullProgressMonitor.INSTANCE) return ds } #downloadReferrer3 () { const options = { full: undefined } const n = this.#normalizeId(arguments[0]) const type = this.#normalizeType(arguments[1]) const id = new SimplePrimitiveId(n, type) util.assert(typeof arguments[2] === 'object', 'Expected an object with named parameters, got {0}', arguments[2]) options.full = optionFull(arguments[2]) const reader = new OsmServerBackreferenceReader(id.getUniqueId(), id.getType()) if (options.full) { reader.setReadFull(true) } const ds = reader.parseOsm(NullProgressMonitor.INSTANCE) return ds } /** * Downloads the objects &lt;em&gt;referring&lt;/em&gt; to another object from * the server. * * Downloads primitives from the OSM server which * refer to a specific primitive. Given a node, the referring ways and * relations are downloaded. Given a way or a relation, only referring * relations are downloaded. * * The default behaviour is to reply proxy objects only. * * If you set the option &lt;code&gt;{full: true}&lt;/code&gt;, every referring object * is downloaded in full. * * There are multiple options to specify what referrers to download. * In addition, the function accepts a set of optional named parameters as * last argument. * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;downloadReferrer(id, type, ?options) * &lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;id&lt;/code&gt; is the global numeric id. * &lt;code&gt;type&lt;/code&gt; is either one of the strings 'node', 'way', or * 'relation', or one of the enumeration * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, * or {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION. * &lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;downloadReferrer(id, ?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;id&lt;/code&gt; is a &lt;code&gt;PrimitiveId&lt;/code&gt; or an object * with the (mandatory) properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, * i.e. an object &lt;code&gt;{id: ..., type: ...}&lt;/code&gt;. * &lt;code&gt;id&lt;/code&gt; is again a number, &lt;code&gt;type&lt;/code&gt; is again either one * of the strings 'node', 'way', or 'relation', or one of the * enumeration * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, * or {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION. * &lt;/dd&gt; * &lt;/dl&gt; * * In both cases, &lt;code&gt;?options&lt;/code&gt; is an (optional) object with the * following (optional) property: * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;full&lt;/code&gt;:boolean&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;If &lt;code&gt;true&lt;/code&gt;, the the &lt;strong&gt;full&lt;/strong&gt; objects are * retrieved using multi-gets. If missing or &lt;code&gt;false&lt;/code&gt;, * only proxy objects are downloaded. Default: false&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { Api } from 'josm/api' * import { NodeBuilder } from 'josm/builder' * const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') * const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') * * // download the objects referring to the node with id 12345 * const ds1 = Api.downloadReferrer(12345, 'node') * * // download the objects referring to the node with id 12345 * const ds2 = Api.downloadReferrer({id: 12345, type: 'node'}) * * // download the relations referring to the relation with id 12345. * // Referring relations are downloaded in full. * const id = new SimplePrimitiveId(12345, OsmPrimitiveType.RELATION) * const ds3 = Api.downloadReferrer(id, { full: true }) * * // create the global node 12345 ... * const node = NodeBuilder.create(12345) * // ... and downloads its referrers in full * const ds = Api.downloadReferrer(node, { full: true }) * * @returns {org.openstreetmap.josm.data.osm.DataSet} the downloaded primitives * @param args see description and examples */ static downloadReferrer() { switch (arguments.length) { case 0: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) break case 1: return downloadReferrer1.apply(this, arguments) case 2: return downloadReferrer2.apply(this, arguments) case 3: return downloadReferrer3.apply(this, arguments) default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } } /** * Downloads the objects within a bounding box. * * @example * import { Api } from 'josm/api' * const ds1 = Api.downloadArea(new Bounds( * new LatLon(46.9479186,7.4619484), // min * new LatLon(46.9497642, 7.4660683) // max * )) * * const ds2 = Api.downloadArea({ * min: {lat: 46.9479186, lon: 7.4619484}, * max: {lat: 46.9497642, lon: 7.4660683} * }) * * @returns {org.openstreetmap.josm.data.osm.DataSet} the downloaded primitives * @param {org.openstreetmap.josm.data.Bounds|object} bounds the bounding box */ static downloadArea() { const BoundingBoxDownloader = Java.type('org.openstreetmap.josm.io.BoundingBoxDownloader') const NullProgressMonitor = Java.type('org.openstreetmap.josm.gui.progress.NullProgressMonitor') const Bounds = Java.type('org.openstreetmap.josm.data.Bounds') util.assert(arguments.length === 1, 'Expected 1 argument, got {0}', arguments.length) let bounds = arguments[0] util.assert(util.isSomething(bounds), 'bounds: must not be null or undefined') if (bounds instanceof Bounds) { // do nothing } else if (typeof bounds === 'object') { bounds = buildBounds(bounds) // convert to bounds } else { util.assert(false, 'expected an instance of Bounds or an object, got {0}', bounds) } const downloader = new BoundingBoxDownloader(bounds) return downloader.parseOsm(NullProgressMonitor.INSTANCE) } /** * Uploads objects to the server. * * You can submit data either as * {@class org.openstreetmap.josm.data.osm.DataSet}, * {@class org.openstreetmap.josm.data.APIDataSet}, javascript array of * {@class org.openstreetmap.josm.data.osm.OsmPrimitive}s or * a {@class java.util.Collection} of * {@class org.openstreetmap.josm.data.osm.OsmPrimitive}s. * * This method supports the same upload strategy as the JOSM upload dialog. * Supply the named parameter &lt;code&gt;{strategy: ...}&lt;/code&gt; to choose the * strategy. * * &lt;p class='documentation-warning'&gt; * Be careful when uploading data to the OSM server! Do not upload copyright- * protected or test data. * &lt;/p&gt; * * * The method takes care to update the primitives in the uploaded data when * the upload succeeds. For instance, uploaded new primitives become global * objects and get assigned their new id and version, successfully deleted * objects become invisible, etc. * * Even if the entire upload of a dataset fails, a subset therefore may * have been uploaded successfully. In order to keep track, which pritives * have been uploaded successfully in case of an error, the method replies a * collection of the successfully uploaded objects. * &lt;p&gt; * &lt;strong&gt;Named options&lt;/strong&gt; * &lt;/p&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;strategy: string| * {@class org.openstreetmap.josm.io.UploadStrategy}&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Indicates how the data is uploaded. Either one of the strings * &lt;ul&gt; * &lt;li&gt;individualobjects&lt;/li&gt; * &lt;li&gt;chunked&lt;/li&gt; * &lt;li&gt;singlerequest&lt;/li&gt; * &lt;/ul&gt; * or one of the enumeration values in * {@class org.openstreetmap.josm.io.UploadStrategy}. * Default falue: UploadStrategy.DEFAULT_UPLOAD_STRATEGY * &lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;changeset: * number|{@class org.openstreetmap.josm.data.osm.Changeset}&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;The changeset to which the data is uploaded. Either a number * (the changeset id) or a * {@class org.openstreetmap.josm.data.osm.Changeset} instance. * Default: creates a new changeset.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;chunkSize: number&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;The size of an upload chunk, if the data is uploaded with the * upload strategy * {@class org.openstreetmap.josm.io.UploadStrategy}.CHUNKED_DATASET_STRATEGY.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;closeChangeset: boolean&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;If true, closes the changeset after the upload. Default: true&lt;/dd&gt; * &lt;/dl&gt; * * @example * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * import { WayBuilder } from 'josm/builder' * import { Api } from 'josm/api' * const ds = new DataSet() * WayBuilder * .forDataSet(ds) * .withNodes( * ds.nodeBuilder.withTags({name: 'node1'}).create(), * ds.nodeBuilder.withTags({name: 'node2'}.create() * ) * .withTags({name: 'way1'}) * .create() * * // uploads the data in a new changeset in one chunk * const processed = Api.upload(ds, 'just testing') * * @param {org.openstreetmap.josm.data.osm.DataSet| * org.openstreetmap.josm.data.APIDataSet|array|java.util.Collection} data the data to upload * @param {string} comment the upload comment * @param {object} [options] various options (see above) * @returns {java.util.Collection} */ static upload(data, comment, options) { const UploadStrategy = Java.type('org.openstreetmap.josm.io.UploadStrategy') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') const APIDataSet = Java.type('org.openstreetmap.josm.data.APIDataSet') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const UploadStrategySpecification = Java.type('org.openstreetmap.josm.io.UploadStrategySpecification') const Collection = Java.type('java.util.Collection') const OsmServerWriter = Java.type('org.openstreetmap.josm.io.OsmServerWriter') comment = comment || '' comment = String(comment) util.assertSomething(data, 'data: must not be null or undefined') options = options || {} util.assert(typeof options === 'object', 'options: expected an object with named arguments, got {0}', options) function normalizeChunkSize (size) { util.assert(util.isNumber(size), 'chunksize: expected a number, got {0}', size) util.assert(size &gt;= -1, 'chunksize: expected -1 or a number &gt; 0, got {0]', size) return size } function normalizeChangeset (changeset) { if (util.isNothing(changeset)) { return new Changeset() } else if (util.isNumber(changeset)) { util.assert(changeset &gt; 0, 'changeset: expected a changeset id &gt; 0, got {0}', changeset) return new Changeset(changeset) } else if (changeset instanceof Changeset) { return changeset } else { util.assert(false, 'changeset: unexpected value, got {0}', changeset) } } function uploadSpecFromOptions (options) { let strategy = options.strategy || UploadStrategy.DEFAULT_UPLOAD_STRATEGY strategy = UploadStrategy.from(strategy) let chunkSize = options.chunkSize || UploadStrategySpecification.UNSPECIFIED_CHUNK_SIZE chunkSize = normalizeChunkSize(chunkSize) let closeChangeset = util.isDef(options.closeChangeset) ? options.closeChangeset : true closeChangeset = Boolean(closeChangeset) const spec = new UploadStrategySpecification() spec.setStrategy(strategy) spec.setChunkSize(chunkSize) spec.setCloseChangesetAfterUpload(closeChangeset) return spec } let apiDataSet if (data instanceof DataSet) { apiDataSet = new APIDataSet(data) } else if (data instanceof APIDataSet) { apiDataSet = data } else if (util.isArray(data)) { apiDataSet = new APIDataSet(data) } else if (data instanceof Collection) { apiDataSet = new APIDataSet(data) } else { util.assert(false, 'data: unexpected type of value, got {0}', data) } if (apiDataSet.isEmpty()) return undefined apiDataSet.adjustRelationUploadOrder() const toUpload = apiDataSet.getPrimitives() let changeset = options.changeset || new Changeset() changeset = normalizeChangeset(changeset) changeset.put('comment', comment) const spec = uploadSpecFromOptions(options) const writer = new OsmServerWriter() writer.uploadOsm(spec, toUpload, changeset, null /* progress monitor */) if (spec.isCloseChangesetAfterUpload()) { ChangesetApi.close(changeset) } return writer.getProcessedPrimitives() } } /* -------------------------------------------------------------------------- */ /* ApiConfig */ /* -------------------------------------------------------------------------- */ /** * ApiConfig provides methods and properties for configuring API parameters. * * * @class * @summary ApiConfig provides methods and properties for configuring API parameters * @name ApiConfig */ export const ApiConfig = {} const DEFAULT_URL = 'http://api.openstreetmap.com/api/0.6' /** * Get or set the API server URL. * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;get&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies the currently configured server URL or undefinend, if no * server URL is configured.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;set&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Sets the current server URL. If null or undefined, removes the * current configuration. Accepts either a string or a {@class java.net.URL}. * Only accepts http or https URLs. * &lt;/dd&gt; * &lt;/dl&gt; * * @example * import { ApiConfig } from 'josm/api' * ApiConfig.serverUrl // -&gt; the current server url * * // set a new API url * ApiConfig.serverUrl = 'http://api06.dev.openstreetmap.org' * * @static * @summary Get or set the API server URL. * @property {string} serverUrl * @name serverUrl * @memberof module:josm/api~ApiConfig */ Object.defineProperty(ApiConfig, 'serverUrl', { enumerable: true, get: function () { var url = Preferences.main().get('osm-server.url', null) if (url == null) url = DEFAULT_URL return url == null ? undefined : util.trim(url) }, set: function (value) { if (util.isNothing(value)) { Preferences.main().put('osm-server.url', null) } else if (value instanceof URL) { util.assert(value.getProtocol() === 'http' || value.getProtocol() === 'https', 'url: expected a http or https URL, got {0}', value) Preferences.main().put('osm-server.url', value.toString()) } else if (util.isString(value)) { value = util.trim(value) try { const url = new URL(value) util.assert(url.getProtocol() === 'http' || url.getProtocol() === 'https', 'url: expected a http or https URL, got {0}', url.toString()) Preferences.main().put('osm-server.url', url.toString()) } catch (e) { util.assert(false, 'url: doesn\\'\\'t look like a valid URL, got {0}. Error: {1}', value, e) } } else { util.assert(false, 'Unexpected type of value, got {0}', value) } } }) /** * Get the default server URL. * * @example * import { ApiConfig } from 'josm/api' * ApiConfig.defaultServerUrl // -&gt; the default server url * * @static * @summary Get the default server URL * @name defaultServerUrl * @property {string} defaultServerUrl the default server URL * @readOnly * @memberof module:josm/api~ApiConfig */ Object.defineProperty(ApiConfig, 'defaultServerUrl', { value: DEFAULT_URL, writable: false, enumerable: true }) function normalizeAuthMethod (authMethod) { util.assert(util.isString(authMethod), 'authMethod: expected a string, got {0}', authMethod) authMethod = util.trim(authMethod).toLowerCase() util.assert(authMethod === 'basic' || authMethod === 'oauth', 'Unsupported value for authMethod, got {0}', authMethod) return authMethod } /** * Get or set the authentication method. * * JOSM uses two authentication methods: * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;basic&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Basic authentication with a username and a password&lt;/dd&gt; * &lt;dt&gt;&lt;code class='signature'&gt;oauth&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Authentication with the &lt;a href='http://oauth.net/'&gt;OAuth&lt;/a&gt; * protocol.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { ApiConfig } from 'josm/api' * ApiConfig.authMethod // -&gt; the current authentication method * * // set OAuth as authentication method * ApiConfig.authMethod = 'oauth' * * @static * @summary Get or set the authentication method. * @type string * @name authMethod * @property {string} authMethod the authentication method * @memberof module:josm/api~ApiConfig */ Object.defineProperty(ApiConfig, 'authMethod', { enumerate: true, get: function () { var authMethod = Preferences.main().get('osm-server.auth-method', 'basic') authMethod = util.trim(authMethod).toLowerCase() if (authMethod === 'basic' || authMethod === 'oauth') return authMethod // unsupported value for authMethod in the preferences. Returning // 'basic' as default. return 'basic' }, set: function (value) { value = normalizeAuthMethod(value) Preferences.main().put('osm-server.auth-method', value) } }) /** * Gets the credentials, i.e. username and password for the basic * authentication method. * * &lt;p&gt;&lt;strong&gt;Named options&lt;/strong&gt;&lt;/p&gt; * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;host:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;The host name of the API server for which credentials are retrieved. * If missing, the host name of the currently configured OSM API server * is used.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { ApiConfig } from 'josm/api' * * // get username/password for the current OSM API server * const credentials = ApiConfig.getCredentials('basic') * * @param {string} authMethod the authentication method. Either &lt;code&gt;basic&lt;/code&gt; or &lt;code&gt;oauth&lt;/code&gt; * @param {object} options (optional) additional options (see above) * @static * @summary Gets the credentials. * @returns {object} the credentials * @name getCredentials * @function * @memberof module:josm/api~ApiConfig */ ApiConfig.getCredentials = function (authMethod, options) { const CredentialsManager = Java.type('org.openstreetmap.josm.io.auth.CredentialsManager') const OsmApi = Java.type('org.openstreetmap.josm.io.OsmApi') const RequestorType = Java.type('java.net.Authenticator.RequestorType') const String = Java.type('java.lang.String') options = options || {} util.assert(typeof options === 'object', 'options: expected an object with named options, got {0}', options) function getBasicCredentials () { const cm = CredentialsManager.getInstance() if (options.host) options.host = util.trim(String(options.host)) const host = options.host ? options.host : OsmApi.getOsmApi().getHost() const pa = cm.lookup(RequestorType.SERVER, host) return pa ? { host: host, user: pa.getUserName(), password: String.valueOf(pa.getPassword()) } : { host: host, user: undefined, password: undefined } } function getOAuthCredentials () { const cm = CredentialsManager.getInstance() const token = cm.lookupOAuthAccessToken() if (token == null) return undefined return { key: token.getKey(), secret: token.getSecret() } } authMethod = normalizeAuthMethod(authMethod) if (authMethod === 'basic') return getBasicCredentials() if (authMethod === 'oauth') return getOAuthCredentials() util.assert(false, 'Unsupported authentication method, got {0}', authMethod) } function normalizeBasicCredentials (credentials) { const PasswordAuthentication = Java.type('java.net.PasswordAuthentication') if (util.isNothing(credentials)) return null util.assert(credentials instanceof PasswordAuthentication || typeof credentials === 'object', 'basic credentials: expected an object or an instance of ' + 'PasswordAuthentication , got {0}', credentials) if (credentials instanceof PasswordAuthentication) { return credentials } else { const user = String.valueOf(credentials.user || '') let password = credentials.password || null password = password ? String.valueOf(password).toCharArray() : password return new PasswordAuthentication(user, password) } } function normalizeOAuthCredentials (credentials) { const OAuthToken = Java.type('org.openstreetmap.josm.data.oauth.OAuthToken') if (util.isNothing(credentials)) return null util.assert(credentials instanceof OAuthToken || typeof credentials === 'object', 'oauth credentials: expected an object or an instance of OAuthToken, ' + 'got {0}', credentials) if (credentials instanceof OAuthToken) { return credentials } else { const key = String(credentials.key || '') const secret = String(credentials.secret || '') return new OAuthToken(key, secret) } } /** * Set the credentials, i.e. username and password for the basic * authentication method. * * Basic authentication credentials are either an instance of * java.net.PasswordAuthentication or * an object &lt;code&gt;{user: string, password: string}&lt;/code&gt;. * * OAuth authentication credentials are either an instance of * {@class org.openstreetmap.josm.data.oauth.OAuthToken} or * an object &lt;code&gt;{key: string, secret: string}&lt;/code&gt;. * &lt;p&gt; * &lt;strong&gt;Named options&lt;/strong&gt; * &lt;/p&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;host:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;The host name of the API server for which credentials are set. * If missing, the host name of the currently configured OSM API server * is used.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { ApiConfig } from 'josm/api' * * // set the credentials * ApiConfig.setCredentials('basic', { user:'test', password:'apassword' }) * * @param {string} authMethod the authentication method. Either 'basic' or 'oauth'. * @param {(object|org.openstreetmap.josm.data.oauth.OAuthToken|java.net.PasswordAuthentication)} * credentials the credentials. * @param {object} options (optional) additional options (see above) * @function * @static * @summary Set the credentials. * @returns {object} the credentials * @name setCredentials * @memberof module:josm/api~ApiConfig */ ApiConfig.setCredentials = function (authMethod, credentials, options) { const CredentialsManager = Java.type('org.openstreetmap.josm.io.auth.CredentialsManager') const RequestorType = Java.type('java.net.Authenticator.RequestorType') const OsmApi = Java.type('org.openstreetmap.josm.io.OsmApi') options = options || {} util.assert(typeof options === 'object', 'options: expected an object with named options, got {0}', options) authMethod = normalizeAuthMethod(authMethod) if (authMethod === 'basic') { credentials = normalizeBasicCredentials(credentials) util.assert(credentials != null, 'credentials: can\\'\\'t store null credentials') let host = options.host ? String(options.host) : null host = host || OsmApi.getOsmApi().getHost() const cm = CredentialsManager.getInstance() cm.store(RequestorType.SERVER, host, credentials) } else if (authMethod === 'oauth') { credentials = normalizeOAuthCredentials(credentials) util.assert(credentials != null, 'credentials: can\\'\\'t store null credentials') const cm = CredentialsManager.getInstance() cm.storeOAuthAccessToken(credentials) } else { util.assert(false, 'Unsupported authentication method, got {0}', authMethod) } } Ã— Search results Close "},"josm_builder.mjs.html":{"id":"josm_builder.mjs.html","title":"Source: josm/builder.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/builder.mjs /** * Collection of builders for creating OSM nodes, ways and relations. * * @module josm/builder * @example * // josm/builder exports the NodeBuilder, WayBuilder, and RelationBuilder * // from its sub modules * import { * NodeBuilder, * WayBuilder, * RelationBuilder * } from 'josm/builder' * * @see module:josm/builder/node * @see module:josm/builder/way * @see module:josm/builder/relation */ export * from './builder/node-builder' export * from './builder/way-builder' export * from './builder/relation-builder' Ã— Search results Close "},"josm_builder_node-builder.mjs.html":{"id":"josm_builder_node-builder.mjs.html","title":"Source: josm/builder/node-builder.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/builder/node-builder.mjs /** * @module josm/builder/node */ /* global Java */ // -- imports const Node = Java.type('org.openstreetmap.josm.data.osm.Node') const Way = Java.type('org.openstreetmap.josm.data.osm.Way') const Relation = Java.type('org.openstreetmap.josm.data.osm.Relation') const RelationMember = Java.type('org.openstreetmap.josm.data.osm.RelationMember') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const OsmPrimitive = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitive') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const List = Java.type('java.util.List') import * as util from 'josm/util' import { assertGlobalId, rememberId, rememberTags, assignTags, rememberIdFromObject, rememberVersionFromObject, checkLat, checkLon, rememberPosFromObject, rememberTagsFromObject } from './common' /** * NodeBuilder helps to create OSM nodes. * * Methods of NodeBuilder can be used in a static and in an instance context. * It isn't necessary to create an instance of NodeBuilder, unless it is * configured with a {@class org.openstreetmap.josm.data.osm.DataSet}, * to which created nodes are added. * * @example * import {NodeBuilder} from 'josm/builder' * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const ds = new DataSet() * // create a node builder without and underlying dataset ... * let nbuilder = new NodeBuilder() * // ... with an underlying dataset .... * nbuilder = new NodeBuilder(ds) * // ... or using this factory method * nbuilder = NodeBuilder.forDataSet(ds) * * // create a new local node at position (0,0) without tags * const n1 = NodeBuilder.create() * * // create a new global node at a specific position with tags * const n2 = NodeBuilder.withPosition(1,1).withTags({name: 'test'}).create(1) * * // create a new proxy for a global node * // (an 'incomplete' node in JOSM terminology) * const n3 = NodeBuilder.createProxy(2) * * @class * @summary NodeBuilder helps to create OSM nodes * @name NodeBuilder * @param {org.openstreetmap.josm.data.osm.DataSet} [ds] the dataset * which created objects are added to */ /** * Creates a new node builder. * * @param {org.openstreetmap.josm.data.osm.DataSet} ds (optional) the dataset, * to which created objects are added * @constructor * @memberOf NodeBuilder * @name NodeBuilder */ export function NodeBuilder(ds) { if (util.isSomething(ds)) { util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) this.ds = ds } } /** * Creates or configures a NodeBuilder which will add created nodes * to the dataset &lt;code&gt;ds&lt;/code&gt;. * * @example * import { NodeBuilder } from 'josm/builder' * * // create a new node builder building to a data set * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * const ds = new DataSet() * * // ... using a static method ... * const nb1 = NodeBuilder.forDataSet(ds) * // ... or the instance method * const nb2 = new NodeBuilder.forDataSet(ds) * * @returns {module:josm/builder.NodeBuilder} the node builder * @param {org.openstreetmap.josm.data.osm.DataSet} ds the dataset which * created objects are added to * @summary Creates a new NodeBuilder for a specific * {@class org.openstreetmap.josm.data.osm.DataSet}. * @function * @memberof module:josm/builder~NodeBuilder */ function forDataSet (ds) { const builder = receiver(this) util.assert(util.isSomething(ds), 'Expected a non-null defined object, got {0}', ds) util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) builder.ds = ds return builder } NodeBuilder.prototype.forDataSet = forDataSet NodeBuilder.forDataSet = forDataSet function receiver (that) { return typeof that === 'object' ? that : new NodeBuilder() } function initFromObject (builder, args) { rememberIdFromObject(builder, args) rememberVersionFromObject(builder, args) rememberPosFromObject(builder, args) rememberTagsFromObject(builder, args) } /** * Creates a new {@class org.openstreetmap.josm.data.osm.Node}. * * Can be used in an instance or in a static context. * &lt;p&gt; * &lt;strong&gt;Optional named arguments in the parameter &lt;code&gt;options&lt;/code&gt;&lt;/strong&gt; * &lt;ul&gt; * &lt;li&gt;&lt;code&gt;version&lt;/code&gt; - the version of a global node (number &gt; 0)&lt;/li&gt; * &lt;li&gt;&lt;code&gt;lat&lt;/code&gt; - a valide latitude (number in the range * [-90,90])&lt;/li&gt; * &lt;li&gt;&lt;code&gt;lon&lt;/code&gt; - a valide longitude (number in the range * [-180,180])&lt;/li&gt; * &lt;li&gt;&lt;code&gt;pos&lt;/code&gt; - either an array &lt;code&gt;[lat,lon]&lt;/code&gt;, * an object &lt;code&gt;{lat: ..., lon: ...}&lt;/code&gt;, * or an instance of {@class org.openstreetmap.josm.data.coor.LatLon}&lt;/li&gt; * &lt;li&gt;&lt;code&gt;tags&lt;/code&gt; - an object with tags. Null values and undefined * values are ignored. Any other value is converted to a string. * Leading and trailing white space in keys is removed.&lt;/li&gt; * &lt;/ul&gt; * * * @example * import { NodeBuilder } from 'josm/builder' * // create a new local node at position [0,0] * const n1 = NodeBuilder.create() * * // create a new global node at position [0,0] * const n2 = NodeBuilder.create(1111) * * // create a new global way with version 3 at a specific position * // and with some tags * const n3 = NodeBuilder.create(2222, { * version: 3, * lat: 23.45, * lon: 87.23, * tags: {amenity: 'restaurant'} * }) * * @param {number} [id] a global node id. If missing and * not set before using &lt;code&gt;withId(..)&lt;/code&gt;, creates a new local id. * @param {object} [options] additional options for creating the node * @returns {org.openstreetmap.josm.data.osm.Node} the created node * @summary Creates a new {@class org.openstreetmap.josm.data.osm.Node} * @function * @name create * @memberof module:josm/builder~NodeBuilder * @instance */ function create () { const builder = receiver(this) let arg switch (arguments.length) { case 0: break case 1: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') if (util.isNumber(arg)) { util.assert(arg &gt; 0, 'Argument 0: expected an id &gt; 0, got {0}', arg) builder.id = arg } else if (typeof arg === 'object') { initFromObject(builder, arg) } else { util.assert(false, \"Argument 0: unexpected type, got ''{0}''\", arg) } break case 2: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(arg), 'Argument 0: must be a number') util.assert(arg &gt; 0, 'Expected an id &gt; 0, got {0}', arg) builder.id = arg arg = arguments[1] if (util.isSomething(arg)) { util.assert(typeof arg === 'object', 'Argument 1: must be an object') initFromObject(builder, arg) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } let node if (util.isNumber(builder.id)) { if (util.isNumber(builder.version)) { node = new Node(builder.id, builder.version) } else { node = new Node(builder.id, 1) } const coor = new LatLon(builder.lat || 0, builder.lon || 0) node.setCoor(coor) } else { node = new Node(new LatLon(builder.lat || 0, builder.lon || 0)) } assignTags(node, builder.tags || {}) if (builder.ds) { if (builder.ds.getPrimitiveById(node) == null) { builder.ds.addPrimitive(node) } else { throw new Error( 'Failed to add primitive, primitive already included ' + 'in dataset. \\n' + 'primitive=' + node ) } } return node } NodeBuilder.create = create NodeBuilder.prototype.create = create /** * Creates a new &lt;em&gt;proxy&lt;/em&gt; * {@class org.openstreetmap.josm.data.osm.Node}. A proxy node is a node, * for which we only know its global id. In order to know more details * (position, tags, etc.), we would have to download it from the OSM server. * * * The method can be used in a static and in an instance context. * * @example * import { NodeBuilder } from 'josm/builder' * * // a new proxy node for the global node with id 1111 * const n1 = NodeBuilder.createProxy(1111) * * @param {number} id the node id (not null, number &gt; 0 expected) * @return {org.openstreetmap.josm.data.osm.Node} the new proxy node * @summary Creates a new &lt;em&gt;proxy&lt;/em&gt; {@class org.openstreetmap.josm.data.osm.Node} * @function * @name createProxy * @memberof module:josm/builder~NodeBuilder * @instance */ function createProxy (id) { const builder = receiver(this) util.assert(util.isSomething(id), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(id), 'Argument 0: expected a number, got {0}', id) util.assert(id &gt; 0, 'Argument 0: id &gt; 0 expected, got {0}', id) const node = new Node(id) if (builder.ds) builder.ds.addPrimitive(node) return node } NodeBuilder.prototype.createProxy = NodeBuilder.createProxy = createProxy /** * Declares the node position. * * The method can be used in a static and in an instance context. * * @example * import { NodeBuilder } from 'josm/builder' * * // a new global node with the global id 1111 at position (34,45) * const n1 = NodeBuilder.withPosition(34,45).create(1111) * * // a new local node at position (23.2, 87.33) * const n2 = NodeBuilder.withPosition(23.3,87.33).create() * * @param {Number} lat the latitude. A number in the range [-90..90]. * @param {Number} lon the longitude. A number in the range [-180..180]. * @returns {module:josm/builder~NodeBuilder} a node builder (for method chaining) * @summary Declares the node position. * @function * @memberof module:josm/builder~NodeBuilder * @name withPosition * @instance */ function withPosition (lat, lon) { const builder = receiver(this) util.assert(util.isNumber(lat), 'Expected a number for lat, got {0}', lat) util.assert(util.isNumber(lon), 'Expected a number for lon, got {0}', lon) util.assert(LatLon.isValidLat(lat), 'Invalid lat, got {0}', lat) util.assert(LatLon.isValidLon(lon), 'Invalid lon, got {0}', lon) builder.lat = lat builder.lon = lon return builder } NodeBuilder.prototype.withPosition = withPosition NodeBuilder.withPosition = withPosition /** * Declares the tags to be assigned to the new node. * * The method can be used in a static and in an instance context. * * @example * import { NodeBuilder } from 'josm/builder' * * // a new global node with the global id 1111 and tags name=test and * // highway=road * const n1 = NodeBuilder.withTags({'name':'test', 'highway':'road'}).global(1111) * * // a new local node with tags name=test and highway=road * const tags = { * 'name' : 'test', * 'highway' : 'road' * } * const n2 = NodeBuilder.withTags(tags).local() * * @param {object} [tags] the tags * @returns {module:josm/builder~NodeBuilder} the node builder (for method chaining) * @summary Declares the node tags. * @function * @memberof module:josm/builder~NodeBuilder * @name withTags * @instance */ function withTags (tags) { const builder = typeof this === 'object' ? this : new NodeBuilder() rememberTags(builder, tags) return builder } NodeBuilder.prototype.withTags = withTags NodeBuilder.withTags = withTags /** * Declares the global node id and the global node version. * * The method can be used in a static and in an instance context. * * @param {number} id (mandatory) the global node id. A number &gt; 0. * @param {number} version (optional) the global node version. If present, * a number &gt; 0. If missing, the version 1 is assumed. * @returns {module:josm/builder~NodeBuilder} the node builder (for method chaining) * @summary Declares the node id and version. * @function * @memberof module:josm/builder~NodeBuilder * @name withId * @instance */ function withId (id, version) { const builder = typeof this === 'object' ? this : new NodeBuilder() rememberId(builder, id, version) return builder } NodeBuilder.prototype.withId = withId NodeBuilder.withId = withId Ã— Search results Close "},"josm_builder_relation-builder.mjs.html":{"id":"josm_builder_relation-builder.mjs.html","title":"Source: josm/builder/relation-builder.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/builder/relation-builder.mjs /** * @module josm/builder/relation */ /* global Java */ // -- imports const Node = Java.type('org.openstreetmap.josm.data.osm.Node') const Way = Java.type('org.openstreetmap.josm.data.osm.Way') const Relation = Java.type('org.openstreetmap.josm.data.osm.Relation') const RelationMember = Java.type('org.openstreetmap.josm.data.osm.RelationMember') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const OsmPrimitive = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitive') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const List = Java.type('java.util.List') import * as util from 'josm/util' import { assertGlobalId, rememberId, rememberTags, assignTags, rememberIdFromObject, rememberVersionFromObject, checkLat, checkLon, rememberPosFromObject, rememberTagsFromObject } from './common' function receiver (that) { return typeof that === 'object' ? that : new RelationBuilder() } /** * RelationBuilder helps to create OSM * {@class org.openstreetmap.josm.data.osm.Relation}s. * * Methods of RelationBuilder can be used in a static and in an instance * context. * It isn't necessary to create an instance of RelationBuilder, unless it is * configured with a {@class org.openstreetmap.josm.data.osm.DataSet}, * which created ways are added to. * @example * import {RelationBuilder} from 'josm/builder' * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const ds = new DataSet() * // create a relation builder without and underlying dataset ... * let rbuilder = new RelationBuilder() * // ... with an underlying dataset ... * rbuilder = new RelationBuilder(ds) * // ... or using this factory method * rbuilder = RelationBuilder.forDataSet(ds) * * // create a new local relation * const r1 = rbuilder.create() * * // create a new global way * const r2 = rbuilder.withTags({route: 'bicycle'}).create(1111) * * // create a new proxy for a global relation * // (an 'incomplete' node in JOSM terminology) * const r3 = rbuilder.createProxy(2222) * * @class * @param {org.openstreetmap.josm.data.osm.DataSet} ds (optional) a JOSM * dataset which created ways are added to. If missing, the created ways * aren't added to a dataset. * @name RelationBuilder * @summary Helps to create {@class org.openstreetmap.josm.data.osm.Relation}s */ export function RelationBuilder(ds) { if (util.isSomething(ds)) { util.assert(ds instanceof DataSet, 'Expected a DataSet, got {0}', ds) this.ds = ds } this.members = [] } /** * Creates or configures a RelationBuilder which will add created nodes * to the dataset &lt;code&gt;ds&lt;/code&gt;. * * @example * import {RelationBuilder} = 'josm/builder' * * // create a new relation builder building to a data set * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * const ds = new DataSet() * const rb1 = RelationBuilder.forDataSet(ds) * * // configure an existing relation builder * let rb2 = new RelationBuilder() * rb2 = rb2.forDataSet(ds) * * @return {module:josm/builder.RelationBuilder} the relation builder * @summary Creates a new RelationBuilder which adds created relations to a * dataset * @param {org.openstreetmap.josm.data.osm.DataSet} ds a JOSM * dataset which created ways are added to. * @function * @name forDataSet * @memberof module:josm/builder~RelationBuilder */ function forDataSet (ds) { const builder = receiver(this) util.assert(util.isSomething(ds), 'Expected a non-null defined object, got {0}', ds) util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) builder.ds = ds return builder } RelationBuilder.prototype.forDataSet = forDataSet RelationBuilder.forDataSet = forDataSet /** * Create a RelationMember * * &lt;dl&gt; * &lt;dt&gt;member(role, obj)&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Create a relation member with role &lt;var&gt;role&lt;/var&gt; and member object * &lt;var&gt;obj&lt;/var&gt;. &lt;var&gt;role&lt;/var&gt; can be null or undefined, obj must neither * be null nor undefinde. &lt;var&gt;role&lt;/var&gt; is a string, &lt;var&gt;obj&lt;/var&gt; is an * OSM node, a way, or a relation. * &lt;/dd&gt; * &lt;dt&gt;member(obj)&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Create a relation member for the member object &lt;var&gt;obj&lt;/var&gt;. * &lt;var&gt;obj&lt;/var&gt; must neither be null nor undefinde. &lt;var&gt;obj&lt;/var&gt; is an * OSM node, a way, or a relation. The created relation member has no role. * &lt;/dd&gt; * &lt;/dl&gt; * * @example * import {RelationBuilder, NodeBuilder} from 'josm/builder' * * // create a new RelationMember with role 'house' for a new node * const m1 = RelationBuilder.member('house', NodeBuilder.create()) * // create a new RelationMember with an empty role for a new node * const m2 = RelationBuilder.member(NodeBuilder.create()) * * @static * @returns {org.openstreetmap.josm.data.osm.RelationMember} the relation member * @summary Utility function - creates a relation member * @memberof module:josm/builder~RelationBuilder * @name member * @function * @param {string} [role] the member role * @param {primitive} primitive the member primitive */ function member () { function normalizeObj (obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined') util.assert(obj instanceof OsmPrimitive, 'obj: expected an OsmPrimitive, got {0}', obj) return obj } function normalizeRole (role) { if (util.isNothing(role)) return null util.assert(util.isString(role), 'role: expected a string, got {0}', role) return role } let obj let role switch (arguments.length) { case 0: util.assert(false, 'Expected arguments (object) or (role, object), got 0 arguments') break case 1: obj = normalizeObj(arguments[0]) return new RelationMember(null /* no role */, obj) case 2: role = normalizeRole(arguments[0]) obj = normalizeObj(arguments[1]) return new RelationMember(role, obj) default: util.assert(false, 'Expected arguments (object) or (role, object), got {0} arguments', arguments.length) } } RelationBuilder.member = member /** * Declares the global relation id and the global relation version. * * The method can be used in a static and in an instance context. * * @example * import {RelationBuilder} from 'josm/builder' * // creates a global relation with id 1111 an version 22 * const r = RelationBuilder.withId(1111, 22).create() * * @param {number} id (mandatory) the global relation id. A number &amp;gt; 0. * @param {number} version (optional) the global relation version. If present, * a number &amp;gt; 0. If missing, the version 1 is assumed. * @returns {module:josm/builder~RelationBuilder} the relation builder (for method chaining) * @summary Declares the relation id and version. * @memberof module:josm/builder~RelationBuilder * @name withId * @function * @instance */ function withId (id, version) { const builder = receiver(this) rememberId(builder, id, version) return builder } RelationBuilder.prototype.withId = withId RelationBuilder.withId = withId /** * Declares the tags to be assigned to the new relation. * * The method can be used in a static and in an instance context. * * @example * import {RelationBuilder} from 'josm/builder' * // a new global relation with the global id 1111 and tags route='bicycle' * //and name='n8' * const r1 = RelationBuilder.withTags({name:'n8', route:'bicycle'}).create(1111) * * // a new local relation with tags name=test and highway=road * const tags = { * name : 'n8', * route : 'bicycle' * } * const r2 = RelationBuilder.withTags(tags).create() * * @param {object} [tags] the tags * @returns {module:josm/builder~RelationBuilder} a relation builder (for method chaining) * @summary Declares the tags to be assigned to the new relation. * @memberof module:josm/builder~RelationBuilder * @name withTags * @function * @instance */ function withTags (tags) { const builder = receiver(this) rememberTags(builder, tags) return builder } RelationBuilder.prototype.withTags = withTags RelationBuilder.withTags = withTags /** * Creates a new &lt;em&gt;proxy&lt;/em&gt; relation. A proxy relation is a relation, * for which we only know its global id. In order to know more details * (members, tags, etc.), we would have to download it from the OSM server. * * * The method can be used in a static and in an instance context. * * @example * import {RelationBuilder} from 'josm/builder' * * // a new proxy relation for the global way with id 1111 * const r1 = RelationBuilder.createProxy(1111) * * @returns {org.openstreetmap.josm.data.osm.Relation} the new proxy relation * @summary Creates a new &lt;em&gt;proxy&lt;/em&gt; relation. * @memberof module:josm/builder~RelationBuilder * @function * @name createProxy * @instance * @param {number} id the id for the proxy relation */ function createProxy (id) { const builder = receiver(this) if (util.isDef(id)) { util.assert(util.isNumber(id) &amp;&amp; id &gt; 0, 'Expected a number &gt; 0, got {0}', id) builder.id = id } util.assert(util.isNumber(builder.id), 'way id is not a number. Use .createProxy(id) or ' + '.withId(id).createProxy()') util.assert(builder.id &gt; 0, 'Expected id &gt; 0, got {0}', builder.id) const relation = new Relation(builder.id) if (builder.ds) builder.ds.addPrimitive(relation) return relation } RelationBuilder.createProxy = createProxy RelationBuilder.prototype.createProxy = createProxy /** * Declares the members of a relation. * * Accepts either a vararg list of relation members, nodes, ways or * relations, an array of relation members, nodes ways or relations, or a * Java list of members, nodes, ways or relation. * * * The method can be used in a static and in an instance context. * * @example * import {RelationBuilder, NodeBuilder} from 'josm/builder' * * const r1 = RelationBuilder.withMembers( * RelationBuilder.member('house', NodeBuilder.create()), * RelationBuilder.member('house', NodeBuilder.create()) * ).create() * * @param nodes the list of members. See description and examples. * @returns {module:josm/builder~RelationBuilder} the relation builder (for method chaining) * @summary Declares the members of a relation. * @memberof module:josm/builder~RelationBuilder * @function * @name withMembers * @instance */ function withMembers () { const builder = receiver(this) const members = [] function remember (obj) { if (util.isNothing(obj)) return if (obj instanceof OsmPrimitive) { members.push(new RelationMember(null, obj)) } else if (obj instanceof RelationMember) { members.push(obj) } else if (util.isArray(obj)) { for (let i = 0; i &lt; obj.length; i++) remember(obj[i]) } else if (obj instanceof List) { for (let it = obj.iterator(); it.hasNext();) remember(it.next()) } else { util.assert(false, \"Can''t add object ''{0}'' as relation member\", obj) } } for (let i = 0; i &lt; arguments.length; i++) { remember(arguments[i]) } builder.members = members return builder } RelationBuilder.withMembers = withMembers RelationBuilder.prototype.withMembers = withMembers function rememberMembersFromObject (builder, args) { if (!util.hasProp(args, 'members')) return const o = args.members if (!util.isSomething(o)) return util.assert(util.isArray(o) || o instanceof List, 'members: Expected an array or an instance of java.util.List, got {0}', o) builder.withMembers(o) } function initFromObject (builder, args) { rememberIdFromObject(builder, args) rememberVersionFromObject(builder, args) rememberTagsFromObject(builder, args) rememberMembersFromObject(builder, args) } /** * Creates a new relation. * * Can be used in an instance or in a static context. * * &lt;strong&gt;Optional named arguments in the parameters &lt;code&gt;args&lt;/code&gt; * &lt;/strong&gt; * &lt;ul&gt; * &lt;li&gt;&lt;var&gt;id&lt;/var&gt; - the id of a global relation (number &gt; 0)&lt;/li&gt; * &lt;li&gt;&lt;var&gt;version&lt;/var&gt; - the version of a global relation (number &gt; 0) * &lt;/li&gt; * &lt;li&gt;&lt;var&gt;members&lt;/var&gt; - an array or a list of relation members, nodes, * ways, or relation&lt;/li&gt; * &lt;li&gt;&lt;var&gt;tags&lt;/var&gt; - an object with tags. Null values and undefined * values are ignored. Any other value * is converted to a string. Leading and trailing white space in keys is * removed.&lt;/li&gt; * &lt;/ul&gt; * * * @example * import { NodeBuilder, RelationBuilder } from 'josm/builder' * const member = RelationBuilder.member * // create a new local relation * const r1 = RelationBuilder.create() * * // create a new global relation * const r2 = RelationBuilder.create(1111) * * // create a new global relation with version 3 with some tags and two * // members * const r3 = RelationBuilder.create(2222, { * version: 3, * tags: {type: 'route'}, * members: [ * member('house', NodeBuilder.create()), * member(NodeBuilder.create()) * ] * }) * * @param {number} [id] a global way id. If missing and not set * before using &lt;code&gt;withId(..)&lt;/code&gt;, creates a new local id. * @param {object} [args] additional parameters for creating the relation * @returns {org.openstreetmap.josm.data.osm.Relation} the relation * @summary Creates a new relation. * @memberof module:josm/builder~RelationBuilder * @function * @name create * @instance */ function create () { const builder = receiver(this) let arg switch (arguments.length) { case 0: break case 1: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') if (util.isNumber(arg)) { util.assert(arg &gt; 0, 'Argument 0: expected an id &gt; 0, got {0}', arg) builder.id = arg } else if (typeof arg === 'object') { initFromObject(builder, arg) } else { util.assert(false, \"Argument 0: unexpected type, got ''{0}''\", arg) } break case 2: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(arg), 'Argument 0: must be a number') util.assert(arg &gt; 0, 'Expected an id &gt; 0, got {0}', arg) builder.id = arg arg = arguments[1] if (util.isSomething(arg)) { util.assert(typeof arg === 'object', 'Argument 1: must be an object') initFromObject(builder, arg) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } let relation if (util.isNumber(builder.id)) { if (util.isNumber(builder.version)) { relation = new Relation(builder.id, builder.version) } else { relation = new Relation(builder.id, 1) } } else { relation = new Relation(0) // creates a new local reÃ¶atopm } assignTags(relation, builder.tags || {}) if (builder.members &amp;&amp; builder.members.length &gt; 0) { relation.setMembers(builder.members) } if (builder.ds) { if (builder.ds.getPrimitiveById(relation) == null) { builder.ds.addPrimitive(relation) } else { throw new Error( 'Failed to add primitive, primitive already included ' + 'in dataset. \\n' + 'primitive=' + relation ) } } return relation } RelationBuilder.create = create RelationBuilder.prototype.create = create Ã— Search results Close "},"josm_builder_way-builder.mjs.html":{"id":"josm_builder_way-builder.mjs.html","title":"Source: josm/builder/way-builder.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/builder/way-builder.mjs /** * @module josm/builder/way */ /* global Java */ // -- imports const Node = Java.type('org.openstreetmap.josm.data.osm.Node') const Way = Java.type('org.openstreetmap.josm.data.osm.Way') const Relation = Java.type('org.openstreetmap.josm.data.osm.Relation') const RelationMember = Java.type('org.openstreetmap.josm.data.osm.RelationMember') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const OsmPrimitive = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitive') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const List = Java.type('java.util.List') import * as util from 'josm/util' import { assertGlobalId, rememberId, rememberTags, assignTags, rememberIdFromObject, rememberVersionFromObject, checkLat, checkLon, rememberPosFromObject, rememberTagsFromObject } from './common' function receiver (that) { return typeof that === 'object' ? that : new WayBuilder() } /** * WayBuilder helps to create OSM * {@class org.openstreetmap.josm.data.osm.Way}s. * * Methods of WayBuilder can be used in a static and in an instance context. * It isn't necessary to create an instance of WayBuilder, unless it is * configured with a {@class org.openstreetmap.josm.data.osm.DataSet}, * to which created ways are added. * @example * import {WayBuilder} from 'josm/builder' * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const ds = new DataSet() * // create a way builder without and underlying dataset ... * let wbuilder = new WayBuilder() * // ... with an underlying dataset .... * wbuilder = new WayBuilder(ds) * // ... or using this factory method * wbuilder = WayBuilder.forDataSet(ds) * * * // create a new local way * const w1 = wbuilder.create() * * // create a new global way * const w2 = wbuilder.withTags({highway: 'residential'}).create(1111) * * // create a new proxy for a global way * // (an 'incomplete' node in JOSM terminology) * const w3 = wbuilder.createProxy(2222) * * @class * @param {org.openstreetmap.josm.data.osm.DataSet} [ds] a JOSM * dataset to which created ways are added. If missing, the created ways * aren't added to a dataset. * @summary Helps to create OSM {@class org.openstreetmap.josm.data.osm.Way}s * @name WayBuilder */ /** * Creates a new builder for OSM ways * * @return {module:josm/builder~WayBuilder} the way builder * @param {org.openstreetmap.josm.data.osm.DataSet} ds the dataset which * created objects are added to * @summary Creates a new WayBuilder with an underlying dataset. * @function * @memberof module:josm/builder~WayBuilder * @name forDataSet */ export function WayBuilder(ds) { if (util.isSomething(ds)) { util.assert(ds instanceof DataSet, 'Expected a DataSet, got {0}', ds) this.ds = ds } this.nodes = [] } /** * Creates or configures a WayBuilder which will add created nodes * to the dataset &lt;code&gt;ds&lt;/code&gt;. * * @example * import {WayBuilder} from 'josm/builder' * * // create a new way builder which builds to a data set * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * const ds = new DataSet() * let wb = WayBuilder.forDataSet(ds) * * @return {module:josm/builder~WayBuilder} the way builder * @param {org.openstreetmap.josm.data.osm.DataSet} ds the dataset to which * created objects are added * @summary Creates a new WayBuilder with an underlying dataset. * @function * @name forDataSet * @memberof module:josm/builder~WayBuilder */ function forDataSet (ds) { const builder = receiver(this) util.assert(util.isSomething(ds), 'Expected a non-null defined object, got {0}', ds) util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) builder.ds = ds return builder } WayBuilder.prototype.forDataSet = forDataSet WayBuilder.forDataSet = forDataSet /** * Declares the global way id and the global way version. * * The method can be used in a static and in an instance context. * * @example * import {WayBuilder} from 'josm/builder' * // creates a global way with id 1111 an version 22 * const way = WayBuilder.withId(1111, 22).create() * * @param {number} id (mandatory) the global way id. A number &gt; 0. * @param {number} [version] the global way version. If present, * a number &gt; 0. If missing, the version 1 is assumed. * @return {module:josm/builder~WayBuilder} the way builder (for method chaining) * @summary Declares the global way id and the global way version. * @function * @memberof module:josm/builder~WayBuilder * @name withId * @instance */ function withId (id, version) { const builder = receiver(this) rememberId(builder, id, version) return builder } WayBuilder.prototype.withId = withId WayBuilder.withId = withId /** * Declares the tags to be assigned to the new way. * * The method can be used in a static and in an instance context. * * @example * import {WayBuilder} from 'josm/builder' * // a new global way with the global id 1111 and tags name='Laubeggstrasse' * // and highway=residential * const w1 = WayBuilder.withTags({name:'Laubeggstrasse', highway:'residential'}) * .create(1111) * * // a new local way with tags name=test and highway=road * const tags = { * name : 'Laubeggstrasse', * highway : 'residential' * } * const w2 = WayBuilder.withTags(tags).create() * * @param {object} [tags] the tags * @return {module:josm/builder~WayBuilder} the way builder (for method chaining) * @summary Declares the tags to be assigned to the new way. * @function * @memberof module:josm/builder~WayBuilder * @name withTags * @instance */ function withTags (tags) { const builder = receiver(this) rememberTags(builder, tags) return builder } WayBuilder.prototype.withTags = withTags WayBuilder.withTags = withTags /** * Declares the nodes of the way. * * Accepts either a vararg list of * {@class org.openstreetmap.josm.data.osm.Node}, * an array of {@class org.openstreetmap.josm.data.osm.Node}s or a Java list * of {@class org.openstreetmap.josm.data.osm.Node}s. At least &lt;strong&gt;two * non-identical nodes&lt;/strong&gt; have to be supplied. * The same node can occure more than once in the list, but a consecutive * sequence of the same node is collapsed to one node. * * * The method can be used in a static and in an instance context. * * @example * import {WayBuilder, NodeBuilder} from 'josm/builder' * // creates a new local way with two local nodes * const way = WayBuilder.withNodes( * NodeBuilder.create(), NodeBuilder.create() * ).create() * * @param nodes the list of nodes. See description and examples. * @return {module:josm/builder~WayBuilder} the way builder (for method chaining) * @summary Declares the nodes of the way. * @function * @memberof module:josm/builder~WayBuilder * @name withNodes * @instance */ function withNodes () { const builder = receiver(this) let nodes switch (arguments.length) { case 0: return builder case 1: nodes = arguments[0] if (util.isNothing(nodes)) return builder if (nodes instanceof Node) { nodes = [nodes] } else if (util.isArray(nodes)) { // OK } else if (nodes instanceof List) { const temp = [] for (let it = nodes.iterator(); it.hasNext();) temp.push(it.next()) nodes = temp } else { util.assert(false, 'Argument 0: expected a Node or a list of nodes, got {0}', nodes) } break default: nodes = Array.prototype.slice.call(arguments, 0) break } const newnodes = [] let last for (let i = 0; i &lt; nodes.length; i++) { const n = nodes[i] if (util.isNothing(n)) continue util.assert(n instanceof Node, 'Expected instances of Node only, got {0} at index {1}', n, i) // skip sequence of identical nodes if (last &amp;&amp; last.getUniqueId() === n.getUniqueId()) continue newnodes.push(n) last = n } builder.nodes = newnodes return builder } WayBuilder.withNodes = WayBuilder.prototype.withNodes = withNodes /** * Creates a new &lt;em&gt;proxy&lt;/em&gt; way. A proxy way is a way, for which we * only know its global id. In order to know more details (nodes, tags, etc.), * we would have to download it from the OSM server. * * The method can be used in a static and in an instance context. * * @example * import {WayBuilder} from 'josm/builder' * * // a new proxy way for the global way with id 1111 * const w1 = WayBuilder.createProxy(1111) * * @return {org.openstreetmap.josm.data.osm.Way} the new proxy way * @summary Creates a new proxy way * @function * @memberof module:josm/builder~WayBuilder * @name createProxy * @instance */ function createProxy (id) { const builder = receiver(this) if (util.isDef(id)) { util.assert(util.isNumber(id) &amp;&amp; id &gt; 0, 'Expected a number &gt; 0, got {0}', id) builder.id = id } util.assert(util.isNumber(builder.id), 'way id is not a number. Use .createProxy(id) or ' + '.withId(id).createProxy()') util.assert(builder.id &gt; 0, 'Expected way id &gt; 0, got {0}', builder.id) const way = new Way(builder.id) if (builder.ds) builder.ds.addPrimitive(way) return way } WayBuilder.createProxy = WayBuilder.prototype.createProxy = createProxy function rememberNodesFromObject (builder, args) { if (!util.hasProp(args, 'nodes')) return const o = args.nodes if (!util.isSomething(o)) return util.assert(util.isArray(o) || o instanceof List, 'Expected an array or an instance of java.util.List, got {0}', o) builder.withNodes(o) } function initFromObject (builder, args) { rememberIdFromObject(builder, args) rememberVersionFromObject(builder, args) rememberTagsFromObject(builder, args) rememberNodesFromObject(builder, args) } /** * Creates a new way. * * Can be used in an instance or in a static context. * * Optional named arguments in the parameters &lt;code&gt;options&lt;/code&gt;: * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;id&lt;/code&gt;:number&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;the id of a global way (number &gt; 0)&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;version&lt;/code&gt;:number&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;the version of a global way (number &gt; 0)&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;nodes&lt;/code&gt;:array|list&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;an array or a list of nodes&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;tags&lt;/code&gt;:object&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;an object with tags. Null values and undefined values are ignored. * Any other value is converted to a string. Leading and trailing white * space in keys is removed.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import {WayBuilder, NodeBuilder} from 'josm/builder' * // create a new local way * const w1 = WayBuilder.create() * * // create a new global way * const w2 = WayBuilder.create(1111) * * // create a new global way with version 3 at a specific position and with * // some tags * const w3 = WayBuilder.create(2222, { * version: 3, * tags: {amenity: 'restaurant'}, * nodes: [ * NodeBuilder.withPosition(1,1).create(), * NodeBuilder.withPosition(2,2).create(), * NodeBuilder.withPosition(3,3).create() * ] * }) * * @param {number} [id] a global way id. If missing and not set * before using &lt;code&gt;withId(..)&lt;/code&gt;, creates a new local id. * @param {object} [options] additional parameters for creating the way * @returns {org.openstreetmap.josm.data.osm.Way} the created way * @summary Creates a new way * @function * @memberof module:josm/builder~WayBuilder * @name create * @instance */ function create () { const builder = receiver(this) let arg switch (arguments.length) { case 0: break case 1: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') if (util.isNumber(arg)) { util.assert(arg &gt; 0, 'Argument 0: expected an id &gt; 0, got {0}', arg) builder.id = arg } else if (typeof arg === 'object') { initFromObject(builder, arg) } else { util.assert(false, \"Argument 0: unexpected type, got ''{0}''\", arg) } break case 2: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(arg), 'Argument 0: must be a number') util.assert(arg &gt; 0, 'Expected an id &gt; 0, got {0}', arg) builder.id = arg arg = arguments[1] if (util.isSomething(arg)) { util.assert(typeof arg === 'object', 'Argument 1: must be an object') initFromObject(builder, arg) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } let way if (util.isNumber(builder.id)) { if (util.isNumber(builder.version)) { way = new Way(builder.id, builder.version) } else { way = new Way(builder.id, 1) } } else { way = new Way(0) // creates a new local way } assignTags(way, builder.tags || {}) if (builder.nodes &amp;&amp; builder.nodes.length &gt; 0) { way.setNodes(builder.nodes) } if (builder.ds) { if (builder.ds.getPrimitiveById(way) == null) { builder.ds.addPrimitive(way) } else { throw new Error( 'Failed to add primitive, primitive already included ' + 'in dataset. \\n' + 'primitive=' + way ) } } return way } WayBuilder.create = create WayBuilder.prototype.create = create Ã— Search results Close "},"josm_command.mjs.html":{"id":"josm_command.mjs.html","title":"Source: josm/command.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/command.mjs /** * A collection of functions to create commands which can be applied, undone * and redone on {@class org.openstreetmap.josm.gui.layer.OsmDataLayer}s. * * @module josm/command * @example * import {AddCommand} from 'josm/command' */ /* global Java */ /* global Plugin */ const AddMultiCommand = Plugin.type('org.openstreetmap.josm.plugins.scripting.js.api.AddMultiCommand') const ChangeMultiCommand = Plugin.type('org.openstreetmap.josm.plugins.scripting.js.api.ChangeMultiCommand') const Change = Plugin.type('org.openstreetmap.josm.plugins.scripting.js.api.Change') import * as util from 'josm/util' import layers from 'josm/layers' const OsmPrimitive = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitive') const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') const Layer = Java.type('org.openstreetmap.josm.gui.layer.Layer') const UndoRedoHandler = Java.type('org.openstreetmap.josm.data.UndoRedoHandler') const CombineWayAction = Java.type('org.openstreetmap.josm.actions.CombineWayAction') const JavaDeleteCommand = Java.type('org.openstreetmap.josm.command.DeleteCommand') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const RelationMember = Java.type('org.openstreetmap.josm.data.osm.RelationMember') const ArrayList = Java.type('java.util.ArrayList') const Map = Java.type('java.util.Map') const HashMap = Java.type('java.util.HashMap') const HashSet = Java.type('java.util.HashSet') const Collection = Java.type('java.util.Collection') const Command = Java.type('org.openstreetmap.josm.command.Command') const System = Java.type('java.lang.System') function checkAndFlatten (primitives) { const ret = new HashSet() function visit (value) { if (util.isNothing(value)) return if (util.isCollection(value)) { util.each(value, visit) } else if (value instanceof OsmPrimitive) { ret.add(value) } else { util.assert(false, 'Unexpected object to add as OSM primitive, got {0}', value) } } visit(primitives) return ret } function applyTo (layer) { util.assert(util.isSomething(layer), 'layer: must not be null or undefined') util.assert(layer instanceof OsmDataLayer, 'layer: expected OsmDataLayer, got {0}', layer) const cmd = this.createJOSMCommand(layer) try { layer.getDataSet().beginUpdate() UndoRedoHandler.getInstance().add(cmd) } finally { layer.getDataSet().endUpdate() } } function toArray (collection) { if (util.isArray(collection)) return collection if (collection instanceof Collection) { const ret = [] for (const it = collection.iterator(); it.hasNext();) ret.push(it.next()) return ret } } /** * A command to add a collection of objects to a data layer. * * @class * @name AddCommand * @summary A command to add a collection of objects to a data layer * @param { java.util.Collection| array } objs the objects to add */ export function AddCommand(objs) { util.assert(objs, 'objs: mandatory parameter missing') this._objs = toArray(checkAndFlatten(objs)) } /** * Applies the command to a layer. * * @function * @summary Applies the command to a layer. * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @instance * @memberof module:josm/command.AddCommand * @name applyTo */ AddCommand.prototype.applyTo = applyTo /** * Creates the internal JOSM command for this command * * @function * @summary Creates the internal JOSM command for this command * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @returns {org.openstreetmap.josm.command.Command} the command * @memberof module:josm/command.AddCommand * @name createJOSMCommand * @instance */ AddCommand.prototype.createJOSMCommand = function (layer) { util.assert(util.isSomething(layer), 'layer: must not be null or undefined') util.assert(layer instanceof OsmDataLayer, 'layer: expected OsmDataLayer, got {0}', layer) const list = new ArrayList() for (let i = 0; i &lt; this._objs.length; i++) { const o = this._objs[i] list.add(o) } return new AddMultiCommand(layer, list) } /** * Creates a command to add a collection of objects to a data layer. * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;add(obj, obj, ...)&lt;/code&gt; &lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;obj&lt;/code&gt; are {@class org.openstreetmap.josm.data.osm.Node}s, * {@class org.openstreetmap.josm.data.osm.Way}s, or * {@class org.openstreetmap.josm.data.osm.Relations}s. Or javascript array * or Java collections thereof.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import {add} from 'josm/command' * import layers from 'josm/layer' * import {NodeBuilder} from 'josm/builder' * const layer = layers.get('Data Layer 1') * * // add two nodes * add(NodeBuilder.create(), NodeBuilder.create()).applyTo(layer) * * * @function * @summary Creates a command to add a collection of objects * @param {...(primitive | primitive[] | java.lang.Collection )} primitives the primitives to add * @name add * @static * @returns {module:josm/command.AddCommand} the command object */ export function add(){ const objs = checkAndFlatten(arguments) return new AddCommand(objs) } /** * A command to delete a collection of objects in a data layer. * * @class * @param {java.util.Collection|array} objs the objects to add * @summary A command to delete a collection of objects in a data layer. * @param {java.util.Collection|array} objs the objects to add */ export function DeleteCommand(objs) { this._objs = checkAndFlatten(objs) } /** * Applies the command to a layer. * * @function * @summary Applies the command to a layer. * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @memberof module:josm/command.DeleteCommand * @instance * @name applyTo */ DeleteCommand.prototype.applyTo = applyTo /** * Creates the internal JOSM command for this command * * @function * @summary Creates the internal JOSM command for this command * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @returns {org.openstreetmap.josm.command.Command} the command object * @instance * @name createJOSMCommand * @memberof module:josm/command.DeleteCommand */ DeleteCommand.prototype.createJOSMCommand = function (layer) { util.assert(util.isSomething(layer), 'layer: must not be null or undefined') util.assert(layer instanceof OsmDataLayer, 'layer: expected OsmDataLayer, got {0}', layer) return JavaDeleteCommand.delete(this._objs, true /* alsoDeleteNodesInWay */, true /* silent */) } /** * Creates a command to delete a collection of objects in a data layer. * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;delete(obj,obj,..., ?options)&lt;/code&gt; &lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;obj&lt;/code&gt; are {@class org.openstreetmap.josm.data.osm.Node}s, * {@class org.openstreetmap.josm.data.osm.Way}s, or * {@class org.openstreetmap.josm.data.osm.Relations}s. Or javascript array * or Java collections thereof.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import {buildDeleteCommand} from 'josm/command' * import layers from 'josm/layer' * import {NodeBuilder} from 'josm/builder' * const layer = layers.get('Data Layer 1') * * // delete two nodes * buildDeleteCommand(NodeBuilder.create(),NodeBuilder.create()).applyTo(layer) * * * @function * @summary Creates a command to delete a collection of objects * @param {...(primitive | primitive[] | java.lang.Collection )} primitives the primitives to delete * @static * @name delete * @returns {module:josm/command.DeleteCommand} the command object */ export function buildDeleteCommand() { return new DeleteCommand(checkAndFlatten(arguments)) } function scheduleLatChangeFromPara (para, change) { if (!para || !util.isDef(para.lat)) return util.assert(util.isNumber(para.lat), 'lat: lat must be a number, got {0}', para.lat) util.assert(LatLon.isValidLat(para.lat), 'lat: expected a valid lat, got {0}', para.lat) change.withLatChange(para.lat) } function scheduleLonChangeFromPara (para, change) { if (!para || !util.isDef(para.lon)) return util.assert(util.isNumber(para.lon), 'lon: lon must be a number, got {0}', para.lon) util.assert(LatLon.isValidLon(para.lon), 'lon: expected a valid lon, got {0}', para.lon) change.withLonChange(para.lon) } function buildLatLon (obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined') util.assert(typeof obj === 'object', 'obj: expected an object, got {0}', obj) util.assert(util.isNumber(obj.lat), 'obj.lat: expected a number, got {0}', obj.lat) util.assert(util.isNumber(obj.lon), 'obj.lon: expected a number, got {0}', obj.lon) util.assert(LatLon.isValidLat(obj.lat), 'obj.lat: expected a valid lat in the range [-90,90], got {0}', obj.lat) util.assert(LatLon.isValidLon(obj.lon), 'obj.lon: expected a valid lon in the range [-180,180], got {0}', obj.lon) return new LatLon(obj.lat, obj.lon) } function schedulePosChangeFromPara (para, change) { if (!para || !util.isDef(para.pos)) return util.assert(para.pos, 'pos must no be null') let pos = para.pos if (pos instanceof LatLon) { // OK } else if (typeof pos === 'object') { pos = buildLatLon(pos) } else { util.assert(false, 'pos: unexpected value, expected LatLon or object, got {0}', pos) } change.withPosChange(pos) } function scheduleNodeChangeFromPara (para, change) { if (!para || !util.isDef(para.nodes)) return // convert to a Java List ... const l = new ArrayList() for (let i = 0; i &lt; para.nodes.length; i++) { l.add(para.nodes[i]) } // ... and pass it to the change command change.withNodeChange(l) } function scheduleMemberChangeFromPara (para, change) { if (!para || !util.isDef(para.members)) return const l = new ArrayList() if (para.members instanceof RelationMember) { l.add(para.members) } else if (para.members instanceof Collection) { l.addAll(para.members) } else if (util.isArray(para.members)) { for (let i = 0; i &lt; para.members.length; i++) { l.add(para.members[i]) } } else { util.assert(false, 'Expected RelationMember, array or collection ' + 'of RelationMembers, got {0}', para.members) } change.withMemberChange(l) } function scheduleTagsChangeFromPara (para, change) { if (!para || !util.isDef(para.tags)) return util.assert(para.tags, 'tags must no be null') let tags = para.tags if (tags instanceof Map) { // OK } else if (typeof tags === 'object') { const map = new HashMap() for (let key in tags) { if (!util.hasProp(tags, key)) continue const value = tags[key] key = util.trim(key) map.put(key, value) } tags = map } else { util.assert(false, 'tags: unexpected value, expected Map or object, got {0}', tags) } change.withTagsChange(tags) } function changeFromParameters (para) { const change = new Change() scheduleLatChangeFromPara(para, change) scheduleLonChangeFromPara(para, change) schedulePosChangeFromPara(para, change) scheduleTagsChangeFromPara(para, change) scheduleNodeChangeFromPara(para, change) scheduleMemberChangeFromPara(para, change) return change } /** * A command to change a collection of objects in a data layer. * * @class * @param {java.util.Collection|array} objs the objects to change * @param {org.openstreetmap.josm.plugins.scripting.js.api.Change} change the change specification * @summary A command to change a collection of objects in a data layer. */ export function ChangeCommand(objs, change) { this._objs = checkAndFlatten(objs) this._change = change } /** * Applies the command to a layer. * * @function * @summary Applies the command to a layer. * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @memberof module:josm/command.ChangeCommand * @instance * @name applyTo */ ChangeCommand.prototype.applyTo = applyTo /** * Creates the internal JOSM command for this command * * @summary Creates the internal JOSM command for this command * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @returns {org.openstreetmap.josm.command.Command} the command object * @instance * @function * @name createJOSMCommand * @memberof module:josm/command.ChangeCommand */ ChangeCommand.prototype.createJOSMCommand = function (layer) { util.assert(util.isSomething(layer), 'layer: must not be null or undefined') util.assert(layer instanceof OsmDataLayer, 'layer: expected OsmDataLayer, got {0}', layer) return new ChangeMultiCommand(layer, this._objs, this._change) } /** * Creates a command to change a collection of objects in a data layer. * * &lt;strong&gt;Signatures&lt;/strong&gt; * * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;change(obj,obj,..., options)&lt;/code&gt; &lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;obj&lt;/code&gt; are {@class org.openstreetmap.josm.data.osm.Node}s, * {@class org.openstreetmap.josm.data.osm.Way}s, or * {@class org.openstreetmap.josm.data.osm.Relation}s. Or javascript array * or Java collections thereof.&lt;/dd&gt; * &lt;/dl&gt; * * The mandatory last argument is an object with named parameters. It accepts * the following named parameters: * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;lat:number&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Changes the latitude of the target nodes to &lt;code&gt;lat&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;lon:number&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Changes the longitude of the target nodes to &lt;code&gt;lon&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;pos: * {@class org.openstreetmap.josm.data.coor.LatLon}|object&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Changes the position of the target nodes to &lt;code&gt;pos&lt;/code&gt;. * pos is either a {@class org.openstreetmap.josm.data.coor.LatLon} or an * object &lt;code&gt;{lat:..., lon:...}&lt;/code&gt; * &lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;tags:{@class java.util.Map}|object&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Changes the tags of the target objects to &lt;code&gt;tags&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;nodes:{@class java.util.List}|array&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Changes the nodes of the target way sto &lt;code&gt;nodes&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;members:{@class java.util.List}|array&lt;/code&gt; * &lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Changes the nodes of the target relations to &lt;code&gt;members&lt;/code&gt;.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import {buildChangeCommand} from 'josm/command' * import layers from 'josm/layers' * const layer = layers.get(\"Data Layer 1\") * * // change the position of a node * buildChangeCommand(n1, {lat: 123.45, lon: 44.234}).applyTo(layer) * * // change the tags of a collection of primitives * buildChangeCommand(n1, n3, w1, r1, { * tags: {'mycustomtag': 'value'} * }).applyTo(layer) * * @function * @summary Creates a command to change a collection of objects * @name change * @returns {module:josm/command.ChangeCommand} the change command object * @static */ export function buildChangeCommand() { let objs = [] let change switch (arguments.length) { case 0: util.assert(false, 'Unexpected number of arguments, got {0} arguments', arguments.length) break default: { const a = arguments[arguments.length - 1] if (a instanceof OsmPrimitive) { util.assert(false, 'Argument {0}: unexpected last argument, expected named ' + 'parameters, got {0}', a) } else if (typeof a === 'object') { // last argument is an object with named parameters objs = Array.prototype.slice.call(arguments, 0, -1) change = changeFromParameters(a) } else { util.assert(false, 'Argument {0}: unexpected type of value, got {1}', arguments.length - 1, a) } } } const tochange = checkAndFlatten(objs) return new ChangeCommand(tochange, change) } /** * Accessor to the global command history. * &lt;p&gt; * Provides static methods to redo and undo commands. * * @class * @summary Accessor to the global command history */ export const CommandHistory = {} /** * Undoes the last &lt;code&gt;depth&lt;/code&gt; commands. * * @static * @summary Undoes the last &lt;code&gt;depth&lt;/code&gt; commands. * @param {number} [depth=1] the number of commands to be undone * @memberof module:josm/command.CommandHistory * @function * @name undo */ CommandHistory.undo = function (depth) { if (util.isDef(depth)) { util.assert(util.isNumber(depth), 'depth: expected a number, got {0}', depth) util.assert(depth &gt; 0, 'depth: expected number &gt; 0, got {0}', depth) } const undoRedoHandler = UndoRedoHandler.getInstance() if (depth) { undoRedoHandler.undo(depth) } else { undoRedoHandler.undo() } } /** * Redoes the last &lt;code&gt;depth&lt;/code&gt; commands. * * @static * @summary Redoes the last &lt;code&gt;depth&lt;/code&gt; commands. * @param {number} [depth=1] the number of commands to be redone. * @memberof module:josm/command.CommandHistory * @function * @name redo */ CommandHistory.redo = function (depth) { if (util.isDef(depth)) { util.assert(util.isNumber(depth), 'depth: expected a number, got {0}', depth) util.assert(depth &gt; 0, 'depth: expected number &gt; 0, got {0}', depth) } const undoRedoHandler = UndoRedoHandler.getInstance() if (depth) { undoRedoHandler.redo(depth) } else { undoRedoHandler.redo() } } /** * Removes commands in the command history, either all commands, or only the * commands applied to a specific layer. * * @static * @summary Removes commands in the command history * @param {org.openstreetmap.josm.gui.layer.Layer} [layer] the * reference layer. Only commands applied to this layer are removed. Default * if missing: &lt;strong&gt;all&lt;/strong&gt; commands are removed. * @memberof module:josm/command.CommandHistory * @function * @name clear */ CommandHistory.clear = function (layer) { const undoRedoHandler = UndoRedoHandler.getInstance() function clearAll () { undoRedoHandler.clean() } function clearForLayer (layer) { undoRedoHandler.clean(layer) } switch (arguments.length) { case 0: clearAll(); break case 1: { const layer = arguments[0] util.assert(layer instanceof Layer, 'Expected a Layer, got {0}', layer) clearForLayer(layer) break } default: util.assert(false, 'Unexpected number of arguments') } } /** * Combines two or more ways into one resulting way. * &lt;p&gt; * Reuses the logic behind the JOSM standard menu entry Tools-&amp;gt;Combine Ways. * If invoked from a script, this may trigger modal dialogs which are presented * to the user, in particular if the direction of the ways has to be reversed * because otherwise they could not be combined. * * @param ways the ways to be combined * @example * import {combineWays} from 'josm/command' * import layers from 'josm/layer' * const ds = layers.activeLayer.data * const ways = [ds.way(1), ds.way(2), ds.way(3)] * * // pass in an array ... * combineWays(ways) * // ... or the individual ways ... * combineWays(ds.way(1), ds.way(2), ds.way(3)) * // ... or any combination thereof. * * @function * @summary Combines two or more ways into one resulting way. * @param {...org.openstreetmap.josm.data.osm.Way | array} ways the ways to be combined * @static * @name combineWays */ export function combineWays() { // ways becomes a java.util.HashSet const ways = checkAndFlatten(arguments) // remove any primitives which are not nodes from the arguments const it = ways.iterator() while (it.hasNext()) { const primitive = it.next() if (primitive == null || !primitive.isWay) { it.remove() } } // at least two remaining ways required to combine them. If less, just // return, don't throw if (ways.size() &lt;= 1) return const activeLayer = layers.activeLayer if (activeLayer == null) return const ret = CombineWayAction.combineWaysWorker(ways) // happens, if combineWayWorkers presents a modal dialog and the user // aborts it if (ret == null) return // ret.b is the SequenceCommand which combines the ways into one // resulting ways. Apply this command to the active layer. activeLayer.apply(ret.b) } /** * Combines the currently selected ways in the active layer into one resulting * way. * * Returns without effect if * &lt;ul&gt; * &lt;li&gt;there is no active layer&lt;/li&gt; * &lt;li&gt;the active layer is not a data layer&lt;/li&gt; * &lt;li&gt;there are less than two selected ways in the active layer&lt;/li&gt; * &lt;/ul&gt; * * Reuses the logic behind the JOSM standard menu entry Tools-&amp;gt;Combine Ways. * If invoked from a script, this may trigger modal dialogs which are presented * to the user, in particular if the direction of the ways has to be reversed * because otherwise they could not be combined. * * @example * import {combineSelectedWays} from 'josm/command' * import layers from 'josm/layer' * const ds = layers.activeLayer.data * combineSelectedWays(ways) * * @summary Combines the currently selected ways. * @static * @name combineSelectedWays * @function */ export function combineSelectedWays() { const activeLayer = layers.activeLayer if (activeLayer == null) return const ways = activeLayer.data.selection.ways if (ways == null || ways.length &lt;= 1) return combineWays(ways) } Ã— Search results Close "},"josm_ds.mjs.html":{"id":"josm_ds.mjs.html","title":"Source: josm/ds.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/ds.mjs /** * Provides utitly methods for data sets * * @module josm/ds */ /* global Java */ import * as util from 'josm/util' import { NodeBuilder, WayBuilder, RelationBuilder } from 'josm/builder' export const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') const PrimitiveId = Java.type('org.openstreetmap.josm.data.osm.PrimitiveId') export const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') const Collection = Java.type('java.util.Collection') const HashSet = Java.type('java.util.HashSet') const File = Java.type('java.io.File') const FileWriter = Java.type('java.io.FileWriter') const PrintWriter = Java.type('java.io.PrintWriter') const FileInputStream = Java.type('java.io.FileInputStream') const OsmImporter = Java.type('org.openstreetmap.josm.gui.io.importexport.OsmImporter') const OsmChangeImporter = Java.type('org.openstreetmap.josm.gui.io.importexport.OsmChangeImporter') const OsmReader = Java.type('org.openstreetmap.josm.io.OsmReader') const OsmChangeReader = Java.type('org.openstreetmap.josm.io.OsmChangeReader') const Utils = Java.type('org.openstreetmap.josm.tools.Utils') const GZIPInputStream = Java.type('java.util.zip.GZIPInputStream') const OsmWriterFactory = Java.type('org.openstreetmap.josm.io.OsmWriterFactory') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') const System = Java.type('java.lang.System') function log (msg) { System.out.println(msg) } function normalizeType (type) { if (util.isString(type)) { type = type.trim().toLowerCase() if ('node'.startsWith(type)) { return OsmPrimitiveType.NODE } else if ('way'.startsWith(type)) { return OsmPrimitiveType.WAY } else if ('relation'.startsWith(type)) { return OsmPrimitiveType.RELATION } else { util.assert(false, 'expected type as string, i.e. \"node\", \"way\", or \"relation\", got \"{0}\"', type) } } else if (type instanceof OsmPrimitiveType) { return type } else { util.assert(false, 'expected String or OsmPrimitiveType, got \"{0}\", type') } } function normalizeId (id) { if (util.isNumber(id)) { if (Number.isInteger(id)) { return id } else { util.assert(false, 'expected integer , got \"{0}\"', id) } } else if (util.isString(id)) { const idSaved = id id = parseInt(id.trim()) if (isNaN(id)) { util.assert(false, 'expected integer as string, got \"{0}\"', idSaved) } } else { util.assert(false, 'expected an integer or a string, got \"{0}\"', id) } } /** * Creates an ID for an OSM primitive. * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;buildId(id, type)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies an object given by its unique numeric id and a type. * The type is either a string &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;way&lt;/code&gt;, or * &lt;code&gt;relation&lt;/code&gt;, or one of the symbols * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, or * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;buildId(id)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies an object given an ID. &lt;code&gt;id&lt;/code&gt; is either an instance * of * {@class org.openstreetmap.josm.data.osm.PrimitiveId} or an object with * the properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, i.e. * &lt;code&gt;{id: 1234, type: 'node'}&lt;/code&gt;.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { buildId, OsmPrimitiveType} from 'josm/ds' * * // build a node id * const id1 = buildId(1234, 'node') * * // build a way id * const id2 = buildId(3333, OsmPrimitiveType.WAY) * * // build a relation id * const id3 = buildId({id: 5423, type: 'relation'}) * * * @param args see description */ export function buildId (id, type) { function buildId2 (id, type) { id = normalizeId(id) type = normalizeType(type) if (id === 0) { util.assert(false, 'expected id != 0, got 0') } return new SimplePrimitiveId(id, type) } function buildId1 (id) { if (id instanceof PrimitiveId) { return id } if (util.hasProp(id, 'id') &amp;&amp; util.hasProp(id, 'type')) { return buildId2(id.id, id.type) } util.assert(false, 'expected PrimitiveId or {id: ..., type: ...}, got \"{0}\"', id) } util.assert(arguments.length &gt; 0, 'expected at least 1 argument, got 0') switch (arguments.length) { case 1: return buildId1(...arguments) case 2: return buildId2(...arguments) default: util.assert(false, 'expected 1 or 2 arguments, got {0}', arguments.length) } } function each (collection, delegate) { if (util.isArray(collection) || util.isArguments(collection)) { for (let i = 0; i &lt; collection.length; i++) { delegate(collection[i]) } } else if (collection instanceof Collection) { for (let it = collection.iterator(); it.hasNext();) { delegate(it.next()) } } else { util.assert(false, 'Expected list or collection, got {0}', collection) } } function collect (collection, predicate) { const ret = [] each(collection, (obj) =&gt; { if (predicate(obj)) ret.push(obj) }) return ret } function isCollection (collection) { return util.isArray(collection) || util.isArguments(collection) || collection instanceof Collection } function normalizeIds () { function walk (set, ids) { if (util.isNothing(ids)) return if (ids instanceof PrimitiveId) { set.add(ids) } else if (isCollection(ids)) { each(ids, (that) =&gt; walk(set, that)) } else { util.assert(false, 'PrimitiveId or collection required, got {0}', ids) } } const set = new HashSet() for (let i = 0; i &lt; arguments.length; i++) { walk(set, arguments[i]) } return set } /** * &lt;code&gt;DataSetUtil&lt;/code&gt; provides methods to build OSM primitive IDs and to * manipulate data in a {@class org.openstreetmap.josm.data.osm.DataSet}. * */ export class DataSetUtil { /** * Creates an instance of &lt;code&gt;DataSetUtil&lt;/code&gt; for a given {@class org.openstreetmap.josm.data.osm.DataSet} * * @example * import { DataSetUtil, DataSet } from 'josm/ds' * const dsutil = new DataSetUtil(new DataSet()) * * @summary Build an utility object wrapping the dataset &lt;code&gt;ds&lt;/code&gt; * @param {org.openstreetmap.josm.data.osm.DataSet} [ds] the dataset. Creates a new dataset if missing */ constructor (ds) { ds = ds || new DataSet() this.ds = ds } /** * Replies an OSM object from the dataset, or undefined, if no such object * exists. * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;get(id, type)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies an object given by its unique numeric id and a type. * The type is either a string \"node\", \"way\", or \"relation\", or one of * the symbols * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, or * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;get(id)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies an object given an ID. &lt;code&gt;id&lt;/code&gt; is either an instance * of * {@class org.openstreetmap.josm.data.osm.PrimitiveId} or an object with * the properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, i.e. * &lt;code&gt;{id: 1234, type: \"node\"}&lt;/code&gt;.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { buildId , DataSetUtil, DataSet, OsmPrimitiveType} from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * // get a node * const n1 = dsutil.get(1234, 'node') * * // get a way * const w1 = dsutil.get(3333, OsmPrimitiveType.WAY) * * // get a relation * const r1 = dsutil.get({id: 5423, type: 'relation'}) * * // pass in a SimplePrimitiveId * const id = buildId(-5, OsmPrimitiveType.NODE) * const n2 = dsutil.get(id) * * // pass in a primitive to get it * const w2 = dsutil.wayBuilder().create(987) * const w3 = dsutil.get(w2) * * @param args see description */ get () { const id = buildId(...arguments) return this.ds.getPrimitiveById(id) } /** * Replies the node with id &lt;code&gt;id&lt;/code&gt;, or null. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * // get a node * const n = dsutil.node(1234) * * @param {number} id the unique numeric id. Must not be 0. * @returns {org.openstreetmap.josm.data.osm.Node} the node */ node (id) { util.assert(util.isSomething(id), 'expected defined id, got \"{0}\"', id) return this.get(id, 'node') } /** * Replies the way with id &lt;code&gt;id&lt;/code&gt;, or null * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * // get a way * const w = dsutil.way(1234) * @param {number} id the unique numeric id. Must not be 0. * @returns {org.openstreetmap.josm.data.osm.Way} the way */ way (id) { util.assert(util.isSomething(id), 'expected defined id, got \"{0}\"', id) return this.get(id, 'way') } /** * Replies the relation with id &lt;code&gt;id&lt;/code&gt;. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * // get a relation * const r = dsutil.relation(1234) * * @param {number} id the unique numeric id. Must not be 0. * @returns {org.openstreetmap.josm.data.osm.Relation} the relation */ relation (id) { util.assert(util.isSomething(id), 'expected defined id, got \"{0}\"', id) return this.get(id, 'relation') } /** * Run a sequence of operations against the dataset in \"batch mode\". * * Listeners to data set events are only notified at the end of the batch. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * const dsutil = new DataSetUtil(new DataSet()) * // creates and adds two nodes and a way in batch operation * // to the dataset * dsutil.batch(() =&gt; { * const n1 = dsutil.nodeBuilder().create() * const n2 = dsutil.nodeBuilder().create() * dsutil.wayBuilder().withNodes(n1,n2).create() * }) * * @param {function} delegate the function implementing the batch process. * Ignored if null or undefined. */ batch (delegate) { if (!(util.isSomething(delegate))) { return } util.assert(util.isFunction(delegate), 'expected a function, got \"{0}\"', delegate) this.ds.beginUpdate() try { delegate() } finally { this.ds.endUpdate() } } /** * Removes objects from the dataset * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;remove(id, type)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Removes a single object given by its unique numeric ID (nid) and a * type. The type is either a string \"node\", \"way\", or \"relation\", or one * of the symbols * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, or * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;remove(id, id, ...)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Removes a collection of objects given by the ids. &lt;code&gt;id&lt;/code&gt; is * either an instance of * {@class org.openstreetmap.josm.data.osm.PrimitiveId} or an object with * the properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, i.e. * &lt;code&gt;{id: 1234, type: \"node\"}&lt;/code&gt;. * null and undefined are ignored.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;remove(array|collection)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Removes a collection of objects given by the an array or a * java.util.Collection of ids. * The collection elemeents are either instances of * {@class org.openstreetmap.josm.data.osm.PrimitiveId} or an object with * the properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, i.e. * &lt;code&gt;{id: 1234, type: \"node\"}&lt;/code&gt;. * null or undefined elements are ignored. * &lt;/dd&gt; * &lt;/dl&gt; * * @example * import { DataSet, DataSetUtil, OsmPrimitiveType, buildId} from 'josm/ds' * const HashSet = Java.type('java.util.HashSet') * const dsutil = new DataSetUtil(new DataSet()) * * // remove a node with a global id * dsutil.remove(1234, 'node') * * // remove a node and a way * const id1 = buildId(1234, 'node') * const id2 = buildId(3333, OsmPrimitiveType.WAY) * dsutil.remove(id1, id2) * * // remove a relation and a node * dsutil.remove({id: 1234, type: 'relation'}, id1) * * // remove an array of nodes * dsutil.remove([id1,id2]) * * // remove a set of primitives * const ids = new HashSet() * ids.add(id1) * ids.add(id1) * dsutil.remove(ids) * * @param args see description */ remove () { // we have exactly two arguments, id and type. If we succeed // to convert them to a primitive id, then we are done if (arguments.length === 2) { let id try { id = buildId(normalizeId(arguments[0]), normalizeType(arguments[1])) } catch (e) { id = null } if (id) { this.ds.removePrimitive(id) return } } // we have a list of ids or collections of ids to remove. // First build a flat list of the ids, then remove them // in a batch operation from the dataset const ids = normalizeIds(...arguments) const ds = this.ds this.batch(() =&gt; { each(ids, (id) =&gt; { ds.removePrimitive(id) }) }) } /** * Replies a node builder to create {@class org.openstreetmap.josm.data.osm.Node}s in this dataset. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * const dsutil = new DataSetUtil(new DataSet()) * const n = dsutil.nodeBuilder * .withId(1234,4567) * .withTags({amenity: 'restaurant'}) * .create() * dsutil.has(n) * * @property {module:josm/builder~NodeBuilder} nodeBuilder * @readOnly */ get nodeBuilder () { return NodeBuilder.forDataSet(this.ds) } /** * Replies a way builder to create ways in this dataset. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * const nb = dsutil.nodeBuilder() * const w = dsutil.wayBuilder() * .withNodes(nb.create(), nb.create()) * .create(1234, {tags: {highway: \"residential\"}}) * dsutil.has(w) * * @property {module:josm/builder~WayBuilder} wayBuilder * @readOnly */ get wayBuilder () { return WayBuilder.forDataSet(this.ds) } /** * Replies a relation builder to create relations in this dataset. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * const r = dsutil.relationBuilder() * .withId(8765,1234) * .create({tags: {type: 'network'}}) * ds.has(r) // --&gt; true * * @property {module:josm/builder~RelationBuilder} relationBuilder * @readOnly */ get relationBuilder () { return RelationBuilder.forDataSet(this.ds) } /** * Loads a dataset from a file. * &lt;p&gt; * Derives the format of the file from the file suffix, unless the named * option &lt;code&gt;options.format&lt;/code&gt; is set. * &lt;p&gt; * &lt;code&gt;options&lt;/code&gt; can contain the following named options: * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;format&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;one of the strings &lt;code&gt;osm&lt;/code&gt; (Open Street Map XML data), * &lt;code&gt;osc&lt;/code&gt; (Open Street Map change format), or * &lt;code&gt;osm.gz&lt;/code&gt; (Open Street Map XML data, * compressed with gzip). The format is normalized: white space is removed and it is * converted to lower case.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { DataSetUtil } from 'josm/ds' * * // loads an OSM file * DataSetUtil.load('/path/to/my/file.osm') * * // loads an OSM file, explicity passing in the format * DataSetUtil.load('/path/to/my/file.any-suffix', { format 'osm' }) * * @param {string|java.io.File} source the data source * @param {object} [options] optional named parameters * * @return {module:josm/ds~DataSetUtil} the data set util with the loaded data set */ static load (source, options) { function normalizeFile (source) { if (source instanceof File) { return source } else if (util.isString(source)) { return new File(source) } else { util.assert(false, 'source: illegal value, expected string or File, got {0}', source) } } function normalizeFormat (source, options) { const FORMATS = { osm: true, osc: true, 'osm.gz': true } if (util.isSomething(options.format)) { // convert to string const format = util.trim(options.format + '').toLowerCase() if (FORMATS[format]) { return format } util.assert(false, `options.format: unknown format '${format}'`) } else { if (source.getPath().endsWith('.osm.gz')) { return 'osm.gz' } if (new OsmImporter().acceptFile(source)) { return 'osm' } if (new OsmChangeImporter().acceptFile(source)) { return 'osc' } util.assert(false, `Failed to derive format from file name. file is '${source}'`) } } util.assert(util.isSomething(source), 'source: must not be null or undefined') options = options || {} source = normalizeFile(source) const format = normalizeFormat(source, options) log(`format: ${format}`) let is try { switch (format) { // load an OSM file case 'osm': { is = new FileInputStream(source) const other = OsmReader.parseDataSet(is, null /* null progress monitor */) return new DataSetUtil(other) } // load an OSC file case 'osc': { is = new FileInputStream(source) const other = OsmChangeReader.parseDataSet(is, null /* null progress monitor */) return new DataSetUtil(other) } // load a compressed OSM file case 'osm.gz': { is = new GZIPInputStream(new FileInputStream(source)) const other = OsmReader.parseDataSet(is, null /* null progress monitor */) return new DataSetUtil(other) } default: util.assert(false, `unknown format '${format}'. Failed to load from ${source}`) } } finally { is &amp;&amp; Utils.close(is) } } /** * Saves the dataset to a file (in OSM XML format). * &lt;p&gt; * * &lt;code&gt;options&lt;/code&gt; can contain the following named options: * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;version&lt;/code&gt;: string&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;the value of the attribute &lt;code&gt;version&lt;/code&gt; in the OSM file * header. Default: \"0.6\"&lt;/dd&gt; * * &lt;dt&gt;&lt;codeclass=\"signature\"&gt;changeset&lt;/code&gt;: Changeset&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;the changeset whose id is included in the attribute * &lt;code&gt;changeset&lt;/code&gt; on every OSM object. If undefined, includes the * individual &lt;code&gt;changeset&lt;/code&gt; attribute of the OSM object. * Default: undefined&lt;/dd&gt; * &lt;dt&gt;&lt;codeclass=\"signature\"&gt;osmConform&lt;/code&gt;: bool&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;if true, prevents modification attributes to be written * Default: true&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil() * // create a node in the dataset * dsutil.nodeBuilder() * .withId(1, 1) * .withPosition({ lat: 1.0, lon: 1.0 }) * .create() * * // save the dataset * dsutil.save('/tmp/my-dataset.osm') * * @param {string|java.io.File} target the target file * @param {object} [options] optional named parameters * @instance */ save (target, options) { function normalizeTarget (target) { util.assert(util.isSomething(target), 'target: must not be null or undefined') if (util.isString(target)) { return new File(target) } else if (target instanceof File) { return target } else { util.assert(false, 'target: unexpected type of value, got {0}', target) } } function normalizeOptions (options) { options = options || {} util.assert( !util.isDef(options.version) || util.isString(options.version), 'options.version: expected a string, got {0}', options.version) options.version = options.version ? util.trim(options.version) : null /* default version */ /// true, if not explicity set to false options.osmConform = options.osmConform !== false const changeset = options.changeset util.assert( !util.isDef(changeset) || changeset instanceof Changeset, 'options.changeset: expected a changeset, got {0}', changeset) return options } target = normalizeTarget(target) options = normalizeOptions(options) let pw try { pw = new PrintWriter(new FileWriter(target)) const writer = OsmWriterFactory.createOsmWriter( pw, options.osmConform, options.version) if (options.changeset) { writer.setChangeset(options.changeset) } try { this.ds.getReadLock().lock() writer.header() writer.writeContent(this.ds) writer.footer() } finally { this.ds.getReadLock().unlock() } } finally { pw &amp;&amp; pw.close() } } /** * Queries the dataset * &lt;p&gt; * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;query(josmSearchExpression,?options)&lt;/code&gt; * &lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Queries the dataset using the JOSM search expression * &lt;code&gt;josmSearchExpression&lt;/code&gt;. * &lt;code&gt;josmSearchExpression&lt;/code&gt; is a string as you would enter it in * the JOSM search dialog. &lt;code&gt;options&lt;/code&gt; is an (optional) object * with named parameters, see below.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;query(predicate,?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Queries the dataset using a javascript predicate function * &lt;code&gt;predicate&lt;/code&gt;. &lt;code&gt;predicate&lt;/code&gt; is a javascript * function which accepts a object as parameter and replies * true, when it matches for the object ans false otherwise. * &lt;code&gt;options&lt;/code&gt; is an (optional) object with named parameters, * see below.&lt;/dd&gt; * &lt;/dl&gt; * * The parameter &lt;code&gt;options&lt;/code&gt; consist of the following (optional) * named parameters: * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;allElements&lt;/code&gt; : boolean * (Deprecated parameter names: * &lt;code class=\"signature\"&gt;all&lt;/code&gt;)&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;If true, searches &lt;em&gt;all&lt;/em&gt; objects in the dataset. If false, * ignores incomplete or deleted * objects. Default: false.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;caseSensitive&lt;/code&gt; : boolean&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;strong&gt;Only applicable for searches with a JOSM search * expression&lt;/strong&gt;. If true, searches case sensitive. If false, * searches case insensitive. Default: false.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;regexSearch&lt;/code&gt; : boolean (Deprecated * parameter names: * &lt;code class=\"signature\"&gt;withRegexp&lt;/code&gt;, * &lt;code class=\"signature\"&gt;regexpSearch&lt;/code&gt;)&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;strong&gt;Only applicable for searches with a JOSM search * expression&lt;/strong&gt;. If true, the search expression contains regular * expressions. If false, it includes only plain strings for searching. * Default: false.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;mapCSSSearch&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;strong&gt;Only applies for searches with a JOSM search * expression&lt;/strong&gt;. * Default: false.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { DataSetUtil } from 'josm/ds' * const dsutil = new DataSetUtil() * // add or load primitives to query * // ... * * // query restaurants * const result1 = dsutil.query('amenity=restaurant') * * // query all nodes with a type query * const result2 = dsutil.query('type:node') * * // query using a custom predicate - all primitives * // with exactly two tags * const result3 = dsutil.query((primitive) =&gt; { * primitive.getKeys().size() === 2 * }) * * @param {string|function} expression the match expression * @param {object} [options] additional named parameters * @instance */ query (expression, options) { const SearchSetting = Java.type('org.openstreetmap.josm.data.osm.search.SearchSetting') const SearchCompiler = Java.type('org.openstreetmap.josm.data.osm.search.SearchCompiler') options = options || {} switch (arguments.length) { case 0: return [] case 1: case 2: if (util.isString(expression)) { const ss = new SearchSetting() ss.caseSensitive = Boolean(options.caseSensitive) ss.regexSearch = Boolean(options.regexSearch) || Boolean(options.regexpSearch) || Boolean(options.withRegexp) ss.allElements = Boolean(options.all) || Boolean(options.allElements) ss.mapCSSSearch = Boolean(options.mapCSSSearch) ss.text = expression const matcher = SearchCompiler.compile(ss) let predicate if (ss.allElements) { predicate = (matcher) =&gt; (obj) =&gt; { return matcher.match(obj) } } else { predicate = (matcher) =&gt; (obj) =&gt; { return obj.isUsable() &amp;&amp; matcher.match(obj) } } return collect(this.ds.allPrimitives(), predicate(matcher)) } else if (util.isFunction(expression)) { const all = Boolean(options.all) || Boolean(options.allElements) let predicate = expression if (!all) { predicate = (obj) =&gt; { return obj.isUsable() &amp;&amp; expression(obj) } } return collect(this.ds.allPrimitives(), predicate) } else { util.assert(false, 'expression: Unexpected type of argument, got {0}', arguments[0]) } break default: util.assert(false, 'Expected a predicate, got {0} arguments', arguments.length) } } } Ã— Search results Close "},"josm_layers.mjs.html":{"id":"josm_layers.mjs.html","title":"Source: josm/layers.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/layers.mjs /** * Provides access to the JOSM layers. * * @module josm/layers */ /* global Java */ // -- imports const MainApplication = Java.type('org.openstreetmap.josm.gui.MainApplication') const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const Layer = Java.type('org.openstreetmap.josm.gui.layer.Layer') import * as util from './util' /** * Provides access to JOSM layers. */ export class Layers { /** * Replies the number of currently open layers. * * @readOnly * @type {number} */ get length() { return MainApplication.getLayerManager().getLayers().size() } /** * Set or get the active layer. * * &lt;dl&gt; * &lt;dt&gt;get&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies the active layer or undefined.&lt;/dd&gt; * * &lt;dt&gt;set&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Assign either an existing {@class org.openstreetmap.josm.gui.layer.Layer}, * the name of a layer as string, or a layer index as number.&lt;/dd&gt; * &lt;/dl&gt; * * @type {org.openstreetmap.josm.gui.layer.Layer} */ get activeLayer() { return MainApplication.getLayerManager().getActiveLayer() } set activeLayer(value) { util.assert(util.isSomething(value),'Value must not be null or undefined)') let layer = null if (value instanceof Layer) { layer = value } else if (util.isNumber(value) || util.isString(value)) { layer = layers.get(value) } else { util.assert(false, 'Unexpected type of value, got {0}', value) } util.assert(util.isSomething(layer), 'Layer \\'\\'{0}\\'\\' doesn\\'\\'t exist. It can\\'\\'t be set as active layer.', value) MainApplication.getLayerManager().setActiveLayer(layer) } #getLayerByName (key) { key = util.trim(key).toLowerCase() if (this.length === 0) return undefined const layers = MainApplication.getLayerManager().getLayers() for (let it = layers.iterator(); it.hasNext();) { const l = it.next() if (l.getName().trim().toLowerCase() === key) return l } return undefined } #getLayerByIndex (idx) { if (idx &lt; 0 || idx &gt;= this.length) return undefined const layers = MainApplication.getLayerManager().getLayers() return layers.get(idx) } /** * Replies one of the layers given a key. * * &lt;ul&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a number, replies the layer with index key, or * undefined, if no layer for this index exists.&lt;/li&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a string, replies the first layer whose name * is identical to key (case insensitive, without leading/trailing * whitespace), or undefined, if no layer with such a name exists.&lt;/li&gt; * &lt;/ul&gt; * * @example * import layers from 'josm/layers' * * // get the first layer * const layer1 = layers.get(0) * * // get the first layer with name \"data layer\" * const layer2 = layers.get('data layer') * * @param {number|string} key the key to retrieve the layer * @returns {org.openstreetmap.josm.gui.layer.Layer} */ get(key) { if (util.isNothing(key)) return undefined if (util.isString(key)) return this.#getLayerByName(key) if (util.isNumber(key)) return this.#getLayerByIndex(key) return undefined } /** * Checks whether &lt;code&gt;layer&lt;/code&gt; is a currently registered layer. * * @example * import layers from 'josm/layers' * * // is there a layer with name \"my layer\"? * let b = layers.has('my layer') * * // is there a layer at index position 2 * b = layers.has(2) * * // is there a specific layer? * let l = layers.get(0) * b = layers.has(l) * * @param {org.openstreetmap.josm.gui.layer.Layer|string|number} layer a layer, * a layer name, or a layer index * @returns {boolean } true, if the layer or at least one layer with the given name exists. * False, otherwise. */ has(layer) { if (util.isNothing(layer)) return false const layerManager = MainApplication.getLayerManager() if (layer instanceof Layer) { return layerManager.getLayers().contains(layer) } else if (util.isString(layer)) { return util.isSomething(layers.get(layer)) } else if (util.isNumber(layer)) { return layer &gt;= 0 &amp;&amp; layer &lt; layers.length } else { return false } } /** * Adds a layer. * &lt;p&gt; * Either pass in a layer object or a data set. In the later case, an * {@class org.openstreetmap.josm.gui.layer.OsmDataLayer} is * automatically created. * * @example * import layers from 'josm/layers' * const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const dataLayer = new OsmDataLayer(new DataSet(), null, null); * // add a layer ... * layers.add(dataLayer) * * // or add a dataset, which will create a data layer * const ds = new DataSet() * layer.add(ds) * * @param {org.openstreetmap.josm.gui.layer.Layer * |org.openstreetmap.josm.data.osm.DataSet} obj a layer to add, * or a dataset. Ignored if null or undefined. * @returns {org.openstreetmap.josm.gui.layer.Layer} the added layer */ add(obj) { if (util.isNothing(obj)) return const layerManager = MainApplication.getLayerManager() if (obj instanceof Layer) { layerManager.addLayer(obj) } else if (obj instanceof DataSet) { layerManager.addLayer(new OsmDataLayer(obj, null, null)) } else { util.assert(false, 'Expected an instance of Layer or DataSet, got {0}', obj) } } #removeLayerByIndex (idx) { const layer = this.get(idx) if (util.isNothing(layer)) return MainApplication.getLayerManager().removeLayer(layer) } #removeLayerByName (name) { const layer = this.get(name) if (util.isNothing(layer)) return MainApplication.getLayerManager().removeLayer(layer) } /** * Removes a layer with the given key. * * &lt;ul&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Number&lt;/code&gt;, removes the layer with * the index key. If the index doesn't isn't a valid layer index, nothing * is removed.&lt;/li&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, removes the layer with * the name &lt;code&gt;key&lt;/code&gt;. Leading and trailing white space is removed, * matching is a case-insensitive sub-string match.&lt;/li&gt; * &lt;/ul&gt; * @example * import josm from 'josm' * * // remove the first layer * josm.layers.remove(0) * * // remove the first layer matching with the supplied name * josm.layers.remove('myLayerName') * * @param {number|string} key indicates the layer to remove */ remove(key) { if (util.isNothing(key)) return if (util.isNumber(key)) { this.#removeLayerByIndex(key) } else if (util.isString(key)) { this.#removeLayerByName(key) } else { util.assert(false, 'Expected a number or a string, got {0}', key) } } /** * Creates and adds a new data layer. The new layer becomes the new edit * layer. * &lt;p&gt; * * &lt;string&gt;Signatures&lt;/string&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer()&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;create data layer with a new dataset and default name&lt;/dd&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer(ds)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;create data layer with dataset ds and default name&lt;/dd&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer(name)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;create data layer with a new dataset and name &lt;code&gt;name&lt;/code&gt;&lt;/dd&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer({name: ..., ds: ...})&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;create data layer with a new dataset and name &lt;code&gt;name&lt;/code&gt;&lt;/dd&gt; * &lt;/dl&gt; * @example * import josm from 'josm' * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * // creates a new data layer * const l1 = josm.layers.addDataLayer() * * // creates a new data layer with name 'test' * const l2 = josm.layers.addDataLayer('test') * * // creates a new data layer for the dataset ds * const ds = new DataSet() * const l3 = josm.layers.addDataLayer(ds) * * @returns {org.openstreetmap.josm.gui.layer.OsmDataLayer} the added layer * @param {string | org.openstreetmap.josm.data.osm.DataSet | object } args see description */ addDataLayer() { let name, ds switch (arguments.length) { case 0: break case 1: if (util.isString(arguments[0])) { name = util.trim(arguments[0]) } else if (arguments[0] instanceof DataSet) { ds = arguments[0] } else if (typeof arguments[0] === 'object') { if (util.isString(arguments[0].name)) { name = util.trim(arguments[0].name) } if (arguments[0].ds instanceof DataSet) { ds = arguments[0].ds } } else { util.assert(false, 'unsupported type of argument, got {0}', arguments[0]) } break default: util.assert(false, 'Unsupported number of arguments, got {0}', arguments.length) } ds = ds || new DataSet() name = name || OsmDataLayer.createNewName() const layer = new OsmDataLayer(ds, name, null /* no file */) layers.add(layer) return layer } } /** * the singleton instance of the layers class */ const layers = new Layers() export default layers Ã— Search results Close "},"josm_scriptingconsole.mjs.html":{"id":"josm_scriptingconsole.mjs.html","title":"Source: josm/scriptingconsole.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/scriptingconsole.mjs /** * Provides a set of functions to write to the built-in scripting * console. * * @module josm/scriptingconsole */ /* global Java */ // -- imports const ScriptingConsole = Plugin.type('org.openstreetmap.josm.plugins.scripting.ui.console.ScriptingConsole') const MessageFormat = Java.type('java.text.MessageFormat') function consoleWriter () { return ScriptingConsole.static.getInstance().getScriptLog().getLogWriter() } /** * Prints a string to the console * * @example * import {print} from 'josm/scriptingconsole' * print('Hello world!') * * // or use formatting * print('Hello world! My name is {0}', 'foo') * * @summary Prints a string to the console * @param {string} message the message * @param {...object} [values] optional values * @static * @name print * @function */ export function print() { const args = Array.prototype.slice.call(arguments, 0) switch (args.length) { case 0: return case 1: consoleWriter().print(args[0] + '') return default: { args[0] = args[0] + '' // make sure first argument is a string const msg = MessageFormat.format(args[0], args.slice(1)) consoleWriter().print(msg) } } } /** * Prints a string to the console, including newline * * @example * import {println} from 'josm/scriptingconsole' * println('Hello world!') * * // or use formatting * ('Hello world! My name is {0}', 'foo') * * @summary Prints a string to the console, including newline * @static * @name println * @function * @param {string} message the message * @param {...object} [values] optional values */ export function println() { var args = Array.prototype.slice.call(arguments, 0) switch (args.length) { case 0: return case 1: consoleWriter().println(args[0] + '') return default: { args[0] = args[0] + '' // make sure first argument is a string const msg = MessageFormat.format(args[0], args.slice(1)) consoleWriter().println(msg) } } } /** * Clears the scripting console. * * @example * import * as console from 'josm/scriptingconsole' * console.clear() * * @summary Clears the scripting console. * @function * @name clear * @static */ export function clear() { const action = ScriptingConsole.getInstance().getScriptLog().getClearAction() action.actionPerformed(null) } /** * Shows the scripting console * * @example * import * as console from 'josm/scriptingconsole' * console.show() * * @summary Shows the scripting console * @function * @name show * @static */ export function show() { ScriptingConsole.showScriptingConsole() } /** * Hides the scripting console * * @example * import * as console from 'josm/scriptingconsole' * console.hide() * * @summary Hides the scripting console * @function * @name hide * @static */ export function hide() { ScriptingConsole.hideScriptingConsole() } /** * Toggles the visibility of the scripting console * * @example * import * as console from 'josm/scriptingconsole' * console.toggle() * * @summary Toggles the visibility of the scripting console * @function * @name toggle * @static */ export function toggle() { ScriptingConsole.toggleScriptingConsole() } Ã— Search results Close "},"josm_ui_menu.mjs.html":{"id":"josm_ui_menu.mjs.html","title":"Source: josm/ui/menu.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/ui/menu.mjs /** * Provides a collection of namespaces, classes and functions to work with * JOSMs menu system. * * @module josm/ui/menu */ /* global Java */ const MainApplication = Java.type('org.openstreetmap.josm.gui.MainApplication') import * as util from 'josm/util' /** * Represents JOSMs global menu bar. * * @class * @name MenuBar */ export const MenuBar = {} /** * Replies the number of menus in the JOSM menu bar. * * @example * import josm from 'josm' * // display the number of menus * josm.alert(josm.menu.length) * * @property {number} length the number of menues * @name length * @summary the number of menus in the JOSM menu bar * @memberof module:josm/ui/menu~MenuBar * @static */ Object.defineProperty(MenuBar, 'length', { enumerable: true, get: function () { if (!MainApplication.getMenu()) return 0 return MainApplication.getMenu().getMenuCount() } }) /** * Replies a menu in the JOSM menu bar. * * &lt;code&gt;key&lt;/code&gt; is either a numberic index or one of the following * symbolic names as string: * &lt;ul&gt; * &lt;li&gt;&lt;code&gt;file&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;edit&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;view&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;tools&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;presets&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;imagery&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;window&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;help&lt;/code&gt;&lt;/li&gt; * &lt;/ul&gt; * * @example * import josm from 'josm' * // get the edit menu with a numeric index * const editmenu = josm.menu.get(1) * * // get the file menu with a symbolic name * const filemenu = josm.menu.get('file') * * @return {javax.swing.JMenu} the menu * @summary Replies a menu in the JOSM menu bar. * @param {number|string} key the key denoting the menu * @memberof module:josm/ui/menu~MenuBar * @name get * @function * @instance */ MenuBar.get = function (key) { util.assert(util.isSomething(key), 'key: must not be null or undefined') const mainMenu = MainApplication.getMenu() if (util.isNumber(key)) { util.assert(key &gt;= 0 &amp;&amp; key &lt; exports.MenuBar.length, 'key: index out of range, got {0}', key) return mainMenu.getMenu(key) } else if (util.isString(key)) { key = util.trim(key).toLowerCase() switch (key) { case 'file': return mainMenu.fileMenu case 'edit': return mainMenu.editMenu case 'view': return mainMenu.viewMenu case 'tools': return mainMenu.toolsMenu case 'presets': return mainMenu.presetsMenu case 'imagery': return mainMenu.imageryMenu case 'window': return mainMenu.windowMenu case 'help': return mainMenu.helpMenu default: util.assert(false, 'Unsupported key to access a menu, got {0}', key) } } else { util.assert(false, 'Unexpected value, got {0}', key) } } /** * Replies an array with the symbolic menu names. * * @memberof module:josm/ui/menu~MenuBar * @name menuNames * @property {array} menuNames the names of the menues in the menu bar * @readOnly * @summary Replies an array with the symbolic menu names. * */ Object.defineProperty(MenuBar, 'menuNames', { enumerable: true, get: function () { return ['file', 'edit', 'view', 'tools', 'presets', 'imagery', 'window', 'help'] } }) /** * JSAction is an action for which a menu item or a toolbar item can be * added to JOSMs menu or JOSMs toolbar respectively. * * This is just a shortcut for the Java class * {@class org.openstreetmap.josm.plugins.scripting.js.JSAction}. * * The constructor accepts an object with the following optional named * parameters. * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;name:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;The optional name of the action. Default: an auto generated name.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;tooltip:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;The optional tooltip of the action. Default: empty string.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;iconName:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;The optional name of an icon. Default: null.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;toolbarId:string&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;The optional name of the tooblar to which this action is added. * Note that it isn't added automatically, when this action is created. Default: null.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;onExecute:function&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;The (optional) function which is called when the action is executed. * Default: null.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;onInitEnabled:function&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;The (optional) function which is called when the &lt;em&gt;enabled&lt;/em&gt; * state of the function is evaluated the first time. Default: null.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;onUpdateEnabled:function&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;The (optional) function which is called when the &lt;em&gt;enabled&lt;/em&gt; * state of the function is reevaluated, in particular, when layer change * events or selection change events occur. Default: null.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import {JSAction} from 'josm/ui/menu' * import * as util from 'josm/util' * import josm from 'josm' * const JMenuItem = Java.type('javax.swing.JMenuItem') * * // create the menu action * const helloWorldAction = new JSAction({ * name: \"My Action\", * iconName: 'myicon', * toolbarId: 'myToolbarId', * tooltip: \"This is my action\", * * onInitEnabled: function() { * util.println('onInitEnabled: entering ...') * }, * * onUpdateEnabled: function() { * util.println('onUpdateEnabled: entering ...') * }, * * onExecute: function() { * util.println('Hello World!') * } * }) * * // register a new menu item in the file menu * const fileMenu = josm.menu.get('file') * fileMenu.addSeparator() * fileMenu.add(new JMenuItem(helloWorldAction)) * * * @property {org.openstreetmap.josm.plugins.scripting.graalvm.JSAction} JSAction * @static * @name JSAction * @memberof module:josm/ui/menu~MenuBar */ export const JSAction = Plugin.type('org.openstreetmap.josm.plugins.scripting.graalvm.JSAction') Ã— Search results Close "},"josm_unittest.mjs.html":{"id":"josm_unittest.mjs.html","title":"Source: josm/unittest.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/unittest.mjs /** * @module josm/unittest */ /* global Java */ import * as util from 'josm/util' const System = Java.type('java.lang.System') const out = System.out export function TestCase(name, test) { this._name = name this._test = test } export function test() { switch (arguments.length) { case 1: return new TestCase('No Name', arguments[0]) case 2: return new TestCase(arguments[0], arguments[1]) default: util.assert(false, 'Unsupported arguments') } } TestCase.prototype.run = function () { try { this._test() out.println('PASS - ' + this._name) return true } catch (e) { out.println(`FAIL - ${this._name}`) const desc = e.message || e.description || e out.println(` description: ${desc}`) let context if (e.lineNumber || e.fileName) { context = ` filename: ${e.fileName}, line: ${e.lineNumber}` } if (context) { out.println(` context: ${context}`) } return false } } export function Suite(name) { this._name = name this._tests = [] } export function suite() { if (arguments.length === 0) return new Suite() let idx = 0 const name = arguments[0] let suite if (util.isString(name)) { suite = new Suite(name) idx = 1 } else { suite = new Suite() } for (let i = idx; i &lt; arguments.length; i++) { const test = arguments[i] if (test instanceof TestCase) { suite.add(test) } else if (util.isFunction(test)) { suite.add(test(test)) } else { util.assert(false, 'Unsupported arguments') } } return suite } Suite.prototype.add = function (test) { this._tests.push(test) } Suite.prototype.run = function () { out.println('----------------------------------------------------------------------') if (this._name) { out.println('suite: ' + this._name) out.println('----------------------------------------------------------------------') } let numtests = 0 let numfail = 0 let numok = 0 for (let i = 0; i &lt; this._tests.length; i++) { const ret = this._tests[i].run() numtests++ if (ret) { numok++ } else { numfail++ } } out.println('----------------------------------------------------------------------') out.println(' # tests: ' + numtests + ' # PASS : ' + numok + ' # FAIL : ' + numfail) out.println('----------------------------------------------------------------------') return numfail } export function expectError() { let name = 'no name' let f switch (arguments.length) { case 0: return case 1: f = arguments[0]; break case 2: name = arguments[0] f = arguments[1] break default: util.assert(false, 'Unexpected number of arguments') } try { f() util.assert(false, \"''{0}'': should have failed. Didn''t catch an error.\", name) } catch (e) { // OK } } export function expectAssertionError() { let name = 'no name' let f switch (arguments.length) { case 0: return case 1: f = arguments[0]; break case 2: name = arguments[0] f = arguments[1] break default: util.assert(false, 'Unexpected number of arguments') } try { f() util.assert(false, \"''{0}'': should have failed. Didn''t catch an error.\", name) } catch (e) { if (e.name !== 'AssertionError') { util.assert(false, \"''{0}'': expected an AssertionError, caught {1}.\", name, e.toSource()) } } } Ã— Search results Close "},"josm_util.mjs.html":{"id":"josm_util.mjs.html","title":"Source: josm/util.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Source: josm/util.mjs /** * Provides a set of static utility functions. * * @module josm/util */ /* global Java */ // -- imports const MessageFormat = Java.type('java.text.MessageFormat') /** * Checks whether a value is null or undefined. * * @param {object} value the value to check * @return {boolean} false, if &lt;code&gt;value&lt;/code&gt; is null or undefined; true, otherwise * @summary Checks whether a value is null or undefined. * @function * @name isNothing */ export function isNothing(value) { return value === null || value === undefined } /** * Checks whether a value is neither null nor undefined. * * @param {object} value the value to check * @return {boolean} false, if &lt;code&gt;value&lt;/code&gt; is null or undefined; true, otherwise * @summary Checks whether a value is neither null nor undefined. * @function * @name isSomething */ export function isSomething(val) { return !isNothing(val) } /** * Trims leading and trailing whitespace from &lt;code&gt;s&lt;/code&gt;. * &lt;p&gt; * * Replies s, if s is null or undefined. Any other value is converted to a * string, then leading and trailing white space is removed. * * @param {string} s the string to be trimmed * @return {string} * @summary Trims leading and trailing whitespace from &lt;code&gt;s&lt;/code&gt;. * @function * @name trim */ export function trim(s) { if (isNothing(s)) { return s } return (s + '').replace(/^\\s+/, '').replace(/\\s+$/, '') } /** * Assert a condition and throw an Error if the condition isn't met. * * &lt;p&gt;&lt;strong&gt;Usage:&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code&gt;assert()&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Does nothing&lt;/dd&gt; * * &lt;dt&gt;&lt;code&gt;assert(cond)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Checks the condition &lt;code&gt;cond&lt;/code&gt;. If it is false, throws an * Error.&lt;/dd&gt; * * &lt;dt&gt;&lt;code&gt;assert(cond, msg)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Checks the condition &lt;code&gt;cond&lt;/code&gt;. If it is false, throws an * Error, whose &lt;code&gt;description&lt;/code&gt; property * is set to &lt;code&gt;msg&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code&gt;assert(cond, msg, objs...)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Checks the condition &lt;code&gt;cond&lt;/code&gt;. If it is false, throws an * Error, whose &lt;code&gt;description&lt;/code&gt; property * is set to the formatted message &lt;code&gt;msg&lt;/code&gt;. Internally uses * &lt;code&gt;java.text.MessageFormat&lt;/code&gt; to format the message.&lt;/dd&gt; * * &lt;/dl&gt; * * @example * import {assert} from 'josm/util' * // throws an Error * assert(false) * * // throws an Error e, with e.description == \"My message\" * assert(false, \"My message\") * * // throws an Error e, with e.description == \"My message: test\" * assert(false, \"My message: {0}\", \"test\") * * @summary Assert a condition and throw an Error if the condition isn't met. * @function * @name assert * @static * @param {boolean} condition * @param {string} [message] the message * @param {...object} [values] an optional list of values */ export function assert() { let message, name switch (arguments.length) { case 0: return case 1: if (arguments[0]) return name = 'AssertionError' message = 'An assertion failed' break case 2: if (arguments[0]) return name = 'AssertionError' message = arguments[1] break default: { if (arguments[0]) return name = 'AssertionError' const args = Array.prototype.slice.call(arguments, 0) message = MessageFormat.format( args[1], args.slice(2) ) break } } const error = new Error(message) error.name = name throw error } /** * Asserts that &lt;code&gt;val&lt;/code&gt; is defined and non-null. * * @example * import {assertSomething} from 'josm/util' * * assertSomething(null) // -&gt; throws an exception * assertSomething(void 0) // -&gt; throws an exception * * assertSomting(\"test\") // -&gt; OK * assertSomething(5) // -&gt; OK * * @param {any} val the value to check * @param {string} [msg] message if the assertion fails * @param {...object} [values] additional values used in &lt;code&gt;msg&lt;/code&gt; * placeholders * @summary Asserts that &lt;code&gt;val&lt;/code&gt; is defined and non-null. * @function * @static * @name assertSomething */ export function assertSomething(val) { let args if (arguments.length &lt;= 1) { args = [isSomething(val), 'Expected a defined non-null value, got {0}', val] } else { args = [isSomething(val)].concat( Array.prototype.slice.call(arguments, 1)) } assert.apply(args) } /** * Asserts that &lt;code&gt;val&lt;/code&gt; is a number. * * @param {Anything} value the value to check * @param {String} [msg] message if the assertion fails * @param {...object} [values] values used in &lt;code&gt;msg&lt;/code&gt; placeholders * @summary Asserts that &lt;code&gt;val&lt;/code&gt; is a number. * @function * @name assertNumber * @static */ export function assertNumber(val) { let args = [] if (arguments.length &lt;= 1) { args = [isSomething(val), 'Expected a number, got {0}', val] } else { args = [isSomething(val)] .concat(Array.prototype.slice.call(arguments, 1)) } assert.apply(args) } /** * Returns true if &lt;code&gt;val&lt;/code&gt; is defined. * * @param {any} value the value to check * @summary Returns true if &lt;code&gt;val&lt;/code&gt; is defined. * @return {boolean} true if &lt;code&gt;val&lt;/code&gt; is defined * @function * @name isDef * @static */ export function isDef(val) { return val !== undefined } /** * Returns true if &lt;code&gt;val&lt;/code&gt; is a number. * * @param {any} value the value to check * @summary Returns true if &lt;code&gt;val&lt;/code&gt; is a number. * @return {boolean} true if &lt;code&gt;val&lt;/code&gt; is a number * @function * @name isNumber * @static */ export function isNumber(val) { return typeof val === 'number' } /** * Returns true if &lt;code&gt;val&lt;/code&gt; is a string. * * @param {any} value the value to check * @return {boolean} true, if val is a string or a String object * @summary Returns true if &lt;code&gt;val&lt;/code&gt; is a string. * @function * @name isString * @static */ export function isString(val) { return isDef(val) &amp;&amp; (typeof val === 'string' || val instanceof String) } /** * Replies true if &lt;code&gt;val&lt;/code&gt; is an array. * * @param {anything} value the value to check * @return {boolean} true, if val is an array * @summary Replies true if &lt;code&gt;val&lt;/code&gt; is an array. * @function * @name isArray * @static */ export function isArray(val) { return Object.prototype.toString.call(val) === '[object Array]' } /** * Replies true if &lt;code&gt;val&lt;/code&gt; is a list of arguments. * * @param {anything} value the value to check * @return {boolean} true, if val is a list of arguments * @summary Replies true if &lt;code&gt;val&lt;/code&gt; is a list of arguments. * @function * @name isArguments * @static */ export function isArguments(val) { return Object.prototype.toString.call(val) === '[object Arguments]' } /** * Replies the number of properties owned by &lt;code&gt;o&lt;/code&gt;. * * @example * import {countProperties} from 'josm/util' * * let o = {p1: \"v1\", p2: \"v2\"} * let c = countProperties(o) // -&gt; 2 * * o = {} * c = countProperties(o) // -&gt; 0 * * o = undefined * c = countProperties(o) // -&gt; undefined * * @param {any} o the object * @summary Replies the number of properties owned by &lt;code&gt;o&lt;/code&gt;. * @return {number} the number of properties owned by &lt;code&gt;o&lt;/code&gt;. * @function * @name countProperties * @static */ export function countProperties(o) { if (isNothing(o)) return undefined if (!(typeof o === 'object')) return undefined let count = 0 for (const p in o) { if (hasProp(o, p)) count++ } return count } /** * Replies true, if &lt;code&gt;o&lt;/code&gt; owns at least one property. * * @example * import {hasProperties} from 'josm/util' * * let o = {p1: \"v1\", p2: \"v2\"} * let c = hasProperties(o) // -&gt; true * * o = {} * c = hasProperties(o) // -&gt; false * * o = undefined * c = hasProperties(o) // -&gt; false * * @param {any} o the object * @summary Replies true, if &lt;code&gt;o&lt;/code&gt; owns at least one property. * @return {boolean} true, if &lt;code&gt;o&lt;/code&gt; owns at least one property. * @function * @name hasProperties * @static */ export function hasProperties(o) { const count = countProperties(o) if (count === undefined) return false return count &gt; 0 } /** * Replies true, if f is a function. * * @param {any} f the object * @summary Replies true, if f is a function. * @return {boolean} true, if f is a function. * @function * @name isFunction * @static */ export function isFunction(f) { return typeof f === 'function' } /** * Mixes the properties of a list of objects into one object. * * @return a new object which includes the combined properties of the * argument objects * @return {object} * @summary Mixes the properties of a list of objects into one object. * @function * @name mix * @static */ export function mix() { const mixin = {} function copyProperties (other) { for (const p in other) { if (!hasProp(other, p)) continue mixin[p] = other[p] } } for (let i = 0; i &lt; arguments.length; i++) { const template = arguments[i] if (isNothing(template)) continue if (!(typeof template === 'object')) continue copyProperties(template) } return mixin } /** * Prints a message to stdout (including newline). * * Supports the same string templates as {@class java.text.MessageFormat}. * * @example * import * as util from 'josm/util' * * const myname = '...' * util.println('Hello world! My name is {0}', myname); * // escape meta characters like {, } or ' with a leading apostrophe * util.println(\" a pair of curly braces '{'}\"); * * @summary Prints a message to stdout (including newline). * @param {string} message * @param {...object} [args] * @function * @name println * @static */ export function println() { const args = Array.prototype.slice.call(arguments, 0) if (args.length === 0) return '' args[0] = args[0] + '' // make sure first argument is a string const System = Java.type('java.lang.System') System.out.println(MessageFormat.format(args[0], args.slice(1))) } /** * Prints a message to stdout (without newline). * * Supports the same string templates as {@class java.text.MessageFormat} * * @example * import * as util from 'josm/util' * * const myname = \"...\" * util.print('Hello world! My name is {0}', myname) * // escape meta characters like {, } or ' with a leading apostrophe * util.print(\" a pair of curly braces '{'}\") * * @summary Prints a message to stdout (without newline). * @param {string} message * @param {...object} [args] * @function * @name print * @static */ export function print() { const args = Array.prototype.slice.call(arguments, 0) if (args.length === 0) return '' args[0] = args[0] + '' // make sure first argument is a string const System = Java.type('java.lang.System') System.out.print(MessageFormat.format(args[0], args.slice(1))) } /** * Checks whether two java objects are either both null or equal by calling * o1.equals(o2). * * @param {object} o1 a java object or null * @param {object} o2 a java object or null * @summary Are two java objects equal. * @return {boolean} * @function * @name javaEquals * @static */ export function javaEquals(o1, o2) { assert(typeof o1 === 'object' &amp;&amp; typeof o1.equals === 'function') assert(typeof o2 === 'object' &amp;&amp; typeof o2.equals === 'function') if (o1 === null &amp;&amp; o2 === null) return true if (o1 === null &amp;&amp; o2 !== null) return false return o1.equals(o2) } /** * Iterates over the elements in &lt;code&gt;collection&lt;/code&gt; and invokes * &lt;code&gt;delegate()&lt;/code&gt; on each element. * * @param {array|arguments|java.util.Collection} collection the collection of * elements * @param {function} delegate the function to call on each elemennt * @summary Iteraties over the elements of a collection * @function * @name each * @static */ export function each(collection, delegate) { const Collection = Java.type('java.util.Collection') if (isNothing(collection) || isNothing(delegate)) return if (isArray(collection) || isArguments(collection)) { const len = collection.length for (let i = 0; i &lt; len; i++) delegate(collection[i]) } else if (collection instanceof Collection) { for (let it = collection.iterator(); it.hasNext();) delegate(it.next()) } else { assert(false, 'collection: unexpected type of value, got {0}\"', collection) } } /** * Replies true, if a value is an array, an arguments list or a Java * collection. * * @param {object} value the value to check * @summary Is a value a collection? * @return {boolean} true, if &lt;code&gt;value&lt;/code&gt; is a collection * @function * @name isCollection * @static */ export function isCollection(value) { const Collection = Java.type('java.util.Collection') return isArray(value) || isArguments(value) || value instanceof Collection } export function hasProp(o, name) { return Object.prototype.hasOwnProperty.call(o, name) } Ã— Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Modules Classes ChangesetApi Provides methods to open, close, get, update, etc. changesets on the OSM API server. Api Collection of static methods to download objects from and upload objects to the OSM server ApiConfig ApiConfig provides methods and properties for configuring API parameters NodeBuilder NodeBuilder helps to create OSM nodes RelationBuilder Helps to create Relations WayBuilder Helps to create OSM Ways ChangeCommand A command to change a collection of objects in a data layer. CommandHistory Accessor to the global command history DeleteCommand A command to delete a collection of objects in a data layer. AddCommand A command to add a collection of objects to a data layer DataSetUtil Build an utility object wrapping the dataset ds Layers MenuBar NodeBuilder Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Classes Classes ChangesetApi Provides methods to open, close, get, update, etc. changesets on the OSM API server. Api Collection of static methods to download objects from and upload objects to the OSM server ApiConfig ApiConfig provides methods and properties for configuring API parameters NodeBuilder NodeBuilder helps to create OSM nodes RelationBuilder Helps to create Relations WayBuilder Helps to create OSM Ways ChangeCommand A command to change a collection of objects in a data layer. CommandHistory Accessor to the global command history DeleteCommand A command to delete a collection of objects in a data layer. AddCommand A command to add a collection of objects to a data layer DataSetUtil Build an utility object wrapping the dataset ds Layers MenuBar NodeBuilder Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Ã— Search results Close "},"module-clipboard.html":{"id":"module-clipboard.html","title":"Module: clipboard","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: clipboard Provides access to the system clipboard Source: clipboard.mjs, line 1 Example import clipboard from 'clipboard' Members &lt;static&gt; text Set or get the clipboard content as text Set or get the clipboard content as text get Replies the clipboard content as text or undefined, if no clipboard content is available or if it can't be converted to a string. set Sets the clipboard content Properties: Name Type Description text string clipboard content as text Source: clipboard.mjs, line 15 Example import clipboard from 'clipboard' // set the clipboard content clipboard.text = 'Hello World!' Ã— Search results Close "},"module-josm.html":{"id":"module-josm.html","title":"Module: josm","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm This modules exports an objects with a set of properties and methods to access JOSMs internals. Source: josm.mjs, line 1 Example import josm from 'josm' Members &lt;static, readonly&gt; commands the global command history Replies the global command history. Use this object to undo/redo commands, or to clear the command history. Properties: Name Type Description commands module:josm/command.CommandHistory Source: josm.mjs, line 222 Example import josm from 'josm' // undoes the last command josm.commands.undo() // redoes two commands josm.commands.redo(2) &lt;static, readonly&gt; layers accessor for JOSM layers Replies the layers object. Properties: Name Type Description layers module:josm/layers the layers object Source: josm.mjs, line 44 Example import josm from 'josm' josm.alert('num layers: ' + josm.layers.length) // name of first layer josm.alert('num layers: ' + josm.layers.get(0).name) &lt;static, readonly&gt; menu Replies an accessor for JOSMs menu bar. Replies an accessor for JOSMs menu bar. Use this object to inspect or modify the menu bar, i.e. to add additional menu items. Properties: Name Type Description menu module:josm/ui/menu~MenuBar accessor for JOSMs menu bar Source: josm.mjs, line 250 &lt;static, readonly&gt; version JOSM version string Replies the current JOSM version string. Properties: Name Type Description version string the JOSM version Source: josm.mjs, line 24 Example import josm from 'josm' josm.alert(josm.version) Ã— Search results Close "},"module-josm_api.html":{"id":"module-josm_api.html","title":"Module: josm/api","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/api This module provides functions to retrieve data from and upload data to an OSM server. Source: josm/api.mjs, line 1 Example import {Api, ChangesetApi, ApiConfig} from 'josm/api' Classes ChangesetApi Provides methods to open, close, get, update, etc. changesets on the OSM API server. Api Collection of static methods to download objects from and upload objects to the OSM server ApiConfig ApiConfig provides methods and properties for configuring API parameters Methods &lt;static&gt; buildBounds(obj) Creates a Bounds instance from a javascript object. Parameters: Name Type Description obj object a javascript object Source: josm/api.mjs, line 63 Returns: the bounds Type Bounds Example import { buildBounds } from 'josm/api' const bounds1 = buildBounds({ minlat: 46.9479186, minlon: 7.4619484, maxlat: 46.9497642, maxlon: 7.4660683 }) const bounds2 = buildBounds({ min: {lat: 46.9479186, lon: 7.4619484}, max: {lat: 46.9497642, lon: 7.4660683} }) &lt;static&gt; buildLatLon(obj) Create a LatLon from a javascript object. Creates a LatLon from a javascript object. Parameters: Name Type Description obj object a javascript object with two number properties lat: and lon: Source: josm/api.mjs, line 29 Returns: Type LatLon Example import { buildLatLon } from 'josm/api' const pos = buildLatLon({lat: 1, lon: 2}); Ã— Search results Close "},"module-josm_api.ChangesetApi.html":{"id":"module-josm_api.ChangesetApi.html","title":"Class: ChangesetApi","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: ChangesetApi josm/api. ChangesetApi Provides methods to open, close, get, update, etc. changesets on the OSM API server. Note: this class doesn't provide a constructor. Methods and properties are static. new ChangesetApi() Provides methods to open, close, get, update, etc. changesets on the OSM API server. Source: josm/api.mjs, line 145 Example // load the changeset api import { ChangesetApi } from 'josm/api' // create a new changeset on the server const cs = ChangesetApi.open() Methods &lt;static&gt; close(changeset) Closes a changeset close(id) closes the changeset with the given id close(aChangeset) Xloses the changeset given by aChangeset Parameters: Name Type Description changeset number | Changeset the changeset to close Source: josm/api.mjs, line 240 Returns: the changeset Type Changeset Example import { ChangesetApi } from 'josm/api' import * as util from 'josm/util' const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // closs the changeset 12345 ChangesetApi.close(12345) // open a new changeset with the tags given by the supplied changeset const cs2 = new Changeset(12345) cs2 = ChangesetApi.close(cs2) util.assert(cs2.closed) // the changeset is now closed &lt;static&gt; get(changeset) Get a changeset from the server get(id) gets the changeset for the id. id must be a number &gt; 0. Parameters: Name Type Description changeset number | Changeset the changeset to get Source: josm/api.mjs, line 346 Returns: the changeset Type Changeset Example import { ChangesetApi } from 'josm/api' const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // get the changeset with id 12345 const cs1 = ChangesetApi.get(12345) // get the changeset with id 12345 lets cs2 = new Changeset(12345) cs2 = ChangesetApi.get(cs2) &lt;static&gt; open( [changeset]) Creates and opens a changeset open() - open a new changeset with no tags open(aChangeset) - open a new changeset with the tags from aChangeset open(anObject) - open a new changeset with the tags given by the properties of anObject Parameters: Name Type Argument Description changeset Changeset | object &lt;optional&gt; the changeset to open Source: josm/api.mjs, line 176 Returns: the changeset Type Changeset Example import { ChangesetApi } from 'josm/api' const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // open a new changeset with no tags const cs1 = ChangesetApi.open() // open a new changeset with the tags given by the supplied changeset const cs2 = new Changeset() cs2.put('comment', 'a test comment') cs2 = ChangesetApi.open(cs2) // open a new changeset with the tags given by the object const cs3 = ChangesetApi.open({comment: 'a test comment'}) &lt;static&gt; update(changeset) Updates a changeset update(aChangeset) Updates the changeset aChangeset Parameters: Name Type Description changeset Changeset the changeset to update Source: josm/api.mjs, line 292 Returns: the changeset Type Changeset Example import { ChangesetApi } from 'josm/api' const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // update the comment of a changeset const cs2 = new Changeset(12345) cs2.put('comment', 'an updated comment') cs2 = ChangesetApi.update(cs2) Ã— Search results Close "},"module-josm_api-Api.html":{"id":"module-josm_api-Api.html","title":"Class: Api","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: Api josm/api~ Api new Api() Collection of static methods to download objects from and upload objects to the OSM server Collection of static methods to download objects from and upload objects to the OSM server. Note: this class doesn't provide a constructor. Methods and properties are 'static'. Source: josm/api.mjs, line 379 Example // load the api import { Api } from 'josm/api' // download node 12345 const ds = Api.downloadObject(12345, 'node') Ã— Search results Close "},"module-josm_api-ApiConfig.html":{"id":"module-josm_api-ApiConfig.html","title":"Class: ApiConfig","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: ApiConfig josm/api~ ApiConfig new ApiConfig() ApiConfig provides methods and properties for configuring API parameters ApiConfig provides methods and properties for configuring API parameters. Source: josm/api.mjs, line 1002 Members &lt;static&gt; authMethod : string Get or set the authentication method. Get or set the authentication method. JOSM uses two authentication methods: basic Basic authentication with a username and a password oauth Authentication with the OAuth protocol. Type: string Properties: Name Type Description authMethod string the authentication method Source: josm/api.mjs, line 1106 Example import { ApiConfig } from 'josm/api' ApiConfig.authMethod // -&gt; the current authentication method // set OAuth as authentication method ApiConfig.authMethod = 'oauth' &lt;static, readonly&gt; defaultServerUrl Get the default server URL Get the default server URL. Properties: Name Type Description defaultServerUrl string the default server URL Source: josm/api.mjs, line 1076 Example import { ApiConfig } from 'josm/api' ApiConfig.defaultServerUrl // -&gt; the default server url &lt;static&gt; serverUrl Get or set the API server URL. Get or set the API server URL. get Replies the currently configured server URL or undefinend, if no server URL is configured. set Sets the current server URL. If null or undefined, removes the current configuration. Accepts either a string or a URL. Only accepts http or https URLs. Properties: Name Type Description serverUrl string Source: josm/api.mjs, line 1014 Example import { ApiConfig } from 'josm/api' ApiConfig.serverUrl // -&gt; the current server url // set a new API url ApiConfig.serverUrl = 'http://api06.dev.openstreetmap.org' Methods &lt;static&gt; getCredentials(authMethod, options) Gets the credentials. Gets the credentials, i.e. username and password for the basic authentication method. Named options host:string The host name of the API server for which credentials are retrieved. If missing, the host name of the currently configured OSM API server is used. Parameters: Name Type Description authMethod string the authentication method. Either basic or oauth options object (optional) additional options (see above) Source: josm/api.mjs, line 1148 Returns: the credentials Type object Example import { ApiConfig } from 'josm/api' // get username/password for the current OSM API server const credentials = ApiConfig.getCredentials('basic') &lt;static&gt; setCredentials(authMethod, credentials, options) Set the credentials. Set the credentials, i.e. username and password for the basic authentication method. Basic authentication credentials are either an instance of java.net.PasswordAuthentication or an object {user: string, password: string}. OAuth authentication credentials are either an instance of OAuthToken or an object {key: string, secret: string}. Named options host:string The host name of the API server for which credentials are set. If missing, the host name of the currently configured OSM API server is used. Parameters: Name Type Description authMethod string the authentication method. Either 'basic' or 'oauth'. credentials object | OAuthToken | PasswordAuthentication the credentials. options object (optional) additional options (see above) Source: josm/api.mjs, line 1251 Returns: the credentials Type object Example import { ApiConfig } from 'josm/api' // set the credentials ApiConfig.setCredentials('basic', { user:'test', password:'apassword' }) Ã— Search results Close "},"module-josm_builder.html":{"id":"module-josm_builder.html","title":"Module: josm/builder","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/builder Collection of builders for creating OSM nodes, ways and relations. Source: josm/builder.mjs, line 1 See: module:josm/builder/node module:josm/builder/way module:josm/builder/relation Example // josm/builder exports the NodeBuilder, WayBuilder, and RelationBuilder // from its sub modules import { NodeBuilder, WayBuilder, RelationBuilder } from 'josm/builder' Ã— Search results Close "},"module-josm_builder_node.html":{"id":"module-josm_builder_node.html","title":"Module: josm/builder/node","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/builder/node Source: josm/builder/node-builder.mjs, line 1 Classes NodeBuilder NodeBuilder helps to create OSM nodes Ã— Search results Close "},"module-josm_builder_node-NodeBuilder.html":{"id":"module-josm_builder_node-NodeBuilder.html","title":"Class: NodeBuilder","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: NodeBuilder josm/builder/node~ NodeBuilder new NodeBuilder( [ds]) NodeBuilder helps to create OSM nodes NodeBuilder helps to create OSM nodes. Methods of NodeBuilder can be used in a static and in an instance context. It isn't necessary to create an instance of NodeBuilder, unless it is configured with a DataSet, to which created nodes are added. Parameters: Name Type Argument Description ds DataSet &lt;optional&gt; the dataset which created objects are added to Source: josm/builder/node-builder.mjs, line 31 Example import {NodeBuilder} from 'josm/builder' const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() // create a node builder without and underlying dataset ... let nbuilder = new NodeBuilder() // ... with an underlying dataset .... nbuilder = new NodeBuilder(ds) // ... or using this factory method nbuilder = NodeBuilder.forDataSet(ds) // create a new local node at position (0,0) without tags const n1 = NodeBuilder.create() // create a new global node at a specific position with tags const n2 = NodeBuilder.withPosition(1,1).withTags({name: 'test'}).create(1) // create a new proxy for a global node // (an 'incomplete' node in JOSM terminology) const n3 = NodeBuilder.createProxy(2) Ã— Search results Close "},"module-josm_builder_relation.html":{"id":"module-josm_builder_relation.html","title":"Module: josm/builder/relation","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/builder/relation Source: josm/builder/relation-builder.mjs, line 1 Classes RelationBuilder Helps to create Relations Ã— Search results Close "},"module-josm_builder_relation-RelationBuilder.html":{"id":"module-josm_builder_relation-RelationBuilder.html","title":"Class: RelationBuilder","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: RelationBuilder josm/builder/relation~ RelationBuilder new RelationBuilder(ds) Helps to create Relations RelationBuilder helps to create OSM Relations. Methods of RelationBuilder can be used in a static and in an instance context. It isn't necessary to create an instance of RelationBuilder, unless it is configured with a DataSet, which created ways are added to. Parameters: Name Type Description ds DataSet (optional) a JOSM dataset which created ways are added to. If missing, the created ways aren't added to a dataset. Source: josm/builder/relation-builder.mjs, line 36 Example import {RelationBuilder} from 'josm/builder' const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() // create a relation builder without and underlying dataset ... let rbuilder = new RelationBuilder() // ... with an underlying dataset ... rbuilder = new RelationBuilder(ds) // ... or using this factory method rbuilder = RelationBuilder.forDataSet(ds) // create a new local relation const r1 = rbuilder.create() // create a new global way const r2 = rbuilder.withTags({route: 'bicycle'}).create(1111) // create a new proxy for a global relation // (an 'incomplete' node in JOSM terminology) const r3 = rbuilder.createProxy(2222) Ã— Search results Close "},"module-josm_builder_way.html":{"id":"module-josm_builder_way.html","title":"Module: josm/builder/way","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/builder/way Source: josm/builder/way-builder.mjs, line 1 Classes WayBuilder Helps to create OSM Ways Ã— Search results Close "},"module-josm_builder_way-WayBuilder.html":{"id":"module-josm_builder_way-WayBuilder.html","title":"Class: WayBuilder","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: WayBuilder josm/builder/way~ WayBuilder new WayBuilder( [ds]) Helps to create OSM Ways WayBuilder helps to create OSM Ways. Methods of WayBuilder can be used in a static and in an instance context. It isn't necessary to create an instance of WayBuilder, unless it is configured with a DataSet, to which created ways are added. Parameters: Name Type Argument Description ds DataSet &lt;optional&gt; a JOSM dataset to which created ways are added. If missing, the created ways aren't added to a dataset. Source: josm/builder/way-builder.mjs, line 36 Example import {WayBuilder} from 'josm/builder' const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() // create a way builder without and underlying dataset ... let wbuilder = new WayBuilder() // ... with an underlying dataset .... wbuilder = new WayBuilder(ds) // ... or using this factory method wbuilder = WayBuilder.forDataSet(ds) // create a new local way const w1 = wbuilder.create() // create a new global way const w2 = wbuilder.withTags({highway: 'residential'}).create(1111) // create a new proxy for a global way // (an 'incomplete' node in JOSM terminology) const w3 = wbuilder.createProxy(2222) Ã— Search results Close "},"module-josm_command.html":{"id":"module-josm_command.html","title":"Module: josm/command","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/command A collection of functions to create commands which can be applied, undone and redone on OsmDataLayers. Source: josm/command.mjs, line 1 Example import {AddCommand} from 'josm/command' Classes ChangeCommand A command to change a collection of objects in a data layer. CommandHistory Accessor to the global command history DeleteCommand A command to delete a collection of objects in a data layer. AddCommand A command to add a collection of objects to a data layer Methods &lt;static&gt; add(primitives) Creates a command to add a collection of objects Creates a command to add a collection of objects to a data layer. Signatures add(obj, obj, ...) obj are Nodes, Ways, or Relationss. Or javascript array or Java collections thereof. Parameters: Name Type Argument Description primitives primitive | Array.&lt;primitive&gt; | Collection &lt;repeatable&gt; the primitives to add Source: josm/command.mjs, line 127 Returns: the command object Type module:josm/command.AddCommand Example import {add} from 'josm/command' import layers from 'josm/layer' import {NodeBuilder} from 'josm/builder' const layer = layers.get('Data Layer 1') // add two nodes add(NodeBuilder.create(), NodeBuilder.create()).applyTo(layer) * &lt;static&gt; change() Creates a command to change a collection of objects Creates a command to change a collection of objects in a data layer. Signatures change(obj,obj,..., options) obj are Nodes, Ways, or Relations. Or javascript array or Java collections thereof. The mandatory last argument is an object with named parameters. It accepts the following named parameters: lat:number Changes the latitude of the target nodes to lat. lon:number Changes the longitude of the target nodes to lon. pos: LatLon|object Changes the position of the target nodes to pos. pos is either a LatLon or an object {lat:..., lon:...} tags:Map|object Changes the tags of the target objects to tags. nodes:List|array Changes the nodes of the target way sto nodes. members:List|array Changes the nodes of the target relations to members. Source: josm/command.mjs, line 391 Returns: the change command object Type module:josm/command.ChangeCommand Example import {buildChangeCommand} from 'josm/command' import layers from 'josm/layers' const layer = layers.get(\"Data Layer 1\") // change the position of a node buildChangeCommand(n1, {lat: 123.45, lon: 44.234}).applyTo(layer) // change the tags of a collection of primitives buildChangeCommand(n1, n3, w1, r1, { tags: {'mycustomtag': 'value'} }).applyTo(layer) &lt;static&gt; combineSelectedWays() Combines the currently selected ways. Combines the currently selected ways in the active layer into one resulting way. Returns without effect if there is no active layer the active layer is not a data layer there are less than two selected ways in the active layer Reuses the logic behind the JOSM standard menu entry Tools-&gt;Combine Ways. If invoked from a script, this may trigger modal dialogs which are presented to the user, in particular if the direction of the ways has to be reversed because otherwise they could not be combined. Source: josm/command.mjs, line 632 Example import {combineSelectedWays} from 'josm/command' import layers from 'josm/layer' const ds = layers.activeLayer.data combineSelectedWays(ways) &lt;static&gt; combineWays(ways, ways) Combines two or more ways into one resulting way. Combines two or more ways into one resulting way. Reuses the logic behind the JOSM standard menu entry Tools-&gt;Combine Ways. If invoked from a script, this may trigger modal dialogs which are presented to the user, in particular if the direction of the ways has to be reversed because otherwise they could not be combined. Parameters: Name Type Description ways the ways to be combined ways Way | array the ways to be combined Source: josm/command.mjs, line 577 Example import {combineWays} from 'josm/command' import layers from 'josm/layer' const ds = layers.activeLayer.data const ways = [ds.way(1), ds.way(2), ds.way(3)] // pass in an array ... combineWays(ways) // ... or the individual ways ... combineWays(ds.way(1), ds.way(2), ds.way(3)) // ... or any combination thereof. &lt;static&gt; delete(primitives) Creates a command to delete a collection of objects Creates a command to delete a collection of objects in a data layer. Signatures delete(obj,obj,..., ?options) obj are Nodes, Ways, or Relationss. Or javascript array or Java collections thereof. Parameters: Name Type Argument Description primitives primitive | Array.&lt;primitive&gt; | Collection &lt;repeatable&gt; the primitives to delete Source: josm/command.mjs, line 203 Returns: the command object Type module:josm/command.DeleteCommand Example import {buildDeleteCommand} from 'josm/command' import layers from 'josm/layer' import {NodeBuilder} from 'josm/builder' const layer = layers.get('Data Layer 1') // delete two nodes buildDeleteCommand(NodeBuilder.create(),NodeBuilder.create()).applyTo(layer) * Ã— Search results Close "},"module-josm_command.ChangeCommand.html":{"id":"module-josm_command.ChangeCommand.html","title":"Class: ChangeCommand","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: ChangeCommand josm/command. ChangeCommand new ChangeCommand(objs, change) A command to change a collection of objects in a data layer. A command to change a collection of objects in a data layer. Parameters: Name Type Description objs Collection | array the objects to change change Change the change specification Source: josm/command.mjs, line 355 Methods applyTo(layer) Applies the command to a layer. Applies the command to a layer. Parameters: Name Type Description layer OsmDataLayer the data layer Source: josm/command.mjs, line 360 createJOSMCommand(layer) Creates the internal JOSM command for this command Creates the internal JOSM command for this command Parameters: Name Type Description layer OsmDataLayer the data layer Source: josm/command.mjs, line 372 Returns: the command object Type Command Ã— Search results Close "},"module-josm_command.CommandHistory.html":{"id":"module-josm_command.CommandHistory.html","title":"Class: CommandHistory","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: CommandHistory josm/command. CommandHistory new CommandHistory() Accessor to the global command history Accessor to the global command history. Provides static methods to redo and undo commands. Source: josm/command.mjs, line 490 Methods &lt;static&gt; clear( [layer]) Removes commands in the command history Removes commands in the command history, either all commands, or only the commands applied to a specific layer. Parameters: Name Type Argument Description layer Layer &lt;optional&gt; the reference layer. Only commands applied to this layer are removed. Default if missing: all commands are removed. Source: josm/command.mjs, line 540 &lt;static&gt; redo( [depth]) Redoes the last depth commands. Redoes the last depth commands. Parameters: Name Type Argument Default Description depth number &lt;optional&gt; 1 the number of commands to be redone. Source: josm/command.mjs, line 516 &lt;static&gt; undo( [depth]) Undoes the last depth commands. Undoes the last depth commands. Parameters: Name Type Argument Default Description depth number &lt;optional&gt; 1 the number of commands to be undone Source: josm/command.mjs, line 492 Ã— Search results Close "},"module-josm_command.DeleteCommand.html":{"id":"module-josm_command.DeleteCommand.html","title":"Class: DeleteCommand","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: DeleteCommand josm/command. DeleteCommand new DeleteCommand(objs, objs) A command to delete a collection of objects in a data layer. A command to delete a collection of objects in a data layer. Parameters: Name Type Description objs Collection | array the objects to add objs Collection | array the objects to add Source: josm/command.mjs, line 168 Methods applyTo(layer) Applies the command to a layer. Applies the command to a layer. Parameters: Name Type Description layer OsmDataLayer the data layer Source: josm/command.mjs, line 172 createJOSMCommand(layer) Creates the internal JOSM command for this command Creates the internal JOSM command for this command Parameters: Name Type Description layer OsmDataLayer the data layer Source: josm/command.mjs, line 184 Returns: the command object Type Command Ã— Search results Close "},"module-josm_command-AddCommand.html":{"id":"module-josm_command-AddCommand.html","title":"Class: AddCommand","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: AddCommand josm/command~ AddCommand new AddCommand(objs) A command to add a collection of objects to a data layer A command to add a collection of objects to a data layer. Parameters: Name Type Description objs Collection | array the objects to add Source: josm/command.mjs, line 78 Ã— Search results Close "},"module-josm_ds.html":{"id":"module-josm_ds.html","title":"Module: josm/ds","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/ds Provides utitly methods for data sets Source: josm/ds.mjs, line 1 Classes DataSetUtil Build an utility object wrapping the dataset ds Methods &lt;static&gt; buildId(args) Creates an ID for an OSM primitive. Signatures buildId(id, type) Replies an object given by its unique numeric id and a type. The type is either a string node, way, or relation, or one of the symbols OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. buildId(id) Replies an object given an ID. id is either an instance of PrimitiveId or an object with the properties id and type, i.e. {id: 1234, type: 'node'}. Parameters: Name Type Description args see description Source: josm/ds.mjs, line 110 Example import { buildId, OsmPrimitiveType} from 'josm/ds' // build a node id const id1 = buildId(1234, 'node') // build a way id const id2 = buildId(3333, OsmPrimitiveType.WAY) // build a relation id const id3 = buildId({id: 5423, type: 'relation'}) Ã— Search results Close "},"module-josm_ds.DataSetUtil.html":{"id":"module-josm_ds.DataSetUtil.html","title":"Class: DataSetUtil","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: DataSetUtil josm/ds. DataSetUtil DataSetUtil provides methods to build OSM primitive IDs and to manipulate data in a DataSet. new DataSetUtil( [ds]) Build an utility object wrapping the dataset ds Creates an instance of DataSetUtil for a given DataSet Parameters: Name Type Argument Description ds DataSet &lt;optional&gt; the dataset. Creates a new dataset if missing Source: josm/ds.mjs, line 193 Example import { DataSetUtil, DataSet } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) Members &lt;readonly&gt; nodeBuilder Replies a node builder to create Nodes in this dataset. Properties: Name Type Description nodeBuilder module:josm/builder~NodeBuilder Source: josm/ds.mjs, line 447 Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) const n = dsutil.nodeBuilder .withId(1234,4567) .withTags({amenity: 'restaurant'}) .create() dsutil.has(n) &lt;readonly&gt; relationBuilder Replies a relation builder to create relations in this dataset. Properties: Name Type Description relationBuilder module:josm/builder~RelationBuilder Source: josm/ds.mjs, line 486 Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) const r = dsutil.relationBuilder() .withId(8765,1234) .create({tags: {type: 'network'}}) ds.has(r) // --&gt; true &lt;readonly&gt; wayBuilder Replies a way builder to create ways in this dataset. Properties: Name Type Description wayBuilder module:josm/builder~WayBuilder Source: josm/ds.mjs, line 467 Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) const nb = dsutil.nodeBuilder() const w = dsutil.wayBuilder() .withNodes(nb.create(), nb.create()) .create(1234, {tags: {highway: \"residential\"}}) dsutil.has(w) Methods &lt;static&gt; load(source [, options]) Loads a dataset from a file. Derives the format of the file from the file suffix, unless the named option options.format is set. options can contain the following named options: format one of the strings osm (Open Street Map XML data), osc (Open Street Map change format), or osm.gz (Open Street Map XML data, compressed with gzip). The format is normalized: white space is removed and it is converted to lower case. Parameters: Name Type Argument Description source string | File the data source options object &lt;optional&gt; optional named parameters Source: josm/ds.mjs, line 520 Returns: the data set util with the loaded data set Type module:josm/ds~DataSetUtil Example import { DataSetUtil } from 'josm/ds' // loads an OSM file DataSetUtil.load('/path/to/my/file.osm') // loads an OSM file, explicity passing in the format DataSetUtil.load('/path/to/my/file.any-suffix', { format 'osm' }) batch(delegate) Run a sequence of operations against the dataset in \"batch mode\". Listeners to data set events are only notified at the end of the batch. Parameters: Name Type Description delegate function the function implementing the batch process. Ignored if null or undefined. Source: josm/ds.mjs, line 331 Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) // creates and adds two nodes and a way in batch operation // to the dataset dsutil.batch(() =&gt; { const n1 = dsutil.nodeBuilder().create() const n2 = dsutil.nodeBuilder().create() dsutil.wayBuilder().withNodes(n1,n2).create() }) get(args) Replies an OSM object from the dataset, or undefined, if no such object exists. Signatures get(id, type) Replies an object given by its unique numeric id and a type. The type is either a string \"node\", \"way\", or \"relation\", or one of the symbols OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. get(id) Replies an object given an ID. id is either an instance of PrimitiveId or an object with the properties id and type, i.e. {id: 1234, type: \"node\"}. Parameters: Name Type Description args see description Source: josm/ds.mjs, line 254 Example import { buildId , DataSetUtil, DataSet, OsmPrimitiveType} from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) // get a node const n1 = dsutil.get(1234, 'node') // get a way const w1 = dsutil.get(3333, OsmPrimitiveType.WAY) // get a relation const r1 = dsutil.get({id: 5423, type: 'relation'}) // pass in a SimplePrimitiveId const id = buildId(-5, OsmPrimitiveType.NODE) const n2 = dsutil.get(id) // pass in a primitive to get it const w2 = dsutil.wayBuilder().create(987) const w3 = dsutil.get(w2) node(id) Replies the node with id id, or null. Parameters: Name Type Description id number the unique numeric id. Must not be 0. Source: josm/ds.mjs, line 272 Returns: the node Type Node Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) // get a node const n = dsutil.node(1234) query(expression [, options]) Queries the dataset Signatures query(josmSearchExpression,?options) Queries the dataset using the JOSM search expression josmSearchExpression. josmSearchExpression is a string as you would enter it in the JOSM search dialog. options is an (optional) object with named parameters, see below. query(predicate,?options) Queries the dataset using a javascript predicate function predicate. predicate is a javascript function which accepts a object as parameter and replies true, when it matches for the object ans false otherwise. options is an (optional) object with named parameters, see below. The parameter options consist of the following (optional) named parameters: allElements : boolean (Deprecated parameter names: all) If true, searches all objects in the dataset. If false, ignores incomplete or deleted objects. Default: false. caseSensitive : boolean Only applicable for searches with a JOSM search expression. If true, searches case sensitive. If false, searches case insensitive. Default: false. regexSearch : boolean (Deprecated parameter names: withRegexp, regexpSearch) Only applicable for searches with a JOSM search expression. If true, the search expression contains regular expressions. If false, it includes only plain strings for searching. Default: false. mapCSSSearch Only applies for searches with a JOSM search expression. Default: false. Parameters: Name Type Argument Description expression string | function the match expression options object &lt;optional&gt; additional named parameters Source: josm/ds.mjs, line 773 Example import { DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil() // add or load primitives to query // ... // query restaurants const result1 = dsutil.query('amenity=restaurant') // query all nodes with a type query const result2 = dsutil.query('type:node') // query using a custom predicate - all primitives // with exactly two tags const result3 = dsutil.query((primitive) =&gt; { primitive.getKeys().size() === 2 }) relation(id) Replies the relation with id id. Parameters: Name Type Description id number the unique numeric id. Must not be 0. Source: josm/ds.mjs, line 307 Returns: the relation Type Relation Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) // get a relation const r = dsutil.relation(1234) remove(args) Removes objects from the dataset Signatures remove(id, type) Removes a single object given by its unique numeric ID (nid) and a type. The type is either a string \"node\", \"way\", or \"relation\", or one of the symbols OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. remove(id, id, ...) Removes a collection of objects given by the ids. id is either an instance of PrimitiveId or an object with the properties id and type, i.e. {id: 1234, type: \"node\"}. null and undefined are ignored. remove(array|collection) Removes a collection of objects given by the an array or a java.util.Collection of ids. The collection elemeents are either instances of PrimitiveId or an object with the properties id and type, i.e. {id: 1234, type: \"node\"}. null or undefined elements are ignored. Parameters: Name Type Description args see description Source: josm/ds.mjs, line 404 Example import { DataSet, DataSetUtil, OsmPrimitiveType, buildId} from 'josm/ds' const HashSet = Java.type('java.util.HashSet') const dsutil = new DataSetUtil(new DataSet()) // remove a node with a global id dsutil.remove(1234, 'node') // remove a node and a way const id1 = buildId(1234, 'node') const id2 = buildId(3333, OsmPrimitiveType.WAY) dsutil.remove(id1, id2) // remove a relation and a node dsutil.remove({id: 1234, type: 'relation'}, id1) // remove an array of nodes dsutil.remove([id1,id2]) // remove a set of primitives const ids = new HashSet() ids.add(id1) ids.add(id1) dsutil.remove(ids) save(target [, options]) Saves the dataset to a file (in OSM XML format). options can contain the following named options: version: string the value of the attribute version in the OSM file header. Default: \"0.6\" changeset: Changeset the changeset whose id is included in the attribute changeset on every OSM object. If undefined, includes the individual changeset attribute of the OSM object. Default: undefined osmConform: bool if true, prevents modification attributes to be written Default: true Parameters: Name Type Argument Description target string | File the target file options object &lt;optional&gt; optional named parameters Source: josm/ds.mjs, line 641 Example import { DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil() // create a node in the dataset dsutil.nodeBuilder() .withId(1, 1) .withPosition({ lat: 1.0, lon: 1.0 }) .create() // save the dataset dsutil.save('/tmp/my-dataset.osm') way(id) Replies the way with id id, or null Parameters: Name Type Description id number the unique numeric id. Must not be 0. Source: josm/ds.mjs, line 289 Returns: the way Type Way Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) // get a way const w = dsutil.way(1234) Ã— Search results Close "},"module-josm_layers.html":{"id":"module-josm_layers.html","title":"Module: josm/layers","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/layers Provides access to the JOSM layers. Source: josm/layers.mjs, line 1 Classes Layers Members &lt;inner, constant&gt; layers the singleton instance of the layers class Source: josm/layers.mjs, line 304 Ã— Search results Close "},"module-josm_layers.Layers.html":{"id":"module-josm_layers.Layers.html","title":"Class: Layers","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: Layers josm/layers. Layers Provides access to JOSM layers. new Layers() Source: josm/layers.mjs, line 20 Members activeLayer : Layer Set or get the active layer. get Replies the active layer or undefined. set Assign either an existing Layer, the name of a layer as string, or a layer index as number. Type: Layer Source: josm/layers.mjs, line 46 &lt;readonly&gt; length : number Replies the number of currently open layers. Type: number Source: josm/layers.mjs, line 28 Methods add(obj) Adds a layer. Either pass in a layer object or a data set. In the later case, an OsmDataLayer is automatically created. Parameters: Name Type Description obj Layer | DataSet a layer to add, or a dataset. Ignored if null or undefined. Source: josm/layers.mjs, line 175 Returns: the added layer Type Layer Example import layers from 'josm/layers' const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const dataLayer = new OsmDataLayer(new DataSet(), null, null); // add a layer ... layers.add(dataLayer) // or add a dataset, which will create a data layer const ds = new DataSet() layer.add(ds) addDataLayer(args) Creates and adds a new data layer. The new layer becomes the new edit layer. Signatures addDataLayer() create data layer with a new dataset and default name addDataLayer(ds) create data layer with dataset ds and default name addDataLayer(name) create data layer with a new dataset and name name addDataLayer({name: ..., ds: ...}) create data layer with a new dataset and name name Parameters: Name Type Description args string | DataSet | object see description Source: josm/layers.mjs, line 267 Returns: the added layer Type OsmDataLayer Example import josm from 'josm' const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') // creates a new data layer const l1 = josm.layers.addDataLayer() // creates a new data layer with name 'test' const l2 = josm.layers.addDataLayer('test') // creates a new data layer for the dataset ds const ds = new DataSet() const l3 = josm.layers.addDataLayer(ds) get(key) Replies one of the layers given a key. If key is a number, replies the layer with index key, or undefined, if no layer for this index exists. If key is a string, replies the first layer whose name is identical to key (case insensitive, without leading/trailing whitespace), or undefined, if no layer with such a name exists. Parameters: Name Type Description key number | string the key to retrieve the layer Source: josm/layers.mjs, line 106 Returns: Type Layer Example import layers from 'josm/layers' // get the first layer const layer1 = layers.get(0) // get the first layer with name \"data layer\" const layer2 = layers.get('data layer') has(layer) Checks whether layer is a currently registered layer. Parameters: Name Type Description layer Layer | string | number a layer, a layer name, or a layer index Source: josm/layers.mjs, line 135 Returns: true, if the layer or at least one layer with the given name exists. False, otherwise. Type boolean Example import layers from 'josm/layers' // is there a layer with name \"my layer\"? let b = layers.has('my layer') // is there a layer at index position 2 b = layers.has(2) // is there a specific layer? let l = layers.get(0) b = layers.has(l) remove(key) Removes a layer with the given key. If key is a Number, removes the layer with the index key. If the index doesn't isn't a valid layer index, nothing is removed. If key is a string, removes the layer with the name key. Leading and trailing white space is removed, matching is a case-insensitive sub-string match. Parameters: Name Type Description key number | string indicates the layer to remove Source: josm/layers.mjs, line 222 Example import josm from 'josm' // remove the first layer josm.layers.remove(0) // remove the first layer matching with the supplied name josm.layers.remove('myLayerName') Ã— Search results Close "},"module-josm_scriptingconsole.html":{"id":"module-josm_scriptingconsole.html","title":"Module: josm/scriptingconsole","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/scriptingconsole Provides a set of functions to write to the built-in scripting console. Source: josm/scriptingconsole.mjs, line 1 Methods &lt;static&gt; clear() Clears the scripting console. Clears the scripting console. Source: josm/scriptingconsole.mjs, line 90 Example import * as console from 'josm/scriptingconsole' console.clear() &lt;static&gt; hide() Hides the scripting console Hides the scripting console Source: josm/scriptingconsole.mjs, line 123 Example import * as console from 'josm/scriptingconsole' console.hide() &lt;static&gt; print(message [, values]) Prints a string to the console Prints a string to the console Parameters: Name Type Argument Description message string the message values object &lt;optional&gt; &lt;repeatable&gt; optional values Source: josm/scriptingconsole.mjs, line 18 Example import {print} from 'josm/scriptingconsole' print('Hello world!') // or use formatting print('Hello world! My name is {0}', 'foo') &lt;static&gt; println(message [, values]) Prints a string to the console, including newline Prints a string to the console, including newline Parameters: Name Type Argument Description message string the message values object &lt;optional&gt; &lt;repeatable&gt; optional values Source: josm/scriptingconsole.mjs, line 54 Example import {println} from 'josm/scriptingconsole' println('Hello world!') // or use formatting ('Hello world! My name is {0}', 'foo') &lt;static&gt; show() Shows the scripting console Shows the scripting console Source: josm/scriptingconsole.mjs, line 107 Example import * as console from 'josm/scriptingconsole' console.show() &lt;static&gt; toggle() Toggles the visibility of the scripting console Toggles the visibility of the scripting console Source: josm/scriptingconsole.mjs, line 139 Example import * as console from 'josm/scriptingconsole' console.toggle() Ã— Search results Close "},"module-josm_ui_menu.html":{"id":"module-josm_ui_menu.html","title":"Module: josm/ui/menu","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/ui/menu Provides a collection of namespaces, classes and functions to work with JOSMs menu system. Source: josm/ui/menu.mjs, line 1 Classes MenuBar Ã— Search results Close "},"module-josm_ui_menu-MenuBar.html":{"id":"module-josm_ui_menu-MenuBar.html","title":"Class: MenuBar","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: MenuBar josm/ui/menu~ MenuBar new MenuBar() Represents JOSMs global menu bar. Source: josm/ui/menu.mjs, line 13 Members &lt;static&gt; JSAction JSAction is an action for which a menu item or a toolbar item can be added to JOSMs menu or JOSMs toolbar respectively. This is just a shortcut for the Java class JSAction. The constructor accepts an object with the following optional named parameters. name:string The optional name of the action. Default: an auto generated name. tooltip:string The optional tooltip of the action. Default: empty string. iconName:string The optional name of an icon. Default: null. toolbarId:string The optional name of the tooblar to which this action is added. Note that it isn't added automatically, when this action is created. Default: null. onExecute:function The (optional) function which is called when the action is executed. Default: null. onInitEnabled:function The (optional) function which is called when the enabled state of the function is evaluated the first time. Default: null. onUpdateEnabled:function The (optional) function which is called when the enabled state of the function is reevaluated, in particular, when layer change events or selection change events occur. Default: null. Properties: Name Type Description JSAction org.openstreetmap.josm.plugins.scripting.graalvm.JSAction Source: josm/ui/menu.mjs, line 120 Example import {JSAction} from 'josm/ui/menu' import * as util from 'josm/util' import josm from 'josm' const JMenuItem = Java.type('javax.swing.JMenuItem') // create the menu action const helloWorldAction = new JSAction({ name: \"My Action\", iconName: 'myicon', toolbarId: 'myToolbarId', tooltip: \"This is my action\", onInitEnabled: function() { util.println('onInitEnabled: entering ...') }, onUpdateEnabled: function() { util.println('onUpdateEnabled: entering ...') }, onExecute: function() { util.println('Hello World!') } }) // register a new menu item in the file menu const fileMenu = josm.menu.get('file') fileMenu.addSeparator() fileMenu.add(new JMenuItem(helloWorldAction)) &lt;static&gt; length the number of menus in the JOSM menu bar Replies the number of menus in the JOSM menu bar. Properties: Name Type Description length number the number of menues Source: josm/ui/menu.mjs, line 21 Example import josm from 'josm' // display the number of menus josm.alert(josm.menu.length) &lt;static, readonly&gt; menuNames Replies an array with the symbolic menu names. Replies an array with the symbolic menu names. Properties: Name Type Description menuNames array the names of the menues in the menu bar Source: josm/ui/menu.mjs, line 102 Methods get(key) Replies a menu in the JOSM menu bar. Replies a menu in the JOSM menu bar. key is either a numberic index or one of the following symbolic names as string: file edit view tools presets imagery window help Parameters: Name Type Description key number | string the key denoting the menu Source: josm/ui/menu.mjs, line 43 Returns: the menu Type JMenu Example import josm from 'josm' // get the edit menu with a numeric index const editmenu = josm.menu.get(1) // get the file menu with a symbolic name const filemenu = josm.menu.get('file') Ã— Search results Close "},"module-josm_unittest.html":{"id":"module-josm_unittest.html","title":"Module: josm/unittest","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/unittest Source: josm/unittest.mjs, line 1 Ã— Search results Close "},"module-josm_util.html":{"id":"module-josm_util.html","title":"Module: josm/util","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Module: josm/util Provides a set of static utility functions. Source: josm/util.mjs, line 1 Methods &lt;static&gt; assert(condition [, message] [, values]) Assert a condition and throw an Error if the condition isn't met. Assert a condition and throw an Error if the condition isn't met. Usage: assert() Does nothing assert(cond) Checks the condition cond. If it is false, throws an Error. assert(cond, msg) Checks the condition cond. If it is false, throws an Error, whose description property is set to msg. assert(cond, msg, objs...) Checks the condition cond. If it is false, throws an Error, whose description property is set to the formatted message msg. Internally uses java.text.MessageFormat to format the message. Parameters: Name Type Argument Description condition boolean message string &lt;optional&gt; the message values object &lt;optional&gt; &lt;repeatable&gt; an optional list of values Source: josm/util.mjs, line 58 Example import {assert} from 'josm/util' // throws an Error assert(false) // throws an Error e, with e.description == \"My message\" assert(false, \"My message\") // throws an Error e, with e.description == \"My message: test\" assert(false, \"My message: {0}\", \"test\") &lt;static&gt; assertNumber(value [, msg] [, values]) Asserts that val is a number. Asserts that val is a number. Parameters: Name Type Argument Description value Anything the value to check msg String &lt;optional&gt; message if the assertion fails values object &lt;optional&gt; &lt;repeatable&gt; values used in msg placeholders Source: josm/util.mjs, line 169 &lt;static&gt; assertSomething(val [, msg] [, values]) Asserts that val is defined and non-null. Asserts that val is defined and non-null. Parameters: Name Type Argument Description val any the value to check msg string &lt;optional&gt; message if the assertion fails values object &lt;optional&gt; &lt;repeatable&gt; additional values used in msg placeholders Source: josm/util.mjs, line 136 Example import {assertSomething} from 'josm/util' assertSomething(null) // -&gt; throws an exception assertSomething(void 0) // -&gt; throws an exception assertSomting(\"test\") // -&gt; OK assertSomething(5) // -&gt; OK &lt;static&gt; countProperties(o) Replies the number of properties owned by o. Replies the number of properties owned by o. Parameters: Name Type Description o any the object Source: josm/util.mjs, line 262 Returns: the number of properties owned by o. Type number Example import {countProperties} from 'josm/util' let o = {p1: \"v1\", p2: \"v2\"} let c = countProperties(o) // -&gt; 2 o = {} c = countProperties(o) // -&gt; 0 o = undefined c = countProperties(o) // -&gt; undefined &lt;static&gt; each(collection, delegate) Iteraties over the elements of a collection Iterates over the elements in collection and invokes delegate() on each element. Parameters: Name Type Description collection array | arguments | Collection the collection of elements delegate function the function to call on each elemennt Source: josm/util.mjs, line 442 &lt;static&gt; hasProperties(o) Replies true, if o owns at least one property. Replies true, if o owns at least one property. Parameters: Name Type Description o any the object Source: josm/util.mjs, line 294 Returns: true, if o owns at least one property. Type boolean Example import {hasProperties} from 'josm/util' let o = {p1: \"v1\", p2: \"v2\"} let c = hasProperties(o) // -&gt; true o = {} c = hasProperties(o) // -&gt; false o = undefined c = hasProperties(o) // -&gt; false &lt;static&gt; isArguments(value) Replies true if val is a list of arguments. Replies true if val is a list of arguments. Parameters: Name Type Description value anything the value to check Source: josm/util.mjs, line 248 Returns: true, if val is a list of arguments Type boolean &lt;static&gt; isArray(value) Replies true if val is an array. Replies true if val is an array. Parameters: Name Type Description value anything the value to check Source: josm/util.mjs, line 234 Returns: true, if val is an array Type boolean &lt;static&gt; isCollection(value) Is a value a collection? Replies true, if a value is an array, an arguments list or a Java collection. Parameters: Name Type Description value object the value to check Source: josm/util.mjs, line 468 Returns: true, if value is a collection Type boolean &lt;static&gt; isDef(value) Returns true if val is defined. Returns true if val is defined. Parameters: Name Type Description value any the value to check Source: josm/util.mjs, line 191 Returns: true if val is defined Type boolean &lt;static&gt; isFunction(f) Replies true, if f is a function. Replies true, if f is a function. Parameters: Name Type Description f any the object Source: josm/util.mjs, line 322 Returns: true, if f is a function. Type boolean &lt;static&gt; isNumber(value) Returns true if val is a number. Returns true if val is a number. Parameters: Name Type Description value any the value to check Source: josm/util.mjs, line 205 Returns: true if val is a number Type boolean &lt;static&gt; isString(value) Returns true if val is a string. Returns true if val is a string. Parameters: Name Type Description value any the value to check Source: josm/util.mjs, line 219 Returns: true, if val is a string or a String object Type boolean &lt;static&gt; javaEquals(o1, o2) Are two java objects equal. Checks whether two java objects are either both null or equal by calling o1.equals(o2). Parameters: Name Type Description o1 object a java object or null o2 object a java object or null Source: josm/util.mjs, line 422 Returns: Type boolean &lt;static&gt; mix() Mixes the properties of a list of objects into one object. Mixes the properties of a list of objects into one object. Source: josm/util.mjs, line 336 Returns: a new object which includes the combined properties of the argument objects Type object &lt;static&gt; print(message [, args]) Prints a message to stdout (without newline). Prints a message to stdout (without newline). Supports the same string templates as MessageFormat Parameters: Name Type Argument Description message string args object &lt;optional&gt; &lt;repeatable&gt; Source: josm/util.mjs, line 394 Example import * as util from 'josm/util' const myname = \"...\" util.print('Hello world! My name is {0}', myname) // escape meta characters like {, } or ' with a leading apostrophe util.print(\" a pair of curly braces '{'}\") &lt;static&gt; println(message [, args]) Prints a message to stdout (including newline). Prints a message to stdout (including newline). Supports the same string templates as MessageFormat. Parameters: Name Type Argument Description message string args object &lt;optional&gt; &lt;repeatable&gt; Source: josm/util.mjs, line 366 Example import * as util from 'josm/util' const myname = '...' util.println('Hello world! My name is {0}', myname); // escape meta characters like {, } or ' with a leading apostrophe util.println(\" a pair of curly braces '{'}\"); &lt;inner&gt; isNothing(value) Checks whether a value is null or undefined. Checks whether a value is null or undefined. Parameters: Name Type Description value object the value to check Source: josm/util.mjs, line 12 Returns: false, if value is null or undefined; true, otherwise Type boolean &lt;inner&gt; isSomething(value) Checks whether a value is neither null nor undefined. Checks whether a value is neither null nor undefined. Parameters: Name Type Description value object the value to check Source: josm/util.mjs, line 25 Returns: false, if value is null or undefined; true, otherwise Type boolean &lt;inner&gt; trim(s) Trims leading and trailing whitespace from s. Trims leading and trailing whitespace from s. Replies s, if s is null or undefined. Any other value is converted to a string, then leading and trailing white space is removed. Parameters: Name Type Description s string the string to be trimmed Source: josm/util.mjs, line 38 Returns: Type string Ã— Search results Close "},"NodeBuilder.NodeBuilder.html":{"id":"NodeBuilder.NodeBuilder.html","title":"Class: NodeBuilder","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.ChangesetApijosm/api~Apijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/command~AddCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.NodeBuilder Class: NodeBuilder NodeBuilder new NodeBuilder(ds) Creates a new node builder. Parameters: Name Type Description ds DataSet (optional) the dataset, to which created objects are added Source: josm/builder/node-builder.mjs, line 68 Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
