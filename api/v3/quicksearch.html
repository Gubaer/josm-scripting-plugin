<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"clipboard.mjs.html":{"id":"clipboard.mjs.html","title":"Source: clipboard.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: clipboard.mjs /** * Provides access to the system clipboard * * @module clipboard * * @example * import clipboard from 'clipboard' * */ /* global Java */ const clipboard = {} export default clipboard /** * Set or get the clipboard content as text * * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;get&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies the clipboard content as text or &lt;code&gt;undefined&lt;/code&gt;, * if no clipboard content is available or if it can't be converted to a * string.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;set&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Sets the clipboard content&lt;/dd&gt; * &lt;/dl&gt; * * @example * import clipboard from 'clipboard' * // set the clipboard content * clipboard.text = 'Hello World!' * * @property {string} text clipboard content as text * @name text * @summary Set or get the clipboard content as text * @static */ Object.defineProperty(clipboard, 'text', { enumerable: true, get: function () { const Toolkit = Java.type('java.awt.Toolkit') const DataFlavor = Java.type('java.awt.datatransfer.DataFlavor') const transferable = Toolkit.getDefaultToolkit() .getSystemClipboard().getContents(null) try { if (transferable &amp;&amp; transferable.isDataFlavorSupported(DataFlavor.stringFlavor)) { return transferable.getTransferData(DataFlavor.stringFlavor) } } catch (e) { } return undefined }, set: function (value) { const StringSelection = Java.type('java.awt.datatransfer.StringSelection') const Toolkit = Java.type('java.awt.Toolkit') Toolkit.getDefaultToolkit().getSystemClipboard().setContents( new StringSelection(String(value || '')), null ) } }) Ã— Search results Close "},"josm.mjs.html":{"id":"josm.mjs.html","title":"Source: josm.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm.mjs /** * This modules exports an objects with a set of properties and methods * to access JOSMs internals. * * @example * import josm from 'josm' * * @module josm */ /* global Java */ const Version = Java.type('org.openstreetmap.josm.data.Version') const JOptionPane = Java.type('javax.swing.JOptionPane') const HelpAwareOptionPane = Java.type('org.openstreetmap.josm.gui.HelpAwareOptionPane') const MainApplication = Java.type('org.openstreetmap.josm.gui.MainApplication') import * as util from 'josm/util' import * as console from 'josm/scriptingconsole' import layers from 'josm/layers' import {MenuBar} from 'josm/ui/menu' import {CommandHistory} from 'josm/command' const josm = {} export default josm /** * Replies the current JOSM version string. * * @example * import josm from 'josm' * josm.alert(josm.version) * * @property {string} version the JOSM version * @readOnly * @static * @name version * @summary JOSM version string */ Object.defineProperty(josm, 'version', { enumerable: true, get: function () { return Version.getInstance().getVersionString() } }) /** * Replies the layers object. * * @example * import josm from 'josm' * josm.alert('num layers: ' + josm.layers.length) * * // name of first layer * josm.alert('num layers: ' + josm.layers.get(0).name) * * @readOnly * @name layers * @static * @property {module:josm/layers} layers the layers object * @summary accessor for JOSM layers */ Object.defineProperty(josm, 'layers', { enumerable: true, get: function () { return layers } }) /** * Displays an alert window with a message * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;alert(message)&lt;/code&gt;&lt;dt&gt; * &lt;dd class=\"param-desc\"&gt;Displays an information message with an OK button.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;alert(message, ?options)&lt;/code&gt;&lt;dt&gt; * &lt;dd class=\"param-desc\"&gt;Displays a message. The look and feel of the alert window depends on * the &lt;var&gt;options&lt;/var&gt;. The following options are supported: * &lt;dl&gt; * &lt;dt&gt;&lt;code&gt;title&lt;/code&gt;:string&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;(optional) the window title. A string is expected. Empty string * if missing.&lt;/dt&gt; * * &lt;dt class=\"param-desc\"&gt;&lt;code&gt;messageType&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;(optional) the message type. Use one of the following values: * &lt;ul&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.INFORMATION_MESSAGE, * \"info\",\"information\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.ERROR_MESSAGE, * \"error\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.WARNING_MESSAGE, * \"warning\", \"warn\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.QUESTION_MESSAGE, * \"question\"&lt;/li&gt; * &lt;li&gt;{@class javax.swing.JOptionPane}.PLAIN_MESSAGE, * \"plain\"&lt;/li&gt; * &lt;/ul&gt; * Default value is * {@class javax.swing.JOptionPane}.INFORMATION_MESSAGE. * String values are not case sensitive and leading and * trailing white space is removed. * &lt;/dd&gt; * &lt;/dl&gt; * &lt;/dd&gt; * &lt;/dl&gt; * * @example * import josm from 'josm' * * // display an information alert * josm.alert('Hello World!') * * // display an error alert * josm.alert('Got an error', { * title: 'Error Alert', * messageType: 'error' * }) * * @summary display a message * @param {string} message the message * @function * @static */ josm.alert = function () { const map = { information: JOptionPane.INFORMATION_MESSAGE, info: JOptionPane.INFORMATION_MESSAGE, error: JOptionPane.ERROR_MESSAGE, warning: JOptionPane.WARNING_MESSAGE, warn: JOptionPane.INFORMATION_MESSAGE, question: JOptionPane.QUESTION_MESSAGE, plain: JOptionPane.PLAIN_MESSAGE } function titleFromOptions (options) { return util.isString(options.title) ? options.title : '' } function messageTypeFromOptions (options) { if (util.isNumber(options.messageType)) { const mt = options.messageType for (const key in map) { if (!util.hasProp(map, key)) continue if (mt === map[key]) return mt } return JOptionPane.INFORMATION_MESSAGE } else if (util.isString(options.messageType)) { const opt = util.trim(options.messageType).toLowerCase() const ret = map[opt] return ret !== undefined ? ret : JOptionPane.INFORMATION_MESSAGE } return JOptionPane.INFORMATION_MESSAGE } switch (arguments.length) { case 0: return case 1: HelpAwareOptionPane.showOptionDialog(MainApplication.getMainFrame(), arguments[0], '', JOptionPane.INFORMATION_MESSAGE, null) return default: { if (typeof arguments[1] !== 'object') { HelpAwareOptionPane.showOptionDialog(MainApplication.getMainFrame(), arguments[0], '', JOptionPane.INFORMATION_MESSAGE, null) return } const title = titleFromOptions(arguments[1]) const messageType = messageTypeFromOptions(arguments[1]) HelpAwareOptionPane.showOptionDialog(MainApplication.getMainFrame(), arguments[0], title, messageType, null) } } } /** * Opens one or more files in JOSM. * * Accepts a variable number of files. Each argument is either a string * (a file name) or a {@class java.io.File}. * * Creates and opens layers in JOSM, depending on the kind of file opened: * * &lt;ul&gt; * &lt;li&gt;creates a data layer for data files&lt;/li&gt; * &lt;li&gt;creates a gpx layer for gpx files&lt;/li&gt; * &lt;li&gt;creates an image layer for a directory with images&lt;/li&gt; * &lt;li&gt;etc.&lt;/li&gt; * &lt;/ul&gt; * * @example * import josm from 'josm' * * // open a data file in a new data layer * josm.open('/my/data/file.osm') * * @summary Opens one or more files in JOSM * @param {...(java.io.File | string)} files files to open * @function * @static */ josm.open = function () { const OpenFileAction = Java.type('org.openstreetmap.josm.actions.OpenFileAction') const File = Java.type('java.io.File') const files = [] for (let i = 0; i &lt; arguments.length; i++) { const file = arguments[i] if (util.isNothing(file)) { continue } else if (util.isString(file)) { files.push(new File(file)) } else if (file instanceof File) { files.push(file) } else { util.assert(false, 'expected java.io.File or string, got {0}', file) } } // openFiles is async OpenFileAction.openFiles(files) } /** * Replies the global command history. * * * Use this object to undo/redo commands, or to clear the command * history. * * @example * import josm from 'josm' * * // undoes the last command * josm.commands.undo() * * // redoes two commands * josm.commands.redo(2) * * @readOnly * @name commands * @property {module:josm/command.CommandHistory} commands * @summary the global command history * @static */ Object.defineProperty(josm, 'commands', { enumerable: true, value: CommandHistory }) /** * Replies an accessor for JOSMs menu bar. * * Use this object to inspect or modify the menu bar, i.e. to add additional * menu items. * * @readOnly * @property {module:josm/ui/menu~MenuBar} menu accessor for JOSMs menu bar * @name menu * @static * @summary Replies an accessor for JOSMs menu bar. */ Object.defineProperty(josm, 'menu', { enumerable: true, value: MenuBar }) /** * Replies an accessor to the JOSM scripting console. * * Use this object to write messages to the scripting console * * @readOnly * @property {module:josm/scriptingconsole} console accessor to the JOSM scripting console * @name console * @static * @summary Replies an accessor to the JOSM scripting console. */ Object.defineProperty(josm, 'console', { enumerable: true, value: console }) Ã— Search results Close "},"josm_api.mjs.html":{"id":"josm_api.mjs.html","title":"Source: josm/api.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/api.mjs /** * This module provides functions to retrieve data from and upload data * to an OSM server. * * @example * import {Api, ChangesetApi, ApiConfig} from 'josm/api' * * @module josm/api */ /* global Java */ const URL = Java.type('java.net.URL') const OsmApi = Java.type('org.openstreetmap.josm.io.OsmApi') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') const PrimitiveId = Java.type('org.openstreetmap.josm.data.osm.PrimitiveId') const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') const NullProgressMonitor = Java.type('org.openstreetmap.josm.gui.progress.NullProgressMonitor') const OsmServerChangesetReader = Java.type('org.openstreetmap.josm.io.OsmServerChangesetReader') const OsmServerObjectReader = Java.type('org.openstreetmap.josm.io.OsmServerObjectReader') const OsmServerBackreferenceReader = Java.type('org.openstreetmap.josm.io.OsmServerBackreferenceReader') const Preferences = Java.type('org.openstreetmap.josm.data.Preferences') const Bounds = Java.type('org.openstreetmap.josm.data.Bounds') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const BoundingBoxDownloader = Java.type('org.openstreetmap.josm.io.BoundingBoxDownloader') const CredentialsManager = Java.type('org.openstreetmap.josm.io.auth.CredentialsManager') const RequestorType = Java.type('java.net.Authenticator.RequestorType') const PasswordAuthentication = Java.type('java.net.PasswordAuthentication') import * as util from 'josm/util' /** * Specification of position as lat/lon-pair. * * @typedef LatLonSpec * @property {number} lat the latitude * @property {number} lon the longitude */ /** * Creates a {@class org.openstreetmap.josm.data.coor.LatLon} from a * javascript object. * * @example * import { buildLatLon } from 'josm/api' * const pos = buildLatLon({lat: 1, lon: 2}); * * @param {module:josm/api~LatLonSpec} obj a specification of the position * @static * @returns {org.openstreetmap.josm.data.coor.LatLon} * @summary Create a {@class org.openstreetmap.josm.data.coor.LatLon} * from a javascript object. */ export function buildLatLon(obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined'); util.assert(typeof obj === 'object', 'obj: expected an object, got {0}', obj); util.assert(util.isNumber(obj.lat), 'obj.lat: expected a number, got {0}', obj.lat); util.assert(util.isNumber(obj.lon), 'obj.lon: expected a number, got {0}', obj.lon); util.assert(LatLon.isValidLat(obj.lat), 'obj.lat: expected a valid lat in the range [-90,90], got {0}', obj.lat); util.assert(LatLon.isValidLon(obj.lon), 'obj.lon: expected a valid lon in the range [-180,180], got {0}', obj.lon); return new LatLon(obj.lat, obj.lon); } /** * Specification of a bounds as JavaScript object. * * @typedef BoundsSpec1 * @property {number} minlat * @property {number} minlon * @property {number} maxlat * @property {number} maxlon * @example * const bounds = { * minlat: 46.9479186, minlon: 7.4619484, * maxlat: 46.9497642, maxlon: 7.4660683 * } */ /** * Specification of a bounds as JavaScript object. * * @typedef BoundsSpec2 * @property {module:josm/api~LatLonSpec} min the upper left point * @property {module:josm/api~LatLonSpec} max the lower right point * @example * const bounds = { * min: {lat: 46.9479186, lon: 7.4619484}, * max: {lat: 46.9497642, lon: 7.4660683} * } */ /** * Creates a {@class org.openstreetmap.josm.data.Bounds} instance from a javascript object. * * @example * import { buildBounds } from 'josm/api' * const bounds1 = buildBounds({ * minlat: 46.9479186, minlon: 7.4619484, * maxlat: 46.9497642, maxlon: 7.4660683 * }) * * const bounds2 = buildBounds({ * min: {lat: 46.9479186, lon: 7.4619484}, * max: {lat: 46.9497642, lon: 7.4660683} * }) * * @param {BoundsSpec1|BoundsSpec2} obj a javascript object * @returns {org.openstreetmap.josm.data.Bounds} the bounds * @static */ export function buildBounds(obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined') util.assert(typeof obj === 'object', 'obj: expected an object, got {0}', obj) function normalizeLat(obj,name) { util.assert(util.isDef(obj[name]), '{0}: missing mandatory property', name) util.assert(util.isNumber(obj[name]), '{0}: expected a number, got {1}', name, obj[name]) util.assert(LatLon.isValidLat(obj[name]), '{0}: expected a valid lat, got {1}', name, obj[name]) return obj[name] } function normalizeLon(obj,name) { util.assert(util.isDef(obj[name]), '{0}: missing mandatory property', name) util.assert(util.isNumber(obj[name]), '{0}: expected a number, got {1}', name, obj[name]) util.assert(LatLon.isValidLon(obj[name]), '{0}: expected a valid lon, got {1}', name, obj[name]) return obj[name] } if (util.isDef(obj.minlat)) { const minlat = normalizeLat(obj, \"minlat\") const minlon = normalizeLon(obj, \"minlon\") const maxlat = normalizeLat(obj, \"maxlat\") const maxlon = normalizeLon(obj, \"maxlon\") return new Bounds(minlat, minlon, maxlat, maxlon) } else if (util.isDef(obj.min)) { const min = buildLatLon(obj.min) const max = buildLatLon(obj.max) return new Bounds(min,max) } else { util.assert(false, 'obj: expected an object {min:.., max:..} or ' + '{minlat:, maxlat:, minlon:, maxlon:}, got {0}', obj) } } /** * Provides methods to open, close, get, update, etc. changesets on the OSM * API server. * * &lt;strong&gt;Note:&lt;/strong&gt; this class doesn't provide a constructor. Methods * and properties are &lt;code&gt;static&lt;/code&gt;. * * @example * // load the changeset api * import { ChangesetApi } from 'josm/api' * * // create a new changeset on the server * const cs = ChangesetApi.open() * * @summary Provides methods to open, close, get, update, etc. changesets on the OSM * API server. * */ export class ChangesetApi { /** * Creates and opens a changeset * * @example * import { ChangesetApi } from 'josm/api' * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // open a new changeset with no tags * const cs1 = ChangesetApi.open() * * // open a new changeset with the tags given by the supplied changeset * const cs2 = new Changeset() * cs2.put('comment', 'a test comment') * cs2 = ChangesetApi.open(cs2) * * // open a new changeset with the tags given by the object * const cs3 = ChangesetApi.open({comment: 'a test comment'}) * * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset * @param {org.openstreetmap.josm.data.osm.Changeset | object} [changeset] the changeset to open */ static open() { let cs switch (arguments.length) { case 0: cs = new Changeset() break case 1: let o = arguments[0] if (o instanceof Changeset) { cs = o } else if (typeof o === 'object') { cs = new Changeset() for (let p in o) { if (!util.hasProp(o, p)) continue let key = p let value = o[p] key = util.trim(key) value = value + '' // convert to string cs.put(key, value) } } else { util.assert(false, 'Unexpected type of argument, expected Changeset or object, ' + 'got {0}', o) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } const api = OsmApi.getOsmApi() api.openChangeset(cs, NullProgressMonitor.INSTANCE) return cs } /** * Closes a changeset * * @example * import { ChangesetApi } from 'josm/api' * import * as util from 'josm/util' * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // closs the changeset 12345 * ChangesetApi.close(12345) * * // open a new changeset with the tags given by the supplied changeset * const cs2 = new Changeset(12345) * cs2 = ChangesetApi.close(cs2) * util.assert(cs2.closed) // the changeset is now closed * * @param {number | org.openstreetmap.josm.data.osm.Changeset} changeset the changeset to close * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset */ static close() { let cs switch (arguments.length) { case 0: util.assert(false, 'Missing arguments. Expected a changeset it or a changeset') break case 1: { const o = arguments[0] if (o instanceof Changeset) { cs = o } else if (util.isNumber(o)) { util.assert(o &gt; 0, 'Expected a positive changeset id, got {0}', o) cs = new Changeset(o) } else { util.assert(false, 'Unexpected type of argument, expected Changeset or number, ' + 'got {0}', o) } break } default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } const api = OsmApi.getOsmApi() api.closeChangeset(cs, NullProgressMonitor.INSTANCE) return cs } /** * Updates a changeset * * @example * import { ChangesetApi } from 'josm/api' * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // update the comment of a changeset * const cs2 = new Changeset(12345) * cs2.put('comment', 'an updated comment') * cs2 = ChangesetApi.update(cs2) * * @param {org.openstreetmap.josm.data.osm.Changeset} changeset the changeset to update * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset */ static update() { let cs switch (arguments.length) { case 0: util.assert(false, 'Missing arguments. Expected a changeset') break case 1: { const o = arguments[0] if (o instanceof Changeset) { cs = o } else { util.assert(false, 'Unexpected type of argument, expected Changeset, got {0}', o) } break } default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } const api = OsmApi.getOsmApi() api.updateChangeset(cs, NullProgressMonitor.INSTANCE) return cs } /** * Get a changeset from the server * * @example * import { ChangesetApi } from 'josm/api' * const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') * * // get the changeset with id 12345 * const cs1 = ChangesetApi.get(12345) * * // get the changeset with id 12345 * lets cs2 = new Changeset(12345) * cs2 = ChangesetApi.get(cs2) * * @param {number|org.openstreetmap.josm.data.osm.Changeset} changeset the changeset to get * @returns {org.openstreetmap.josm.data.osm.Changeset} the changeset */ static get() { let cs switch (arguments.length) { case 0: util.assert(false, 'Missing arguments. Expected a changeset id or a changeset') break case 1: { const o = arguments[0] if (o instanceof Changeset) { cs = o } else if (util.isNumber(o)) { util.assert(o &gt; 0, 'Expected a positive changeset id, got {0}', o) cs = new Changeset(o) } else { util.assert(false, 'Unexpected type of argument, expected Changeset or number, ' + 'got {0}', o) } break } default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } const reader = new OsmServerChangesetReader() cs = reader.readChangeset(cs.id, NullProgressMonitor.INSTANCE) return cs } } /** * Collection of static methods to download objects from and upload objects * to the OSM server. * * &lt;strong&gt;Note:&lt;/strong&gt; this class doesn't provide a constructor. * Methods and properties are 'static'. * * @example * // load the api * import { Api } from 'josm/api' * * // download node 12345 * const ds = Api.downloadObject(12345, 'node') * * @summary Collection of static methods to download objects from and upload objects * to the OSM server */ export class Api { static #normalizeType (type) { util.assert(util.isSomething(type), 'type must not be null or undefined') if (util.isString(type)) { try { type = OsmPrimitiveType.fromApiTypeName(type) } catch (e) { util.assert(false, 'Invalid primitive type, got \\'\\'{0}\\'\\'', type) } } else if (type instanceof OsmPrimitiveType) { if (![OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, OsmPrimitiveType.RELATION].includes(type)) { util.assert(false, 'Invalid primitive type, got {0}', type) } } else { util.assert(false, 'Invalid primitive type, got {0}', type) } return type } static #normalizeId (id) { util.assert(util.isSomething(id), 'id must not be null or nothing') util.assert(util.isNumber(id), 'Expected a number as id, got {0}', id) util.assert(id &gt; 0, 'Expected a positive number as id, got {0}', id) return id } static #primitiveIdFromObject(o) { util.assert(util.hasProp(o, 'id'), 'Mandatory property \\'\\'id\\'\\' is missing in object {0}', o) util.assert(util.hasProp(o, 'type'), 'Mandatory property \\'\\'type\\'\\' is missing in object {0}', o) return new SimplePrimitiveId(Api.#normalizeId(o.id), Api.#normalizeType(o.type)) } static #downloadObject1() { let id const o = arguments[0] util.assert(util.isSomething(o), 'Argument 0: must not be null or undefined') if (o instanceof PrimitiveId) { id = o } else if (typeof o === 'object') { id = Api.#primitiveIdFromObject(o) } else { util.assert(false, 'Argument 0: unexpected type, got {0}', o) } var reader = new OsmServerObjectReader(id, false) var ds = reader.parseOsm(null /* null progress monitor */) return ds } static #optionFull(options) { if (!util.hasProp(options, 'full')) return undefined var o = options.full if (typeof o === 'boolean') return o util.assert('Expected a boolean value for option \\'\\'full\\'\\', got {0}', o) } static #optionVersion(options) { if (!util.hasProp(options, 'version')) return undefined var o = options.version util.assert(util.isNumber(o), 'Expected a number for option \\'\\'version\\'\\', got {0}', o) util.assert(o &gt; 0, 'Expected a number &gt; 0 for option \\'\\'version\\'\\', got {0}', o) return o } static #downloadObject2 () { function parseOptions (arg) { const options = { full: undefined, version: undefined } if (!(typeof arg === 'object')) { return options } options.full = Api.#optionFull(arg) options.version = Api.#optionVersion(arg) return options } let id let options = { full: undefined, version: undefined } if (util.isNumber(arguments[0])) { id = Api.#normalizeId(arguments[0]) const type = Api.#normalizeType(arguments[1]) id = new SimplePrimitiveId(id, type) } else if (arguments[0] instanceof PrimitiveId) { id = arguments[0] options = parseOptions(arguments[1]) } else if (typeof arguments[0] === 'object') { id = Api.#primitiveIdFromObject(arguments[0]) options = parseOptions(arguments[1]) } else { util.assert(false, 'Unsupported types of arguments') } let reader if (util.isDef(options.version)) { reader = new OsmServerObjectReader(id, options.version) } else { reader = new OsmServerObjectReader(id, !!options.full) } const ds = reader.parseOsm(null /* null progress monitor */) return ds } static #downloadObject3 () { const options = { full: undefined, version: undefined } let n = Api.#normalizeId(arguments[0]) let type = Api.#normalizeType(arguments[1]) let id = new SimplePrimitiveId(n, type) util.assert(typeof arguments[2] === 'object', 'Expected an object with named parameters, got {0}', arguments[2]) options.full = Api.#optionFull(arguments[2]) options.version = Api.#optionVersion(arguments[2]) let reader if (util.isDef(options.version)) { reader = new OsmServerObjectReader(id, options.version) } else { reader = new OsmServerObjectReader(id, !!options.full) } var ds = reader.parseOsm(null /* null progress monitor */) return ds } /** * Options for the method downloadObject() * * @typedef DownloadObjectOptions * @property {boolean} [full=false] if &lt;code&gt;true&lt;/code&gt;, the object and its immediate children are * downloaded, i.e. the nodes of a way and the relation members of a relation. Default: * &lt;code&gt;false&lt;/code&gt;. * @property {number} [version] if present, the specified version of the object is downloaded. * If missing, the current version is downloaded. If present, the * option &lt;code&gt;full&lt;/code&gt; is ignored. */ /** * Downloads an object from the server. * * There are multiple options to specify what object to download. * In addition, the function accepts a set of optional named parameters * as last argument. * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;downloadObject(id, type, ?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;id&lt;/code&gt; is the global numeric id. * &lt;code&gt;type&lt;/code&gt; is either one of the strings 'node', 'way', * or 'relation', or one of the enumeration OsmPrimitiveType.NODE, * OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION * &lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;downloadObject(id, ?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;id&lt;/code&gt; is a &lt;code&gt;PrimitiveId&lt;/code&gt; or an object * with the (mandatory) properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, * i.e. an object &lt;code&gt;{id: ..., type: ...}&lt;/code&gt;. * &lt;code&gt;id&lt;/code&gt; is again a number, &lt;code&gt;type&lt;/code&gt; is again either one * of the strings 'node', 'way', or 'relation', or one of the * enumeration OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, * or OsmPrimitiveType.RELATION. * &lt;/dd&gt; * &lt;/dl&gt; * * @example * import { Api } from 'josm/api' * const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') * const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') * * // download the node with id 12345 * const ds1 = Api.downloadObject(12345, 'node') * * // download the node with id 12345 * const ds2 = Api.downloadObject({id: 12345, type: 'node'}) * * // download the full relation (including its members) with id 12345 * const id = new SimplePrimitiveId(12345, OsmPrimitiveType.RELATION) * const ds3 = Api.downloadObject(id, {full: true}) * * // download version 5 of the full way 12345 (including its nodes) * const ds4 = Api.downloadObject(12345, OsmPrimitiveType.WAY, {full: true, version: 5}) * * @returns {org.openstreetmap.josm.data.osm.DataSet} the downloaded primitives * @param {number|org.openstreetmap.josm.data.osm.PrimitiveId} id the id of the object * @param {string|org.openstreetmap.josm.data.osm.OsmPrimitiveType} [type] the type of the object * @param {module:josm/api~DownloadObjectOptions} [options] named options * @static */ static downloadObject() { switch (arguments.length) { case 0: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) break case 1: return Api.#downloadObject1(...arguments) case 2: return Api.#downloadObject2(...arguments) case 3: return Api.#downloadObject3(...arguments) default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } } static #downloadReferrer1 () { let id const o = arguments[0] util.assert(util.isSomething(o), 'Argument 0: must not be null or undefined') if (o instanceof PrimitiveId) { id = o } else if (typeof o === 'object') { id = Api.#primitiveIdFromObject(o) } else { util.assert(false, 'Argument 0: unexpected type, got {0}', o) } const reader = new OsmServerBackreferenceReader(id.getUniqueId(),id.getType()) const ds = reader.parseOsm(NullProgressMonitor.INSTANCE) return ds } static #downloadReferrer2 () { let id let type const options = { full: undefined } if (util.isNumber(arguments[0])) { id = Api.#normalizeId(arguments[0]) type = Api.#normalizeType(arguments[1]) id = new SimplePrimitiveId(id, type) } else if (arguments[0] instanceof PrimitiveId) { id = arguments[0] const o = arguments[1] if (util.isSomething(o)) { util.assert(typeof o === 'object', 'Expected an object with named parameters, got {0}', o) options.full = Api.#optionFull(o) } } else if (typeof arguments[0] === 'object') { id = Api.#primitiveIdFromObject(arguments[0]) const o = arguments[1] if (util.isSomething(o)) { util.assert(typeof o === 'object', 'Expected an object with named parameters, got {0}', o) options.full = Api.#optionFull(o) } } else { util.assert(false, 'Unsupported types of arguments') } const reader = new OsmServerBackreferenceReader(id.getUniqueId(), id.getType()) if (options.full) { reader.setReadFull(true) } const ds = reader.parseOsm(NullProgressMonitor.INSTANCE) return ds } static #downloadReferrer3 () { const options = { full: undefined } const n = Api.#normalizeId(arguments[0]) const type = Api.#normalizeType(arguments[1]) const id = new SimplePrimitiveId(n, type) util.assert(typeof arguments[2] === 'object', 'Expected an object with named parameters, got {0}', arguments[2]) options.full = Api.#optionFull(arguments[2]) const reader = new OsmServerBackreferenceReader(id.getUniqueId(), id.getType()) if (options.full) { reader.setReadFull(true) } const ds = reader.parseOsm(NullProgressMonitor.INSTANCE) return ds } /** * Options for the method donwloadReferrers() * * @typedef DownloadReferrerOptions * @property {boolean} [full=false] If &lt;code&gt;true&lt;/code&gt;, the &lt;strong&gt;full&lt;/strong&gt; objects are * retrieved using multi-gets. If missing or &lt;code&gt;false&lt;/code&gt;, * only proxy objects are downloaded. Default: false */ /** * Downloads the objects &lt;em&gt;referring&lt;/em&gt; to another object from * the server. * * Downloads primitives from the OSM server which * refer to a specific primitive. Given a node, the referring ways and * relations are downloaded. Given a way or a relation, only referring * relations are downloaded. * * The default behaviour is to reply proxy objects only. * * If you set the option &lt;code&gt;{full: true}&lt;/code&gt;, every referring object * is downloaded in full. * * There are multiple options to specify what referrers to download. * In addition, the function accepts a set of optional named parameters as * last argument. * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;downloadReferrer(id, type, ?options) * &lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;id&lt;/code&gt; is the global numeric id. * &lt;code&gt;type&lt;/code&gt; is either one of the strings 'node', 'way', or * 'relation', or one of the enumeration * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, * or {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION. * &lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;downloadReferrer(id, ?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;id&lt;/code&gt; is a &lt;code&gt;PrimitiveId&lt;/code&gt; or an object * with the (mandatory) properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, * i.e. an object &lt;code&gt;{id: ..., type: ...}&lt;/code&gt;. * &lt;code&gt;id&lt;/code&gt; is again a number, &lt;code&gt;type&lt;/code&gt; is again either one * of the strings 'node', 'way', or 'relation', or one of the * enumeration * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, * or {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION. * &lt;/dd&gt; * &lt;/dl&gt; * * @example * import { Api } from 'josm/api' * import { NodeBuilder } from 'josm/builder' * const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') * const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') * * // download the objects referring to the node with id 12345 * const ds1 = Api.downloadReferrer(12345, 'node') * * // download the objects referring to the node with id 12345 * const ds2 = Api.downloadReferrer({id: 12345, type: 'node'}) * * // download the relations referring to the relation with id 12345. * // Referring relations are downloaded in full. * const id = new SimplePrimitiveId(12345, OsmPrimitiveType.RELATION) * const ds3 = Api.downloadReferrer(id, { full: true }) * * // create the global node 12345 ... * const node = NodeBuilder.create(12345) * // ... and downloads its referrers in full * const ds = Api.downloadReferrer(node, { full: true }) * * @returns {org.openstreetmap.josm.data.osm.DataSet} the downloaded primitives * @param {number|org.openstreetmap.josm.data.osm.PrimitiveId} id the id of the object * @param {string|org.openstreetmap.josm.data.osm.OsmPrimitiveType} [type] the type of the object * @param {module:josm/api~DownloadReferrerOptions} [options] named options */ static downloadReferrer() { switch (arguments.length) { case 0: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) break case 1: return Api.#downloadReferrer1(...arguments) case 2: return Api.#downloadReferrer2(...arguments) case 3: return Api.#downloadReferrer3(...arguments) default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } } /** * Downloads the objects within a bounding box. * * @example * import { Api } from 'josm/api' * const Bounds = Java.type('org.openstreetmap.josm.data.Bounds') * const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') * const ds1 = Api.downloadArea(new Bounds( * new LatLon(46.9479186,7.4619484), // min * new LatLon(46.9497642, 7.4660683) // max * )) * * const ds2 = Api.downloadArea({ * min: {lat: 46.9479186, lon: 7.4619484}, * max: {lat: 46.9497642, lon: 7.4660683} * }) * * @returns {org.openstreetmap.josm.data.osm.DataSet} the downloaded primitives * @param {org.openstreetmap.josm.data.Bounds|module:josm/api~BoundsSpec1|module:josm/api~BoundsSpec2} bounds the bounding box */ static downloadArea() { util.assert(arguments.length === 1, 'Expected 1 argument, got {0}', arguments.length) let bounds = arguments[0] util.assert(util.isSomething(bounds),'bounds: must not be null or undefined') if (bounds instanceof Bounds) { // do nothing } else if (typeof bounds === 'object') { bounds = buildBounds(bounds) // convert to bounds } else { util.assert(false, 'expected an instance of Bounds or an object, got {0}', bounds) } const downloader = new BoundingBoxDownloader(bounds) return downloader.parseOsm(NullProgressMonitor.INSTANCE) } /** * Options for the method upload() * * @typedef UploadOptions * @property {string|org.openstreetmap.josm.io.UploadStrategy}[strategy] Indicates how the data is uploaded. * Either one of the strings * &lt;ul&gt; * &lt;li&gt;individualobjects&lt;/li&gt; * &lt;li&gt;chunked&lt;/li&gt; * &lt;li&gt;singlerequest&lt;/li&gt; * &lt;/ul&gt; * or one of the enumeration values in * {@class org.openstreetmap.josm.io.UploadStrategy}. * Default value: UploadStrategy.DEFAULT_UPLOAD_STRATEGY * @property {number| org.openstreetmap.josm.data.osm.Changeset} [changeset] The changeset to which the data is uploaded. * Default: creates a new changeset * * @property {number} [chunkSize] the size of an upload chunk if the data is uploaded with the * upload strategy {@class org.openstreetmap.josm.io.UploadStrategy}.CHUNKED_DATASET_STRATEGY. * * @property {boolean} [closeChangeset=true] if true, closes the changeset after the upload */ /** * Uploads objects to the server. * * You can submit data either as * {@class org.openstreetmap.josm.data.osm.DataSet}, * {@class org.openstreetmap.josm.data.APIDataSet}, javascript array of * {@class org.openstreetmap.josm.data.osm.OsmPrimitive}s or * a {@class java.util.Collection} of * {@class org.openstreetmap.josm.data.osm.OsmPrimitive}s. * * This method supports the same upload strategy as the JOSM upload dialog. * Supply the named parameter &lt;code&gt;{strategy: ...}&lt;/code&gt; to choose the * strategy. * * &lt;p class='documentation-warning'&gt; * Be careful when uploading data to the OSM server! Do not upload copyright- * protected or test data. * &lt;/p&gt; * * * The method takes care to update the primitives in the uploaded data when * the upload succeeds. For instance, uploaded new primitives become global * objects and get assigned their new id and version, successfully deleted * objects become invisible, etc. * * Even if the entire upload of a dataset fails, a subset therefore may * have been uploaded successfully. In order to keep track, which pritives * have been uploaded successfully in case of an error, the method replies a * collection of the successfully uploaded objects. * * @example * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * import { WayBuilder, NodeBuilder } from 'josm/builder' * import { Api } from 'josm/api' * const ds = new DataSet() * const nb = NodeBuilder.forDataSet(ds) * WayBuilder * .forDataSet(ds) * .withNodes( * nb.withTags({name: 'node1'}).create(), * nb.withTags({name: 'node2'}).create() * ) * .withTags({name: 'way1'}) * .create() * * // uploads the data in a new changeset in one chunk * const processed = Api.upload(ds, 'just testing') * * @param {org.openstreetmap.josm.data.osm.DataSet| * org.openstreetmap.josm.data.APIDataSet|array|java.util.Collection} data the data to upload * @param {string} comment the upload comment * @param {module:josm/api~UploadOptions} [options] named options * @returns {java.util.Collection} */ static upload(data, comment, options) { const UploadStrategy = Java.type('org.openstreetmap.josm.io.UploadStrategy') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') const APIDataSet = Java.type('org.openstreetmap.josm.data.APIDataSet') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const UploadStrategySpecification = Java.type('org.openstreetmap.josm.io.UploadStrategySpecification') const Collection = Java.type('java.util.Collection') const OsmServerWriter = Java.type('org.openstreetmap.josm.io.OsmServerWriter') comment = comment || '' comment = String(comment) util.assertSomething(data, 'data: must not be null or undefined') options = options || {} util.assert(typeof options === 'object', 'options: expected an object with named arguments, got {0}', options) function normalizeChunkSize (size) { util.assert(util.isNumber(size), 'chunksize: expected a number, got {0}', size) util.assert(size &gt;= -1, 'chunksize: expected -1 or a number &gt; 0, got {0}', size) return size } function normalizeChangeset (changeset) { if (util.isNothing(changeset)) { return new Changeset() } else if (util.isNumber(changeset)) { util.assert(changeset &gt; 0, 'changeset: expected a changeset id &gt; 0, got {0}', changeset) return new Changeset(changeset) } else if (changeset instanceof Changeset) { return changeset } else { util.assert(false, 'changeset: unexpected value, got {0}', changeset) } } function uploadSpecFromOptions (options) { let strategy = options.strategy || UploadStrategy.DEFAULT_UPLOAD_STRATEGY if (strategy instanceof String) { strategy = UploadStrategy.valueOf(strategy) util.assert(strategy, \"invalid upload strategy ''{0}''\", strategy) } let chunkSize = options.chunkSize || UploadStrategySpecification.UNSPECIFIED_CHUNK_SIZE chunkSize = normalizeChunkSize(chunkSize) let closeChangeset = util.isDef(options.closeChangeset) ? options.closeChangeset : true closeChangeset = Boolean(closeChangeset) const spec = new UploadStrategySpecification() spec.setStrategy(strategy) spec.setChunkSize(chunkSize) spec.setCloseChangesetAfterUpload(closeChangeset) return spec } let apiDataSet if (data instanceof DataSet) { apiDataSet = new APIDataSet(data) } else if (data instanceof APIDataSet) { apiDataSet = data } else if (util.isArray(data)) { apiDataSet = new APIDataSet(data) } else if (data instanceof Collection) { apiDataSet = new APIDataSet(data) } else { util.assert(false, 'data: unexpected type of value, got {0}', data) } if (apiDataSet.isEmpty()) return undefined apiDataSet.adjustRelationUploadOrder() const toUpload = apiDataSet.getPrimitives() let changeset = options.changeset || new Changeset() changeset = normalizeChangeset(changeset) changeset.put('comment', comment) const spec = uploadSpecFromOptions(options) const writer = new OsmServerWriter() writer.uploadOsm(spec, toUpload, changeset, null /* progress monitor */) if (spec.isCloseChangesetAfterUpload()) { ChangesetApi.close(changeset) } return writer.getProcessedPrimitives() } } /* -------------------------------------------------------------------------- */ /* ApiConfig */ /* -------------------------------------------------------------------------- */ /** * ApiConfig provides methods and properties for configuring API parameters. * * * @class * @summary ApiConfig provides methods and properties for configuring API parameters * @name ApiConfig */ export const ApiConfig = {} const DEFAULT_URL = 'https://www.openstreetmap.org/api' /** * Get or set the API server URL. * * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;get&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies the currently configured server URL or undefinend, if no * server URL is configured.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class='signature'&gt;set&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Sets the current server URL. If null or undefined, removes the * current configuration. Accepts either a string or a {@class java.net.URL}. * Only accepts http or https URLs. * &lt;/dd&gt; * &lt;/dl&gt; * * @example * import { ApiConfig } from 'josm/api' * ApiConfig.serverUrl // -&gt; the current server url * * // set a new API url * ApiConfig.serverUrl = 'http://api06.dev.openstreetmap.org' * * @static * @summary Get or set the API server URL. * @property {string} serverUrl * @name serverUrl * @memberof module:josm/api~ApiConfig */ Object.defineProperty(ApiConfig, 'serverUrl', { enumerable: true, get: function () { var url = Preferences.main().get('osm-server.url', null) if (url == null) url = DEFAULT_URL return url == null ? undefined : util.trim(url) }, set: function (value) { if (util.isNothing(value)) { Preferences.main().put('osm-server.url', null) } else if (value instanceof URL) { util.assert( ['http', 'https'].includes(value.getProtocol()), 'url: expected a http or https URL, got {0}', value) Preferences.main().put('osm-server.url', value.toString()) } else if (util.isString(value)) { value = util.trim(value) try { const url = new URL(value) util.assert( ['http', 'https'].includes(url.getProtocol()), 'url: expected a http or https URL, got {0}', url.toString()) Preferences.main().put('osm-server.url', url.toString()) } catch (e) { util.assert(false, 'url: doesn\\'\\'t look like a valid URL, got {0}. Error: {1}', value, e) } } else { util.assert(false, 'Unexpected type of value, got {0}', value) } } }) /** * Get the default server URL. * * @example * import { ApiConfig } from 'josm/api' * ApiConfig.defaultServerUrl // -&gt; the default server url * * @static * @summary Get the default server URL * @name defaultServerUrl * @property {string} defaultServerUrl the default server URL * @readOnly * @memberof module:josm/api~ApiConfig */ Object.defineProperty(ApiConfig, 'defaultServerUrl', { value: DEFAULT_URL, writable: false, enumerable: true }) function normalizeAuthMethod (authMethod) { util.assert(util.isString(authMethod), 'authMethod: expected a string, got {0}', authMethod) authMethod = util.trim(authMethod).toLowerCase() util.assert(authMethod === 'basic' || authMethod === 'oauth', 'Unsupported value for authMethod, got {0}', authMethod) return authMethod } /** * Get or set the authentication method. * * JOSM uses two authentication methods: * &lt;dl&gt; * &lt;dt&gt;&lt;code class='signature'&gt;basic&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Basic authentication with a username and a password&lt;/dd&gt; * &lt;dt&gt;&lt;code class='signature'&gt;oauth&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Authentication with the &lt;a href='http://oauth.net/'&gt;OAuth&lt;/a&gt; * protocol.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { ApiConfig } from 'josm/api' * ApiConfig.authMethod // -&gt; the current authentication method * * // set OAuth as authentication method * ApiConfig.authMethod = 'oauth' * * @static * @summary Get or set the authentication method. * @type string * @name authMethod * @property {string} authMethod the authentication method * @memberof module:josm/api~ApiConfig */ Object.defineProperty(ApiConfig, 'authMethod', { enumerate: true, get: function () { let authMethod = Preferences.main().get('osm-server.auth-method', 'basic') authMethod = util.trim(authMethod).toLowerCase() if (authMethod === 'basic' || authMethod === 'oauth') return authMethod // unsupported value for authMethod in the preferences. Returning // 'basic' as default. return 'basic' }, set: function (value) { value = normalizeAuthMethod(value) Preferences.main().put('osm-server.auth-method', value) } }) /** * Options for the method setCredentials * * @typedef SetOrGetCredentialOptions * @param {string} [host] the host name of the API server for which credentials are set. * If missing, the host name of the currently configured OSM API server * is used. */ /** * Basic credentials replied by getCredentials * * @typedef BasicCredentials * @property {string} host the host name * @property {string} user the user name * @property {string} password the password */ /** * OAuth credentials replied by getCredentials * * @typedef OAuthCredentials * @property {string} key the OAuth key * @property {string} secret the OAuth secret */ /** * Gets the credentials, i.e. username and password for the basic * authentication method. * * @example * import { ApiConfig } from 'josm/api' * * // get username/password for the current OSM API server * const credentials = ApiConfig.getCredentials('basic') * * @param {string} authMethod the authentication method. Either &lt;code&gt;basic&lt;/code&gt; or &lt;code&gt;oauth&lt;/code&gt; * @param {module:josm/api~SetOrGetCredentialOptions} [options] additional options * @static * @returns {BasicCredentials | OAuthCredentials} the credentials * @memberof module:josm/api~ApiConfig */ function getCredentials(authMethod, options) { options = options || {} util.assert(typeof options === 'object', 'options: expected an object with named options, got {0}', options) // a hack to convert a Java 'char[]' into a JavaScript string function charArrayToString(chars) { let result = \"\" for (let i=0; i &lt; chars.length; i++) { const c = chars[i].toString() result += c } return result } function getBasicCredentials () { const cm = CredentialsManager.getInstance() if (options.host) options.host = util.trim(String(options.host)) const host = options.host ? options.host : OsmApi.getOsmApi().getHost() const pa = cm.lookup(RequestorType.SERVER, host) if (pa) { return { host: host, user: pa.getUserName(), password: charArrayToString(pa.getPassword()) } } else { return { host: host, user: undefined, password: undefined } } } function getOAuthCredentials () { const cm = CredentialsManager.getInstance() const token = cm.lookupOAuthAccessToken() if (token == null) return undefined return { key: token.getKey(), secret: token.getSecret() } } authMethod = normalizeAuthMethod(authMethod) if (authMethod === 'basic') return getBasicCredentials() if (authMethod === 'oauth') return getOAuthCredentials() util.assert(false, 'Unsupported authentication method, got {0}', authMethod) } ApiConfig.getCredentials = getCredentials function normalizeBasicCredentials (credentials) { if (util.isNothing(credentials)) return null util.assert(credentials instanceof PasswordAuthentication || typeof credentials === 'object', 'basic credentials: expected an object or an instance of ' + 'PasswordAuthentication , got {0}', credentials) if (credentials instanceof PasswordAuthentication) { return credentials } else { const user = String(credentials.user || '') let password = credentials.password || null if (password) { // convert to char array password = [...password] } return new PasswordAuthentication(user, password) } } function normalizeOAuthCredentials (credentials) { const OAuthToken = Java.type('org.openstreetmap.josm.data.oauth.OAuthToken') if (util.isNothing(credentials)) return null util.assert(credentials instanceof OAuthToken || typeof credentials === 'object', 'oauth credentials: expected an object or an instance of OAuthToken, ' + 'got {0}', credentials) if (credentials instanceof OAuthToken) { return credentials } else { const key = String(credentials.key || '') const secret = String(credentials.secret || '') return new OAuthToken(key, secret) } } /** * Userid and password for basic authentication. * * @typdef BasicAuthParameters * @param {string} user the user id * @param {string} password the password */ /** * Parameters for OAuth authentication * * @typdef OAuthParameters * @param {string} key the key * @param {string} secret the secret */ /** * Set the credentials, i.e. username and password for the basic * authentication method. * * Basic authentication credentials are either an instance of * {@class java.net.PasswordAuthentication} or * an object &lt;code&gt;{user: string, password: string}&lt;/code&gt;. * * OAuth authentication credentials are either an instance of * {@class org.openstreetmap.josm.data.oauth.OAuthToken} or * an object &lt;code&gt;{key: string, secret: string}&lt;/code&gt;. * * @example * import { ApiConfig } from 'josm/api' * * // set the credentials * ApiConfig.setCredentials('basic', { user:'test', password:'my-password' }) * * @param {string} authMethod the authentication method. Either 'basic' or 'oauth'. * @param {( * module:josm/api~BasicAuthParameters * | module:josm/api~OAuthParameters * | org.openstreetmap.josm.data.oauth.OAuthToken * | java.net.PasswordAuthentication)} credentials the credentials * @param {module:josm/api~SetOrGetCredentialOptions} [options] additional options * @static * @returns {object} the credentials * @memberof module:josm/api~ApiConfig */ function setCredentials (authMethod, credentials, options) { options = options || {} util.assert(typeof options === 'object', 'options: expected an object with named options, got {0}', options) authMethod = normalizeAuthMethod(authMethod) if (authMethod === 'basic') { credentials = normalizeBasicCredentials(credentials) util.assert(credentials != null, 'credentials: can\\'\\'t store null credentials') let host = options.host ? String(options.host) : null host = host || OsmApi.getOsmApi().getHost() const cm = CredentialsManager.getInstance() cm.store(RequestorType.SERVER, host, credentials) } else if (authMethod === 'oauth') { credentials = normalizeOAuthCredentials(credentials) util.assert(credentials != null, 'credentials: can\\'\\'t store null credentials') const cm = CredentialsManager.getInstance() cm.storeOAuthAccessToken(credentials) } else { util.assert(false, 'Unsupported authentication method, got {0}', authMethod) } } ApiConfig.setCredentials = setCredentials Ã— Search results Close "},"josm_builder.mjs.html":{"id":"josm_builder.mjs.html","title":"Source: josm/builder.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/builder.mjs /** * Collection of builders for creating OSM nodes, ways and relations. * * @module josm/builder * @example * // josm/builder exports the NodeBuilder, WayBuilder, and RelationBuilder * // from its sub modules * import { * NodeBuilder, * WayBuilder, * RelationBuilder * } from 'josm/builder' * * @see module:josm/builder/node~NodeBuilder * @see module:josm/builder/way~WayBuilder * @see module:josm/builder/relation~RelationBuilder */ export const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') export * from './builder/node-builder' export * from './builder/way-builder' export * from './builder/relation-builder' Ã— Search results Close "},"josm_builder_node-builder.mjs.html":{"id":"josm_builder_node-builder.mjs.html","title":"Source: josm/builder/node-builder.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/builder/node-builder.mjs /** * @module josm/builder/node */ /* global Java */ // -- imports const Node = Java.type('org.openstreetmap.josm.data.osm.Node') const Way = Java.type('org.openstreetmap.josm.data.osm.Way') const Relation = Java.type('org.openstreetmap.josm.data.osm.Relation') const RelationMember = Java.type('org.openstreetmap.josm.data.osm.RelationMember') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const OsmPrimitive = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitive') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const List = Java.type('java.util.List') import * as util from 'josm/util' import { assertGlobalId, rememberId, rememberTags, assignTags, rememberIdFromObject, rememberVersionFromObject, checkLat, checkLon, rememberPosFromObject, rememberTagsFromObject } from './common' /** * NodeBuilder helps to create OSM nodes. * * Methods of NodeBuilder can be used in a static and in an instance context. * It isn't necessary to create an instance of NodeBuilder, unless it is * configured with a {@class org.openstreetmap.josm.data.osm.DataSet}, * to which created nodes are added. * * @example * import {NodeBuilder} from 'josm/builder' * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const ds = new DataSet() * // create a node builder without and underlying dataset ... * let nbuilder = new NodeBuilder() * // ... with an underlying dataset .... * nbuilder = new NodeBuilder(ds) * // ... or using this factory method * nbuilder = NodeBuilder.forDataSet(ds) * * // create a new local node at position (0,0) without tags * const n1 = NodeBuilder.create() * * // create a new global node at a specific position with tags * const n2 = NodeBuilder.withPosition(1,1).withTags({name: 'test'}).create(1) * * // create a new proxy for a global node * // (an 'incomplete' node in JOSM terminology) * const n3 = NodeBuilder.createProxy(2) * * @class * @summary NodeBuilder helps to create OSM nodes * @name NodeBuilder * @param {org.openstreetmap.josm.data.osm.DataSet} [ds] the dataset * which created objects are added to */ /** * Creates a new node builder. * * @param {org.openstreetmap.josm.data.osm.DataSet} [ds] the dataset * to which created objects are added * @constructor * @memberOf NodeBuilder */ export function NodeBuilder(ds) { if (util.isSomething(ds)) { util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) this.ds = ds } } /** * Creates or configures a NodeBuilder which will add created nodes * to the dataset &lt;code&gt;ds&lt;/code&gt;. * * @example * import { NodeBuilder } from 'josm/builder' * * // create a new node builder building to a data set * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * const ds = new DataSet() * * // ... using a static method ... * const nb1 = NodeBuilder.forDataSet(ds) * // ... or the instance method * const nb2 = new NodeBuilder.forDataSet(ds) * * @returns {module:josm/builder/node~NodeBuilder} the node builder * @param {org.openstreetmap.josm.data.osm.DataSet} ds the dataset which * created objects are added to * @summary Creates a new NodeBuilder for a specific * {@class org.openstreetmap.josm.data.osm.DataSet}. * @memberof module:josm/builder/node~NodeBuilder * @instance */ function forDataSet (ds) { const builder = receiver(this) util.assert(util.isSomething(ds), 'Expected a non-null defined object, got {0}', ds) util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) builder.ds = ds return builder } NodeBuilder.prototype.forDataSet = forDataSet NodeBuilder.forDataSet = forDataSet function receiver (that) { return typeof that === 'object' ? that : new NodeBuilder() } function initFromObject (builder, args) { rememberIdFromObject(builder, args) rememberVersionFromObject(builder, args) rememberPosFromObject(builder, args) rememberTagsFromObject(builder, args) } /** * Named options for {@link module:josm/builder/node~NodeBuilder#create create} * * @typedef NodeBuilderOptions * @property {number} [version=1] the version (&amp;gt 0) of the node. Default: 1. * @property {number} [lat=0.0] a valide latitude (number in the range [-90,90]. Default: 0.0 * @property {number} [lon=0.0] a valide longitude (number in the range[-180,180]. Default: 0.0 * @property {number[] | {lat: number, lon: number }} [pos=null] a position, either an array with * two numbers or as an object * @property {object} [tags] an object with tags. Null values and undefined * values are ignored. Any other value is converted to a string. * Leading and trailing white space in keys is removed. * @memberOf module:josm/builder/node~NodeBuilder * @example * // options to create a node at position (1.0, 2.0) with some tags * const options = { * lat: 1.0, * lon: 2.0, * tags: { * amenity: 'restaurant' * } * } */ /** * Creates a new {@class org.openstreetmap.josm.data.osm.Node}. * * Can be used in an instance or in a static context. * * @example * import { NodeBuilder } from 'josm/builder' * // create a new local node at position [0,0] * const n1 = NodeBuilder.create() * * // create a new global node with id 1111 at position [0,0] * const n2 = NodeBuilder.create(1111) * * // create a new global node with version 3 at a specific position * // and with some tags * const n3 = NodeBuilder.create(2222, { * version: 3, * lat: 23.45, * lon: 87.23, * tags: {amenity: 'restaurant'} * }) * * @param {number} [id] a global node id. If missing and * not set before using &lt;code&gt;withId(..)&lt;/code&gt;, creates a new local id. * @param {module:josm/builder/node~NodeBuilder.NodeBuilderOptions} [options] additional options for creating the node * @returns {org.openstreetmap.josm.data.osm.Node} the created node * @summary Creates a new {@class org.openstreetmap.josm.data.osm.Node} * @memberof module:josm/builder/node~NodeBuilder * @instance */ function create () { const builder = receiver(this) let arg switch (arguments.length) { case 0: break case 1: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') if (util.isNumber(arg)) { util.assert(arg &gt; 0, 'Argument 0: expected an id &gt; 0, got {0}', arg) builder.id = arg } else if (typeof arg === 'object') { initFromObject(builder, arg) } else { util.assert(false, \"Argument 0: unexpected type, got ''{0}''\", arg) } break case 2: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(arg), 'Argument 0: must be a number') util.assert(arg &gt; 0, 'Expected an id &gt; 0, got {0}', arg) builder.id = arg arg = arguments[1] if (util.isSomething(arg)) { util.assert(typeof arg === 'object', 'Argument 1: must be an object') initFromObject(builder, arg) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } let node if (util.isNumber(builder.id)) { if (util.isNumber(builder.version)) { node = new Node(builder.id, builder.version) } else { node = new Node(builder.id, 1) } const coor = new LatLon(builder.lat || 0, builder.lon || 0) node.setCoor(coor) } else { node = new Node(new LatLon(builder.lat || 0, builder.lon || 0)) } assignTags(node, builder.tags || {}) if (builder.ds) { if (builder.ds.getPrimitiveById(node) == null) { builder.ds.addPrimitive(node) } else { throw new Error( 'Failed to add primitive, primitive already included ' + 'in dataset. \\n' + 'primitive=' + node ) } } return node } NodeBuilder.create = create NodeBuilder.prototype.create = create /** * Creates a new &lt;em&gt;proxy&lt;/em&gt; * {@class org.openstreetmap.josm.data.osm.Node}. A proxy node is a node, * for which we only know its global id. In order to know more details * (position, tags, etc.), we would have to download it from the OSM server. * * * The method can be used in a static and in an instance context. * * @example * import { NodeBuilder } from 'josm/builder' * * // a new proxy node for the global node with id 1111 * const n1 = NodeBuilder.createProxy(1111) * * @param {number} id the node id (not null, number &gt; 0 expected) * @return {org.openstreetmap.josm.data.osm.Node} the new proxy node * @memberof module:josm/builder/node~NodeBuilder * @instance */ function createProxy (id) { const builder = receiver(this) util.assert(util.isSomething(id), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(id), 'Argument 0: expected a number, got {0}', id) util.assert(id &gt; 0, 'Argument 0: id &gt; 0 expected, got {0}', id) const node = new Node(id) if (builder.ds) builder.ds.addPrimitive(node) return node } NodeBuilder.prototype.createProxy = NodeBuilder.createProxy = createProxy /** * Declares the node position. * * The method can be used in a static and in an instance context. * * @example * import { NodeBuilder } from 'josm/builder' * * // a new global node with the global id 1111 at position (34,45) * const n1 = NodeBuilder.withPosition(34,45).create(1111) * * // a new local node at position (23.2, 87.33) * const n2 = NodeBuilder.withPosition(23.3,87.33).create() * * @param {Number} lat the latitude. A number in the range [-90..90]. * @param {Number} lon the longitude. A number in the range [-180..180]. * @returns {module:josm/builder/node~NodeBuilder} a node builder (for method chaining) * @memberof module:josm/builder/node~NodeBuilder * @instance */ function withPosition (lat, lon) { const builder = receiver(this) util.assert(util.isNumber(lat), 'Expected a number for lat, got {0}', lat) util.assert(util.isNumber(lon), 'Expected a number for lon, got {0}', lon) util.assert(LatLon.isValidLat(lat), 'Invalid lat, got {0}', lat) util.assert(LatLon.isValidLon(lon), 'Invalid lon, got {0}', lon) builder.lat = lat builder.lon = lon return builder } NodeBuilder.prototype.withPosition = withPosition NodeBuilder.withPosition = withPosition /** * Declares the tags to be assigned to the new node. * * The method can be used in a static and in an instance context. * * @example * import { NodeBuilder } from 'josm/builder' * * // a new global node with the global id 1111 and tags name=test and * // highway=road * const n1 = NodeBuilder.withTags({'name':'test', 'highway':'road'}).create(1111) * * // a new local node with tags name=test and highway=road * const tags = { * 'name' : 'test', * 'highway' : 'road' * } * const n2 = NodeBuilder.withTags(tags).create() * * @param {object} [tags] the tags * @returns {module:josm/builder/node~NodeBuilder} the node builder (for method chaining) * @memberof module:josm/builder/node~NodeBuilder * @instance */ function withTags (tags) { const builder = receiver(this) rememberTags(builder, tags) return builder } NodeBuilder.prototype.withTags = withTags NodeBuilder.withTags = withTags /** * Declares the global node id and the global node version. * * The method can be used in a static and in an instance context. * * @param {number} id the global node id. A number &amp;gt; 0. * @param {number} [version=1] optional the global node version. If present, * a number &amp;gt; 0. * @returns {module:josm/builder/node~NodeBuilder} the node builder (for method chaining) * @memberof module:josm/builder/node~NodeBuilder * @instance */ function withId (id, version) { const builder = receiver(this) rememberId(builder, id, version) return builder } NodeBuilder.prototype.withId = withId NodeBuilder.withId = withId Ã— Search results Close "},"josm_builder_relation-builder.mjs.html":{"id":"josm_builder_relation-builder.mjs.html","title":"Source: josm/builder/relation-builder.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/builder/relation-builder.mjs /** * @module josm/builder/relation * @example * import {RelationBuilder} from 'josm/builder' * // creates a new relation with no tags and a * // local id * const relation = RelationBuilder.create() */ /* global Java */ // -- imports const Node = Java.type('org.openstreetmap.josm.data.osm.Node') const Way = Java.type('org.openstreetmap.josm.data.osm.Way') const Relation = Java.type('org.openstreetmap.josm.data.osm.Relation') const RelationMember = Java.type('org.openstreetmap.josm.data.osm.RelationMember') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const OsmPrimitive = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitive') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const List = Java.type('java.util.List') import * as util from 'josm/util' import { assertGlobalId, rememberId, rememberTags, assignTags, rememberIdFromObject, rememberVersionFromObject, checkLat, checkLon, rememberPosFromObject, rememberTagsFromObject } from './common' function receiver (that) { return typeof that === 'object' ? that : new RelationBuilder() } /** * RelationBuilder helps to create OSM * {@class org.openstreetmap.josm.data.osm.Relation}s. * * Methods of RelationBuilder can be used in a static and in an instance * context. * It isn't necessary to create an instance of RelationBuilder, unless it is * configured with a {@class org.openstreetmap.josm.data.osm.DataSet} to * which created ways are added. * @example * import {RelationBuilder} from 'josm/builder' * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const ds = new DataSet() * // create a relation builder without and underlying dataset ... * let rbuilder = new RelationBuilder() * // ... with an underlying dataset ... * rbuilder = new RelationBuilder(ds) * // ... or using this factory method * rbuilder = RelationBuilder.forDataSet(ds) * * // create a new local relation * const r1 = rbuilder.create() * * // create a new global way * const r2 = rbuilder.withTags({route: 'bicycle'}).create(1111) * * // create a new proxy for a global relation * // (an 'incomplete' node in JOSM terminology) * const r3 = rbuilder.createProxy(2222) * * @class * @param {org.openstreetmap.josm.data.osm.DataSet} ds (optional) a JOSM * dataset which created ways are added to. If missing, the created ways * aren't added to a dataset. * @name RelationBuilder * @summary Helps to create {@class org.openstreetmap.josm.data.osm.Relation}s */ export function RelationBuilder(ds) { if (util.isSomething(ds)) { util.assert(ds instanceof DataSet, 'Expected a DataSet, got {0}', ds) this.ds = ds } this.members = [] } /** * Creates or configures a RelationBuilder which will add created nodes * to the dataset &lt;code&gt;ds&lt;/code&gt;. * * @example * import {RelationBuilder} = 'josm/builder' * * // create a new relation builder building to a data set * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * const ds = new DataSet() * const rb1 = RelationBuilder.forDataSet(ds) * * // configure an existing relation builder * let rb2 = new RelationBuilder() * rb2 = rb2.forDataSet(ds) * * @return {module:josm/builder/relation~RelationBuilder} the relation builder * @param {org.openstreetmap.josm.data.osm.DataSet} ds a JOSM * dataset which created ways are added to. * @memberof module:josm/builder/relation~RelationBuilder */ function forDataSet (ds) { const builder = receiver(this) util.assert(util.isSomething(ds), 'Expected a non-null defined object, got {0}', ds) util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) builder.ds = ds return builder } RelationBuilder.prototype.forDataSet = forDataSet RelationBuilder.forDataSet = forDataSet /** * Create a RelationMember * * &lt;dl&gt; * &lt;dt&gt;member(role, obj)&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Create a relation member with role &lt;var&gt;role&lt;/var&gt; and member object * &lt;var&gt;obj&lt;/var&gt;. &lt;var&gt;role&lt;/var&gt; can be null or undefined, obj must neither * be null nor undefinde. &lt;var&gt;role&lt;/var&gt; is a string, &lt;var&gt;obj&lt;/var&gt; is an * OSM node, a way, or a relation. * &lt;/dd&gt; * &lt;dt&gt;member(obj)&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Create a relation member for the member object &lt;var&gt;obj&lt;/var&gt;. * &lt;var&gt;obj&lt;/var&gt; must neither be null nor undefinde. &lt;var&gt;obj&lt;/var&gt; is an * OSM node, a way, or a relation. The created relation member has no role. * &lt;/dd&gt; * &lt;/dl&gt; * * @example * import {RelationBuilder, NodeBuilder} from 'josm/builder' * * // create a new RelationMember with role 'house' for a new node * const m1 = RelationBuilder.member('house', NodeBuilder.create()) * // create a new RelationMember with an empty role for a new node * const m2 = RelationBuilder.member(NodeBuilder.create()) * * @static * @returns {org.openstreetmap.josm.data.osm.RelationMember} the relation member * @summary Utility function - creates a relation member * @memberof module:josm/builder/relation~RelationBuilder * @param {string} [role] the member role * @param {primitive} primitive the member primitive */ function member () { function normalizeObj (obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined') util.assert(obj instanceof OsmPrimitive, 'obj: expected an OsmPrimitive, got {0}', obj) return obj } function normalizeRole (role) { if (util.isNothing(role)) return null util.assert(util.isString(role), 'role: expected a string, got {0}', role) return role } let obj let role switch (arguments.length) { case 0: util.assert(false, 'Expected arguments (object) or (role, object), got 0 arguments') break case 1: obj = normalizeObj(arguments[0]) return new RelationMember(null /* no role */, obj) case 2: role = normalizeRole(arguments[0]) obj = normalizeObj(arguments[1]) return new RelationMember(role, obj) default: util.assert(false, 'Expected arguments (object) or (role, object), got {0} arguments', arguments.length) } } RelationBuilder.member = member /** * Declares the global relation id and the global relation version. * * The method can be used in a static and in an instance context. * * @example * import {RelationBuilder} from 'josm/builder' * // creates a global relation with id 1111 an version 22 * const r = RelationBuilder.withId(1111, 22).create() * * @param {number} id the global relation id. A number &amp;gt; 0. * @param {number} [version=1] the global relation version. If present, * a number &amp;gt; 0 * @returns {module:josm/builder/relation~RelationBuilder} the relation builder (for method chaining) * @memberof module:josm/builder/relation~RelationBuilder * @instance */ function withId (id, version) { const builder = receiver(this) rememberId(builder, id, version) return builder } RelationBuilder.prototype.withId = withId RelationBuilder.withId = withId /** * Declares the tags to be assigned to the new relation. * * The method can be used in a static and in an instance context. * * @example * import {RelationBuilder} from 'josm/builder' * // a new global relation with the global id 1111 and tags route='bicycle' * //and name='n8' * const r1 = RelationBuilder.withTags({name:'n8', route:'bicycle'}).create(1111) * * // a new local relation with tags name=test and highway=road * const tags = { * name : 'n8', * route : 'bicycle' * } * const r2 = RelationBuilder.withTags(tags).create() * * @param {object} [tags] the tags * @returns {module:josm/builder/relation~RelationBuilder} a relation builder (for method chaining) * @memberof module:josm/builder/relation~RelationBuilder * @instance */ function withTags (tags) { const builder = receiver(this) rememberTags(builder, tags) return builder } RelationBuilder.prototype.withTags = withTags RelationBuilder.withTags = withTags /** * Creates a new &lt;em&gt;proxy&lt;/em&gt; relation. A proxy relation is a relation, * for which we only know its global id. In order to know more details * (members, tags, etc.), we would have to download it from the OSM server. * * * The method can be used in a static and in an instance context. * * @example * import {RelationBuilder} from 'josm/builder' * * // a new proxy relation for the global way with id 1111 * const r1 = RelationBuilder.createProxy(1111) * * @returns {org.openstreetmap.josm.data.osm.Relation} the new proxy relation * @memberof module:josm/builder/relation~RelationBuilder * @instance * @param {number} id the id for the proxy relation */ function createProxy (id) { const builder = receiver(this) if (util.isDef(id)) { util.assert(util.isNumber(id) &amp;&amp; id &gt; 0, 'Expected a number &gt; 0, got {0}', id) builder.id = id } util.assert(util.isNumber(builder.id), 'way id is not a number. Use .createProxy(id) or ' + '.withId(id).createProxy()') util.assert(builder.id &gt; 0, 'Expected id &gt; 0, got {0}', builder.id) const relation = new Relation(builder.id) if (builder.ds) builder.ds.addPrimitive(relation) return relation } RelationBuilder.createProxy = createProxy RelationBuilder.prototype.createProxy = createProxy /** * Declares the members of a relation. * * Accepts either a vararg list of relation members, nodes, ways or * relations, an array of relation members, nodes ways or relations, or a * Java list of members, nodes, ways or relation. * * The method can be used in a static and in an instance context. * * @example * import {RelationBuilder, NodeBuilder} from 'josm/builder' * const {member} = RelationBuilder * const r1 = RelationBuilder.withMembers( * member('house', NodeBuilder.create()), * member('house', NodeBuilder.create()) * ) * .create() * * const members = [ * NodeBuilder.create(), // empty role * member('house', NodeBuilder.create() * ] * * const r2 = RelationBuilder.withMembers( * members, * NodeBuilder.create(), * ).create() * * @param { * ...(org.openstreetmap.josm.data.osm.OsmPrimitive * | org.openstreetmap.josm.data.osm.RelationMember * | Array.&lt;OsmPrimitive | RelationMember&gt; * | java.util.List) * } members the list of members. See description and examples. * @returns {module:josm/builder/relation~RelationBuilder} the relation builder (for method chaining) * @memberof module:josm/builder/relation~RelationBuilder * @instance */ function withMembers () { const builder = receiver(this) const members = [] function remember (obj) { if (util.isNothing(obj)) return if (obj instanceof OsmPrimitive) { members.push(new RelationMember(null, obj)) } else if (obj instanceof RelationMember) { members.push(obj) } else if (util.isArray(obj)) { for (let i = 0; i &lt; obj.length; i++) remember(obj[i]) } else if (obj instanceof List) { for (let it = obj.iterator(); it.hasNext();) remember(it.next()) } else { util.assert(false, \"Can''t add object ''{0}'' as relation member\", obj) } } for (let i = 0; i &lt; arguments.length; i++) { remember(arguments[i]) } builder.members = members return builder } RelationBuilder.withMembers = withMembers RelationBuilder.prototype.withMembers = withMembers function rememberMembersFromObject (builder, args) { if (!util.hasProp(args, 'members')) return const o = args.members if (!util.isSomething(o)) return util.assert(util.isArray(o) || o instanceof List, 'members: Expected an array or an instance of java.util.List, got {0}', o) builder.withMembers(o) } function initFromObject (builder, args) { rememberIdFromObject(builder, args) rememberVersionFromObject(builder, args) rememberTagsFromObject(builder, args) rememberMembersFromObject(builder, args) } /** * Named options for {@link module:josm/builder/relation~RelationBuilder#create create} * * @typedef RelationBuilderOptions * @property {number} [id] the id (&amp;gt 0) of the way. Default: creates new local id. * @property {number} [version=1] the version (&amp;gt 0) of the way. Default: 1. * @property {object} [tags] an object with tags. Null values and undefined * values are ignored. Any other value is converted to a string. * Leading and trailing white space in keys is removed. * @property {org.openstreetmap.josm.data.osm.RelationMember[]|java.util.List} [members] the member for the relation * @memberOf module:josm/builder/relation~RelationBuilder * @example * import {RelationBuilder, NodeBuilder} from 'josm/builder' * const {member} = RelationBuilder * // options to create a relation * const options = { * version: 3, * tags: {type: 'route'}, * members: [ * member('house', NodeBuilder.create()), * member(NodeBuilder.create()) * ] * } */ /** * Creates a new relation. * * Can be used in an instance or in a static context. * * @example * import { NodeBuilder, RelationBuilder } from 'josm/builder' * const member = RelationBuilder.member * // create a new local relation * const r1 = RelationBuilder.create() * * // create a new global relation * const r2 = RelationBuilder.create(1111) * * // create a new global relation with version 3 with some tags and two * // members * const r3 = RelationBuilder.create(2222, { * version: 3, * tags: {type: 'route'}, * members: [ * member('house', NodeBuilder.create()), * member(NodeBuilder.create()) * ] * }) * * @param {number} [id] a global way id. If missing and not set * before using &lt;code&gt;withId(..)&lt;/code&gt;, creates a new local id. * @param {module:josm/builder/relation~RelationBuilder.RelationBuilderOptions} [options] options for creating the relation * @returns {org.openstreetmap.josm.data.osm.Relation} the relation * @memberof module:josm/builder/relation~RelationBuilder * @instance */ function create () { const builder = receiver(this) let arg switch (arguments.length) { case 0: break case 1: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') if (util.isNumber(arg)) { util.assert(arg &gt; 0, 'Argument 0: expected an id &gt; 0, got {0}', arg) builder.id = arg } else if (typeof arg === 'object') { initFromObject(builder, arg) } else { util.assert(false, \"Argument 0: unexpected type, got ''{0}''\", arg) } break case 2: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(arg), 'Argument 0: must be a number') util.assert(arg &gt; 0, 'Expected an id &gt; 0, got {0}', arg) builder.id = arg arg = arguments[1] if (util.isSomething(arg)) { util.assert(typeof arg === 'object', 'Argument 1: must be an object') initFromObject(builder, arg) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } let relation if (util.isNumber(builder.id)) { if (util.isNumber(builder.version)) { relation = new Relation(builder.id, builder.version) } else { relation = new Relation(builder.id, 1) } } else { relation = new Relation(0) // creates a new local reÃ¶atopm } assignTags(relation, builder.tags || {}) if (builder.members &amp;&amp; builder.members.length &gt; 0) { relation.setMembers(builder.members) } if (builder.ds) { if (builder.ds.getPrimitiveById(relation) == null) { builder.ds.addPrimitive(relation) } else { throw new Error( 'Failed to add primitive, primitive already included ' + 'in dataset. \\n' + 'primitive=' + relation ) } } return relation } RelationBuilder.create = create RelationBuilder.prototype.create = create Ã— Search results Close "},"josm_builder_way-builder.mjs.html":{"id":"josm_builder_way-builder.mjs.html","title":"Source: josm/builder/way-builder.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/builder/way-builder.mjs /** * @module josm/builder/way */ /* global Java */ // -- imports const Node = Java.type('org.openstreetmap.josm.data.osm.Node') const Way = Java.type('org.openstreetmap.josm.data.osm.Way') const Relation = Java.type('org.openstreetmap.josm.data.osm.Relation') const RelationMember = Java.type('org.openstreetmap.josm.data.osm.RelationMember') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const OsmPrimitive = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitive') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const List = Java.type('java.util.List') import * as util from 'josm/util' import { assertGlobalId, rememberId, rememberTags, assignTags, rememberIdFromObject, rememberVersionFromObject, checkLat, checkLon, rememberPosFromObject, rememberTagsFromObject } from './common' function receiver (that) { return typeof that === 'object' ? that : new WayBuilder() } /** * WayBuilder helps to create OSM * {@class org.openstreetmap.josm.data.osm.Way}s. * * Methods of WayBuilder can be used in a static and in an instance context. * It isn't necessary to create an instance of WayBuilder, unless it is * configured with a {@class org.openstreetmap.josm.data.osm.DataSet}, * to which created ways are added. * @example * import {WayBuilder} from 'josm/builder' * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const ds = new DataSet() * // create a way builder without and underlying dataset ... * let wbuilder = new WayBuilder() * // ... with an underlying dataset .... * wbuilder = new WayBuilder(ds) * // ... or using this factory method * wbuilder = WayBuilder.forDataSet(ds) * * * // create a new local way * const w1 = wbuilder.create() * * // create a new global way * const w2 = wbuilder.withTags({highway: 'residential'}).create(1111) * * // create a new proxy for a global way * // (an 'incomplete' node in JOSM terminology) * const w3 = wbuilder.createProxy(2222) * * @class * @param {org.openstreetmap.josm.data.osm.DataSet} [ds] a JOSM * dataset to which created ways are added. If missing, the created ways * aren't added to a dataset. * @summary Helps to create OSM {@class org.openstreetmap.josm.data.osm.Way}s * @name WayBuilder */ /** * Creates a new WayBuilder with an underlying dataset. * * @return {module:josm/builder/way~WayBuilder} the way builder * @param {org.openstreetmap.josm.data.osm.DataSet} ds the dataset which * created objects are added to * @summary Creates a new WayBuilder with an underlying dataset. * @class * @memberof module:josm/builder/way~WayBuilder * @name WayBuilder */ export function WayBuilder(ds) { if (util.isSomething(ds)) { util.assert(ds instanceof DataSet, 'Expected a DataSet, got {0}', ds) this.ds = ds } this.nodes = [] } /** * Creates or configures a WayBuilder which will add created nodes * to the dataset &lt;code&gt;ds&lt;/code&gt;. * * @example * import {DataSet, WayBuilder} from 'josm/builder' * * // create a new way builder which builds to a data set * const ds = new DataSet() * let wb = WayBuilder.forDataSet(ds) * * @return {module:josm/builder/way~WayBuilder} the way builder * @param {org.openstreetmap.josm.data.osm.DataSet} ds the dataset to which * created objects are added * @memberof module:josm/builder/way~WayBuilder * @instance */ function forDataSet (ds) { const builder = receiver(this) util.assert(util.isSomething(ds), 'Expected a non-null defined object, got {0}', ds) util.assert(ds instanceof DataSet, 'Expected a JOSM dataset, got {0}', ds) builder.ds = ds return builder } WayBuilder.prototype.forDataSet = forDataSet WayBuilder.forDataSet = forDataSet /** * Declares the global way id and the global way version. * * The method can be used in a static and in an instance context. * * @example * import {WayBuilder} from 'josm/builder' * // creates a global way with id 1111 an version 22 * const way = WayBuilder.withId(1111, 22).create() * * @param {number} id (mandatory) the global way id. A number &gt; 0. * @param {number} [version] the global way version. If present, * a number &gt; 0. If missing, the version 1 is assumed. * @return {module:josm/builder/way~WayBuilder} the way builder (for method chaining) * @memberof module:josm/builder/way~WayBuilder * @instance */ function withId (id, version) { const builder = receiver(this) rememberId(builder, id, version) return builder } WayBuilder.prototype.withId = withId WayBuilder.withId = withId /** * Declares the tags to be assigned to the new way. * * The method can be used in a static and in an instance context. * * @example * import {WayBuilder} from 'josm/builder' * // a new global way with the global id 1111 and tags name='Laubeggstrasse' * // and highway=residential * const w1 = WayBuilder.withTags({name:'Laubeggstrasse', highway:'residential'}) * .create(1111) * * // a new local way with tags name=test and highway=road * const tags = { * name : 'Laubeggstrasse', * highway : 'residential' * } * const w2 = WayBuilder.withTags(tags).create() * * @param {object} [tags] the tags * @return {module:josm/builder/way~WayBuilder} the way builder (for method chaining) * @memberof module:josm/builder/way~WayBuilder * @instance */ function withTags (tags) { const builder = receiver(this) rememberTags(builder, tags) return builder } WayBuilder.prototype.withTags = withTags WayBuilder.withTags = withTags /** * Declares the nodes of the way. * * Accepts either a vararg list of * {@class org.openstreetmap.josm.data.osm.Node}, * an array of {@class org.openstreetmap.josm.data.osm.Node}s or a Java list * of {@class org.openstreetmap.josm.data.osm.Node}s. At least &lt;strong&gt;two * non-identical nodes&lt;/strong&gt; have to be supplied. * The same node can occure more than once in the list, but a consecutive * sequence of the same node is collapsed to one node. * * * The method can be used in a static and in an instance context. * * @example * import {WayBuilder, NodeBuilder} from 'josm/builder' * // creates a new local way with two local nodes * const way = WayBuilder.withNodes( * NodeBuilder.create(), * NodeBuilder.create() * ).create() * * @param {...org.openstreetmap.josm.data.osm.Node | java.util.List | org.openstreetmap.josm.data.osm.Node[]} [nodes] the list of nodes. * See description and examples. * @return {module:josm/builder/way~WayBuilder} the way builder (for method chaining) * @memberof module:josm/builder/way~WayBuilder * @instance */ function withNodes () { const builder = receiver(this) let nodes switch (arguments.length) { case 0: return builder case 1: nodes = arguments[0] if (util.isNothing(nodes)) return builder if (nodes instanceof Node) { nodes = [nodes] } else if (util.isArray(nodes)) { // OK } else if (nodes instanceof List) { const temp = [] for (let it = nodes.iterator(); it.hasNext();) temp.push(it.next()) nodes = temp } else { util.assert(false, 'Argument 0: expected a Node or a list of nodes, got {0}', nodes) } break default: nodes = Array.prototype.slice.call(arguments, 0) break } const newnodes = [] let last for (let i = 0; i &lt; nodes.length; i++) { const n = nodes[i] if (util.isNothing(n)) continue util.assert(n instanceof Node, 'Expected instances of Node only, got {0} at index {1}', n, i) // skip sequence of identical nodes if (last &amp;&amp; last.getUniqueId() === n.getUniqueId()) continue newnodes.push(n) last = n } builder.nodes = newnodes return builder } WayBuilder.withNodes = WayBuilder.prototype.withNodes = withNodes /** * Creates a new &lt;em&gt;proxy&lt;/em&gt; way. A proxy way is a way for which we * only know its global id. In order to know more details (nodes, tags, etc.), * we would have to download it from the OSM server. * * The method can be used in a static and in an instance context. * * @example * import {WayBuilder} from 'josm/builder' * * // a new proxy way for the global way with id 1111 * const w1 = WayBuilder.createProxy(1111) * * @param {number} id the id. A number &amp;gt; 0 * @return {org.openstreetmap.josm.data.osm.Way} the new proxy way * @memberof module:josm/builder/way~WayBuilder * @instance */ function createProxy (id) { const builder = receiver(this) if (util.isDef(id)) { util.assert(util.isNumber(id) &amp;&amp; id &gt; 0, 'Expected a number &gt; 0, got {0}', id) builder.id = id } util.assert(util.isNumber(builder.id), 'way id is not a number. Use .createProxy(id) or ' + '.withId(id).createProxy()') util.assert(builder.id &gt; 0, 'Expected way id &gt; 0, got {0}', builder.id) const way = new Way(builder.id) if (builder.ds) builder.ds.addPrimitive(way) return way } WayBuilder.createProxy = WayBuilder.prototype.createProxy = createProxy function rememberNodesFromObject (builder, args) { if (!util.hasProp(args, 'nodes')) return const o = args.nodes if (!util.isSomething(o)) return util.assert(util.isArray(o) || o instanceof List, 'Expected an array or an instance of java.util.List, got {0}', o) builder.withNodes(o) } function initFromObject (builder, args) { rememberIdFromObject(builder, args) rememberVersionFromObject(builder, args) rememberTagsFromObject(builder, args) rememberNodesFromObject(builder, args) } /** * Named options for {@link module:josm/builder/way~WayBuilder#create create} * * @typedef WayBuilderOptions * @property {number} [id] the id (&amp;gt 0) of the way. Default: creates new local id. * @property {number} [version=1] the version (&amp;gt 0) of the way. Default: 1. * @property {object} [tags] an object with tags. Null values and undefined * values are ignored. Any other value is converted to a string. * Leading and trailing white space in keys is removed. * @property {org.openstreetmap.josm.data.osm.Node[]|java.util.List} [nodes] the nodes for the way. * @memberOf module:josm/builder/way~WayBuilder * @example * import {NodeBuilder} from 'josm/builder' * // options to create a way * const options = { * version: 3, * tags: {highway: 'primary'}, * nodes: [ * NodeBuilder.withPosition(1,1).create(), * NodeBuilder.withPosition(2,2).create(), * NodeBuilder.withPosition(3,3).create() * ] * } */ /** * Creates a new way. * * Can be used in an instance or in a static context. * * @example * import {WayBuilder, NodeBuilder} from 'josm/builder' * // create a new local way * const w1 = WayBuilder.create() * * // create a new global way * const w2 = WayBuilder.create(1111) * * // create a new global way with version 3 with some nodes and with * // some tags * const w3 = WayBuilder.create(2222, { * version: 3, * tags: {higway: 'primary'}, * nodes: [ * NodeBuilder.withPosition(1,1).create(), * NodeBuilder.withPosition(2,2).create(), * NodeBuilder.withPosition(3,3).create() * ] * }) * * @param {number} [id] a global way id. If missing and not set * before using &lt;code&gt;withId(..)&lt;/code&gt;, creates a new local id. * @param {module:josm/builder/way~WayBuilder.WayBuilderOptions} [options] additional parameters for creating the way * @returns {org.openstreetmap.josm.data.osm.Way} the created way * @memberof module:josm/builder/way~WayBuilder * @instance */ function create () { const builder = receiver(this) let arg switch (arguments.length) { case 0: break case 1: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') if (util.isNumber(arg)) { util.assert(arg &gt; 0, 'Argument 0: expected an id &gt; 0, got {0}', arg) builder.id = arg } else if (typeof arg === 'object') { initFromObject(builder, arg) } else { util.assert(false, \"Argument 0: unexpected type, got ''{0}''\", arg) } break case 2: arg = arguments[0] util.assert(util.isSomething(arg), 'Argument 0: must not be null or undefined') util.assert(util.isNumber(arg), 'Argument 0: must be a number') util.assert(arg &gt; 0, 'Expected an id &gt; 0, got {0}', arg) builder.id = arg arg = arguments[1] if (util.isSomething(arg)) { util.assert(typeof arg === 'object', 'Argument 1: must be an object') initFromObject(builder, arg) } break default: util.assert(false, 'Unexpected number of arguments, got {0}', arguments.length) } let way if (util.isNumber(builder.id)) { if (util.isNumber(builder.version)) { way = new Way(builder.id, builder.version) } else { way = new Way(builder.id, 1) } } else { way = new Way(0) // creates a new local way } assignTags(way, builder.tags || {}) if (builder.nodes &amp;&amp; builder.nodes.length &gt; 0) { way.setNodes(builder.nodes) } if (builder.ds) { if (builder.ds.getPrimitiveById(way) == null) { builder.ds.addPrimitive(way) } else { throw new Error( 'Failed to add primitive, primitive already included ' + 'in dataset. ' + 'primitive=' + way ) } } return way } WayBuilder.create = create WayBuilder.prototype.create = create Ã— Search results Close "},"josm_command.mjs.html":{"id":"josm_command.mjs.html","title":"Source: josm/command.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/command.mjs /** * A collection of functions to create commands which can be applied, undone * and redone on {@class org.openstreetmap.josm.gui.layer.OsmDataLayer}s. * * @module josm/command * @example * import { * buildAddCommand, * buildChangeCommand, * buildDeleteCommand * } from 'josm/command' */ /* global Java */ /* global Plugin */ const AddMultiCommand = Plugin.type('org.openstreetmap.josm.plugins.scripting.js.api.AddMultiCommand') const ChangeMultiCommand = Plugin.type('org.openstreetmap.josm.plugins.scripting.js.api.ChangeMultiCommand') const Change = Plugin.type('org.openstreetmap.josm.plugins.scripting.js.api.Change') import * as util from 'josm/util' import layers from 'josm/layers' const OsmPrimitive = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitive') const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') const Layer = Java.type('org.openstreetmap.josm.gui.layer.Layer') const UndoRedoHandler = Java.type('org.openstreetmap.josm.data.UndoRedoHandler') const CombineWayAction = Java.type('org.openstreetmap.josm.actions.CombineWayAction') const JavaDeleteCommand = Java.type('org.openstreetmap.josm.command.DeleteCommand') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const RelationMember = Java.type('org.openstreetmap.josm.data.osm.RelationMember') const ArrayList = Java.type('java.util.ArrayList') const Map = Java.type('java.util.Map') const HashMap = Java.type('java.util.HashMap') const HashSet = Java.type('java.util.HashSet') const Collection = Java.type('java.util.Collection') const Command = Java.type('org.openstreetmap.josm.command.Command') const System = Java.type('java.lang.System') function checkAndFlatten (primitives) { const ret = new HashSet() function visit (value) { if (util.isNothing(value)) return if (util.isCollection(value)) { util.each(value, visit) } else if (value instanceof OsmPrimitive) { ret.add(value) } else { util.assert(false, 'Unexpected object to add as OSM primitive, got {0}', value) } } visit(primitives) return ret } function toArray (collection) { if (util.isArray(collection)) return collection if (collection instanceof Collection) { const ret = [] for (const it = collection.iterator(); it.hasNext();) ret.push(it.next()) return ret } } class AbstractCommand { /** * Applies the command to a layer. * * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer */ applyTo(layer) { util.assert(util.isSomething(layer), 'layer: must not be null or undefined') util.assert(layer instanceof OsmDataLayer, 'layer: expected OsmDataLayer, got {0}', layer) const cmd = this.createJOSMCommand(layer) try { layer.getDataSet().beginUpdate() UndoRedoHandler.getInstance().add(cmd) } finally { layer.getDataSet().endUpdate() } } ensureOsmDataLayer(layer) { util.assert(util.isSomething(layer), 'layer: must not be null or undefined') util.assert(layer instanceof OsmDataLayer, 'layer: expected OsmDataLayer, got {0}', layer) } } /** * A command to add a collection of objects to a data layer. * * @param { java.util.Collection| array } objs the objects to add */ export class AddCommand extends AbstractCommand { constructor(objs) { super() util.assert(objs, 'objs: mandatory parameter missing') this._objs = toArray(checkAndFlatten(objs)) } /** * Creates the internal JOSM command for this command * * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @returns {org.openstreetmap.josm.command.Command} the command */ createJOSMCommand(layer) { super.ensureOsmDataLayer(layer) const list = new ArrayList() this._objs.forEach(obj =&gt; list.add(obj)) return new AddMultiCommand(layer, list) } } /** * Creates a command to add a collection of objects to a data layer. * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;add(obj, obj, ...)&lt;/code&gt; &lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;code&gt;obj&lt;/code&gt; are {@class org.openstreetmap.josm.data.osm.Node}s, * {@class org.openstreetmap.josm.data.osm.Way}s, or * {@class org.openstreetmap.josm.data.osm.Relations}s. Or javascript array * or Java collections thereof.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import {buildAddCommand} from 'josm/command' * import layers from 'josm/layer' * import {NodeBuilder} from 'josm/builder' * const layer = layers.get('Data Layer 1') * * // add two nodes * buildAddCommand( * NodeBuilder.create(), * NodeBuilder.create() * ).applyTo(layer) * * @param {...(org.openstreetmap.josm.data.osm.OsmPrimitive | org.openstreetmap.josm.data.osm.OsmPrimitive[] | java.lang.Collection )} obj the primitives to add * @returns {module:josm/command.AddCommand} the command object */ export function buildAddCommand(){ const objs = toArray(checkAndFlatten(arguments)) return new AddCommand(objs) } /** * A command to delete a collection of objects in a data layer. * * @param {java.util.Collection|array} objs the objects to add */ export class DeleteCommand extends AbstractCommand { constructor(objs) { super() this._objs = toArray(checkAndFlatten(objs)) } /** * Creates the internal JOSM command for this command * * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @returns {org.openstreetmap.josm.command.Command} the command object */ createJOSMCommand(layer) { super.ensureOsmDataLayer(layer) const list = new ArrayList() this._objs.forEach(obj =&gt; list.add(obj)) return JavaDeleteCommand.delete(list, true /* alsoDeleteNodesInWay */, true /* silent */) } } /** * Creates a command to delete a collection of objects in a data layer. * * @example * import {buildDeleteCommand} from 'josm/command' * import layers from 'josm/layer' * import {NodeBuilder} from 'josm/builder' * const layer = layers.get('Data Layer 1') * // delete two nodes * buildDeleteCommand(NodeBuilder.create(),NodeBuilder.create()).applyTo(layer) * * * @param {...(org.openstreetmap.josm.data.osm.OsmPrimitive | org.openstreetmap.josm.data.osm.OsmPrimitive[] | java.lang.Collection )} obj the primitives to delete * @returns {module:josm/command.DeleteCommand} the command object */ export function buildDeleteCommand() { return new DeleteCommand(toArray(checkAndFlatten(arguments))) } function scheduleLatChangeFromPara (para, change) { if (!para || !util.isDef(para.lat)) return util.assert(util.isNumber(para.lat), 'lat: lat must be a number, got {0}', para.lat) util.assert(LatLon.isValidLat(para.lat), 'lat: expected a valid lat, got {0}', para.lat) change.withLatChange(para.lat) } function scheduleLonChangeFromPara (para, change) { if (!para || !util.isDef(para.lon)) return util.assert(util.isNumber(para.lon), 'lon: lon must be a number, got {0}', para.lon) util.assert(LatLon.isValidLon(para.lon), 'lon: expected a valid lon, got {0}', para.lon) change.withLonChange(para.lon) } function buildLatLon (obj) { util.assert(util.isSomething(obj), 'obj: must not be null or undefined') util.assert(typeof obj === 'object', 'obj: expected an object, got {0}', obj) util.assert(util.isNumber(obj.lat), 'obj.lat: expected a number, got {0}', obj.lat) util.assert(util.isNumber(obj.lon), 'obj.lon: expected a number, got {0}', obj.lon) util.assert(LatLon.isValidLat(obj.lat), 'obj.lat: expected a valid lat in the range [-90,90], got {0}', obj.lat) util.assert(LatLon.isValidLon(obj.lon), 'obj.lon: expected a valid lon in the range [-180,180], got {0}', obj.lon) return new LatLon(obj.lat, obj.lon) } function schedulePosChangeFromPara (para, change) { if (!para || !util.isDef(para.pos)) return util.assert(para.pos, 'pos must no be null') let pos = para.pos if (pos instanceof LatLon) { // OK } else if (typeof pos === 'object') { pos = buildLatLon(pos) } else { util.assert(false, 'pos: unexpected value, expected LatLon or object, got {0}', pos) } change.withPosChange(pos) } function scheduleNodeChangeFromPara (para, change) { if (!para || !util.isDef(para.nodes)) return // convert to a Java List ... const l = new ArrayList() for (let i = 0; i &lt; para.nodes.length; i++) { l.add(para.nodes[i]) } // ... and pass it to the change command change.withNodeChange(l) } function scheduleMemberChangeFromPara (para, change) { if (!para || !util.isDef(para.members)) return const l = new ArrayList() if (para.members instanceof RelationMember) { l.add(para.members) } else if (para.members instanceof Collection) { l.addAll(para.members) } else if (util.isArray(para.members)) { for (let i = 0; i &lt; para.members.length; i++) { l.add(para.members[i]) } } else { util.assert(false, 'Expected RelationMember, array or collection ' + 'of RelationMembers, got {0}', para.members) } change.withMemberChange(l) } function scheduleTagsChangeFromPara (para, change) { if (!para || !util.isDef(para.tags)) return util.assert(para.tags, 'tags must no be null') let tags = para.tags if (tags instanceof Map) { // OK } else if (typeof tags === 'object') { const map = new HashMap() for (let key in tags) { if (!util.hasProp(tags, key)) continue const value = tags[key] key = util.trim(key) map.put(key, value) } tags = map } else { util.assert(false, 'tags: unexpected value, expected Map or object, got {0}', tags) } change.withTagsChange(tags) } function changeFromParameters (para) { const change = new Change() scheduleLatChangeFromPara(para, change) scheduleLonChangeFromPara(para, change) schedulePosChangeFromPara(para, change) scheduleTagsChangeFromPara(para, change) scheduleNodeChangeFromPara(para, change) scheduleMemberChangeFromPara(para, change) return change } /** * A command to change a collection of objects in a data layer. * * @param {java.util.Collection|array} objs the objects to change * @param {org.openstreetmap.josm.plugins.scripting.js.api.Change} change the change specification */ export class ChangeCommand extends AbstractCommand { constructor(objs, change) { super() this._objs = toArray(checkAndFlatten(objs)) this._change = change } /** * Creates the internal JOSM command for this command * * @param {org.openstreetmap.josm.gui.layer.OsmDataLayer} layer the data layer * @returns {org.openstreetmap.josm.command.Command} the command object */ createJOSMCommand(layer) { super.ensureOsmDataLayer(layer) const list = new ArrayList() this._objs.forEach(obj =&gt; list.add(obj)) return new ChangeMultiCommand(layer, list, this._change) } } /** * A lat/lon position as a JavaScript object. * * @typedef {Object} LatLonSpec * @property {number} lat the latitude of the position * @property {number} lon the longitude of the position * @example * const latLonSpec = { * lat: 1.0, * lon: 1.0 * } */ /** * The change specification for a change command. * * @typedef {Object} ChangeSpec * @property {number} lat if present and applied to a node, changes the nodes latitude * @property {number} lon if present and applied to a node, changes the nodes longitude * @property {org.openstreetmap.josm.data.coor.LatLon| module:josm/command~LatLonSpec} pos if present and applied to a node, * changes the nodes position * @property {java.util.Map | object} tags if present, changes the tags of the target object * @property {java.util.List | org.openstreetmap.josm.data.osm.OsmPrimitive[]} nodes if present and applied to a way, changes * the ways nodes * @property {java.util.List | org.openstreetmap.josm.data.osm.RelationMember[]} nodes if present and applied to a relation, changes * the relations members * * @example * // change the positon of a node * const changeSpec1 = { * lat: 1.0, * lon: 2.0 * } * * // change the tags of one or more primitives * const changeSpec2 = { * tags: { * amentity: 'restaurant' * } * } */ /** * Creates a command to change a collection of objects in a data layer. * * The mandatory last argument is an object with named parameters. * * @example * import {buildChangeCommand} from 'josm/command' * import layers from 'josm/layers' * const layer = layers.get(\"Data Layer 1\") * * // change the position of a node * buildChangeCommand(n1, {lat: 123.45, lon: 44.234}).applyTo(layer) * * // change the tags of a collection of primitives * buildChangeCommand(n1, n3, w1, r1, { * tags: {'mycustomtag': 'value'} * }).applyTo(layer) * * @returns {module:josm/command.ChangeCommand} the change command object * @param {...(org.openstreetmap.josm.data.osm.OsmPrimitive | org.openstreetmap.josm.data.osm.OsmPrimitive[] | java.lang.Collection )} objs the objects to change. See documentation. * @param {module:josm/command~ChangeSpec} change the change specification */ export function buildChangeCommand() { let objs = [] let change switch (arguments.length) { case 0: util.assert(false, 'Unexpected number of arguments, got {0} arguments', arguments.length) break default: { const a = arguments[arguments.length - 1] if (a instanceof OsmPrimitive) { util.assert(false, 'Argument {0}: unexpected last argument, expected named ' + 'parameters, got {0}', a) } else if (typeof a === 'object') { // last argument is an object with named parameters objs = Array.prototype.slice.call(arguments, 0, -1) change = changeFromParameters(a) } else { util.assert(false, 'Argument {0}: unexpected type of value, got {1}', arguments.length - 1, a) } } } const tochange = checkAndFlatten(objs) return new ChangeCommand(tochange, change) } /** * Accessor to the global command history. * &lt;p&gt; * Provides static methods to redo and undo commands. * * @summary Accessor to the global command history */ export class CommandHistory { /** * Undoes the last &lt;code&gt;depth&lt;/code&gt; commands. * * @param {number} [depth=1] the number of commands to be undone */ static undo(depth) { if (util.isDef(depth)) { util.assert(util.isNumber(depth), 'depth: expected a number, got {0}', depth) util.assert(depth &gt; 0, 'depth: expected number &gt; 0, got {0}', depth) } const undoRedoHandler = UndoRedoHandler.getInstance() if (depth) { undoRedoHandler.undo(depth) } else { undoRedoHandler.undo() } } /** * Redoes the last &lt;code&gt;depth&lt;/code&gt; commands. * * @param {number} [depth=1] the number of commands to be redone. */ static redo(depth) { if (util.isDef(depth)) { util.assert(util.isNumber(depth), 'depth: expected a number, got {0}', depth) util.assert(depth &gt; 0, 'depth: expected number &gt; 0, got {0}', depth) } const undoRedoHandler = UndoRedoHandler.getInstance() if (depth) { undoRedoHandler.redo(depth) } else { undoRedoHandler.redo() } } /** * Removes commands in the command history, either all commands, or only the * commands applied to a specific layer. * * @param {org.openstreetmap.josm.gui.layer.Layer} [layer] the * reference layer. Only commands applied to this layer are removed. Default * if missing: &lt;strong&gt;all&lt;/strong&gt; commands are removed. */ static clear(layer) { const undoRedoHandler = UndoRedoHandler.getInstance() function clearAll () { undoRedoHandler.clean() } function clearForLayer (layer) { undoRedoHandler.clean(layer) } switch (arguments.length) { case 0: clearAll(); break case 1: { const layer = arguments[0] util.assert(layer instanceof Layer, 'Expected a Layer, got {0}', layer) clearForLayer(layer) break } default: util.assert(false, 'Unexpected number of arguments') } } } /** * Combines two or more ways into one resulting way. * &lt;p&gt; * Reuses the logic behind the JOSM standard menu entry Tools-&amp;gt;Combine Ways. * If invoked from a script, this may trigger modal dialogs which are presented * to the user, in particular if the direction of the ways has to be reversed * because otherwise they could not be combined. * * @param ways the ways to be combined * @example * import {combineWays} from 'josm/command' * import layers from 'josm/layer' * const ds = layers.activeLayer.data * const ways = [ds.way(1), ds.way(2), ds.way(3)] * * // pass in an array ... * combineWays(ways) * // ... or the individual ways ... * combineWays(ds.way(1), ds.way(2), ds.way(3)) * // ... or any combination thereof. * * @summary Combines two or more ways into one resulting way. * @param {...org.openstreetmap.josm.data.osm.Way | array} ways the ways to be combined * @static */ export function combineWays() { // ways becomes a java.util.HashSet const ways = checkAndFlatten(arguments) // remove any primitives which are not nodes from the arguments const it = ways.iterator() while (it.hasNext()) { const primitive = it.next() if (primitive == null || !primitive.isWay) { it.remove() } } // at least two remaining ways required to combine them. If less, just // return, don't throw if (ways.size() &lt;= 1) return const activeLayer = layers.activeLayer if (activeLayer == null) return const ret = CombineWayAction.combineWaysWorker(ways) // happens, if combineWayWorkers presents a modal dialog and the user // aborts it if (ret == null) return // ret.b is the SequenceCommand which combines the ways into one // resulting ways. Apply this command to the active layer. activeLayer.apply(ret.b) } /** * Combines the currently selected ways in the active layer into one resulting * way. * * Returns without effect if * &lt;ul&gt; * &lt;li&gt;there is no active layer&lt;/li&gt; * &lt;li&gt;the active layer is not a data layer&lt;/li&gt; * &lt;li&gt;there are less than two selected ways in the active layer&lt;/li&gt; * &lt;/ul&gt; * * Reuses the logic behind the JOSM standard menu entry Tools-&amp;gt;Combine Ways. * If invoked from a script, this may trigger modal dialogs which are presented * to the user, in particular if the direction of the ways has to be reversed * because otherwise they could not be combined. * * @example * import {combineSelectedWays} from 'josm/command' * import layers from 'josm/layer' * const ds = layers.activeLayer.data * combineSelectedWays(ways) * * @summary Combines the currently selected ways. * @static */ export function combineSelectedWays() { const activeLayer = layers.activeLayer if (activeLayer == null) return const ways = activeLayer.data.selection.ways if (ways == null || ways.length &lt;= 1) return combineWays(ways) } Ã— Search results Close "},"josm_ds.mjs.html":{"id":"josm_ds.mjs.html","title":"Source: josm/ds.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/ds.mjs /** * Provides utitly methods for data sets * * @module josm/ds */ /* global Java */ import * as util from 'josm/util' import { NodeBuilder, WayBuilder, RelationBuilder } from 'josm/builder' export const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') const PrimitiveId = Java.type('org.openstreetmap.josm.data.osm.PrimitiveId') export const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') const Collection = Java.type('java.util.Collection') const HashSet = Java.type('java.util.HashSet') const File = Java.type('java.io.File') const FileWriter = Java.type('java.io.FileWriter') const PrintWriter = Java.type('java.io.PrintWriter') const FileInputStream = Java.type('java.io.FileInputStream') const OsmImporter = Java.type('org.openstreetmap.josm.gui.io.importexport.OsmImporter') const OsmChangeImporter = Java.type('org.openstreetmap.josm.gui.io.importexport.OsmChangeImporter') const OsmReader = Java.type('org.openstreetmap.josm.io.OsmReader') const OsmChangeReader = Java.type('org.openstreetmap.josm.io.OsmChangeReader') const Utils = Java.type('org.openstreetmap.josm.tools.Utils') const GZIPInputStream = Java.type('java.util.zip.GZIPInputStream') const OsmWriterFactory = Java.type('org.openstreetmap.josm.io.OsmWriterFactory') const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') const System = Java.type('java.lang.System') function log (msg) { System.out.println(msg) } function normalizeType (type) { if (util.isString(type)) { type = type.trim().toLowerCase() if ('node'.startsWith(type)) { return OsmPrimitiveType.NODE } else if ('way'.startsWith(type)) { return OsmPrimitiveType.WAY } else if ('relation'.startsWith(type)) { return OsmPrimitiveType.RELATION } else { util.assert(false, 'expected type as string, i.e. \"node\", \"way\", or \"relation\", got \"{0}\"', type) } } else if (type instanceof OsmPrimitiveType) { return type } else { util.assert(false, 'expected String or OsmPrimitiveType, got \"{0}\", type') } } function normalizeId (id) { if (util.isNumber(id)) { if (Number.isInteger(id)) { return id } else { util.assert(false, 'expected integer , got \"{0}\"', id) } } else if (util.isString(id)) { const idSaved = id id = parseInt(id.trim()) if (isNaN(id)) { util.assert(false, 'expected integer as string, got \"{0}\"', idSaved) } } else { util.assert(false, 'expected an integer or a string, got \"{0}\"', id) } } /** * Creates an ID for an OSM primitive. * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;buildId(id, type)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies an object given by its unique numeric id and a type. * The type is either a string &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;way&lt;/code&gt;, or * &lt;code&gt;relation&lt;/code&gt;, or one of the symbols * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, or * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;buildId(id)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies an object given an ID. &lt;code&gt;id&lt;/code&gt; is either an instance * of * {@class org.openstreetmap.josm.data.osm.PrimitiveId} or an object with * the properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, i.e. * &lt;code&gt;{id: 1234, type: 'node'}&lt;/code&gt;.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { buildId, OsmPrimitiveType} from 'josm/ds' * * // build a node id * const id1 = buildId(1234, 'node') * * // build a way id * const id2 = buildId(3333, OsmPrimitiveType.WAY) * * // build a relation id * const id3 = buildId({id: 5423, type: 'relation'}) * * * @param args see description */ export function buildId (id, type) { function buildId2 (id, type) { id = normalizeId(id) type = normalizeType(type) if (id === 0) { util.assert(false, 'expected id != 0, got 0') } return new SimplePrimitiveId(id, type) } function buildId1 (id) { if (id instanceof PrimitiveId) { return id } if (util.hasProp(id, 'id') &amp;&amp; util.hasProp(id, 'type')) { return buildId2(id.id, id.type) } util.assert(false, 'expected PrimitiveId or {id: ..., type: ...}, got \"{0}\"', id) } util.assert(arguments.length &gt; 0, 'expected at least 1 argument, got 0') switch (arguments.length) { case 1: return buildId1(...arguments) case 2: return buildId2(...arguments) default: util.assert(false, 'expected 1 or 2 arguments, got {0}', arguments.length) } } function each (collection, delegate) { if (util.isArray(collection) || util.isArguments(collection)) { for (let i = 0; i &lt; collection.length; i++) { delegate(collection[i]) } } else if (collection instanceof Collection) { for (let it = collection.iterator(); it.hasNext();) { delegate(it.next()) } } else { util.assert(false, 'Expected list or collection, got {0}', collection) } } function collect (collection, predicate) { const ret = [] each(collection, (obj) =&gt; { if (predicate(obj)) ret.push(obj) }) return ret } function isCollection (collection) { return util.isArray(collection) || util.isArguments(collection) || collection instanceof Collection } function normalizeIds () { function walk (set, ids) { if (util.isNothing(ids)) return if (ids instanceof PrimitiveId) { set.add(ids) } else if (isCollection(ids)) { each(ids, (that) =&gt; walk(set, that)) } else { util.assert(false, 'PrimitiveId or collection required, got {0}', ids) } } const set = new HashSet() for (let i = 0; i &lt; arguments.length; i++) { walk(set, arguments[i]) } return set } /** * &lt;code&gt;DataSetUtil&lt;/code&gt; provides methods to build OSM primitive IDs and to * manipulate data in a {@class org.openstreetmap.josm.data.osm.DataSet}. * */ export class DataSetUtil { /** * Creates an instance of &lt;code&gt;DataSetUtil&lt;/code&gt; for a given {@class org.openstreetmap.josm.data.osm.DataSet} * * @example * import { DataSetUtil, DataSet } from 'josm/ds' * const dsutil = new DataSetUtil(new DataSet()) * * @summary Build an utility object wrapping the dataset &lt;code&gt;ds&lt;/code&gt; * @param {org.openstreetmap.josm.data.osm.DataSet} [ds] the dataset. Creates a new dataset if missing */ constructor (ds) { ds = ds || new DataSet() this.ds = ds } /** * Replies an OSM object from the dataset, or undefined, if no such object * exists. * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;get(id, type)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies an object given by its unique numeric id and a type. * The type is either a string \"node\", \"way\", or \"relation\", or one of * the symbols * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, or * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;get(id)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies an object given an ID. &lt;code&gt;id&lt;/code&gt; is either an instance * of * {@class org.openstreetmap.josm.data.osm.PrimitiveId} or an object with * the properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, i.e. * &lt;code&gt;{id: 1234, type: \"node\"}&lt;/code&gt;.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { buildId , DataSetUtil, DataSet, OsmPrimitiveType} from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * // get a node * const n1 = dsutil.get(1234, 'node') * * // get a way * const w1 = dsutil.get(3333, OsmPrimitiveType.WAY) * * // get a relation * const r1 = dsutil.get({id: 5423, type: 'relation'}) * * // pass in a SimplePrimitiveId * const id = buildId(-5, OsmPrimitiveType.NODE) * const n2 = dsutil.get(id) * * // pass in a primitive to get it * const w2 = dsutil.wayBuilder().create(987) * const w3 = dsutil.get(w2) * * @param args see description */ get () { const id = buildId(...arguments) return this.ds.getPrimitiveById(id) } /** * Replies the node with id &lt;code&gt;id&lt;/code&gt;, or null. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * // get a node * const n = dsutil.node(1234) * * @param {number} id the unique numeric id. Must not be 0. * @returns {org.openstreetmap.josm.data.osm.Node} the node */ node (id) { util.assert(util.isSomething(id), 'expected defined id, got \"{0}\"', id) return this.get(id, 'node') } /** * Replies the way with id &lt;code&gt;id&lt;/code&gt;, or null * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * // get a way * const w = dsutil.way(1234) * @param {number} id the unique numeric id. Must not be 0. * @returns {org.openstreetmap.josm.data.osm.Way} the way */ way (id) { util.assert(util.isSomething(id), 'expected defined id, got \"{0}\"', id) return this.get(id, 'way') } /** * Replies the relation with id &lt;code&gt;id&lt;/code&gt;. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * // get a relation * const r = dsutil.relation(1234) * * @param {number} id the unique numeric id. Must not be 0. * @returns {org.openstreetmap.josm.data.osm.Relation} the relation */ relation (id) { util.assert(util.isSomething(id), 'expected defined id, got \"{0}\"', id) return this.get(id, 'relation') } /** * Run a sequence of operations against the dataset in \"batch mode\". * * Listeners to data set events are only notified at the end of the batch. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * const dsutil = new DataSetUtil(new DataSet()) * // creates and adds two nodes and a way in batch operation * // to the dataset * dsutil.batch(() =&gt; { * const n1 = dsutil.nodeBuilder().create() * const n2 = dsutil.nodeBuilder().create() * dsutil.wayBuilder().withNodes(n1,n2).create() * }) * * @param {function} delegate the function implementing the batch process. * Ignored if null or undefined. */ batch (delegate) { if (!(util.isSomething(delegate))) { return } util.assert(util.isFunction(delegate), 'expected a function, got \"{0}\"', delegate) this.ds.beginUpdate() try { delegate() } finally { this.ds.endUpdate() } } /** * Removes objects from the dataset * * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;remove(id, type)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Removes a single object given by its unique numeric ID (nid) and a * type. The type is either a string \"node\", \"way\", or \"relation\", or one * of the symbols * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.NODE, * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.WAY, or * {@class org.openstreetmap.josm.data.osm.OsmPrimitiveType}.RELATION.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;remove(id, id, ...)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Removes a collection of objects given by the ids. &lt;code&gt;id&lt;/code&gt; is * either an instance of * {@class org.openstreetmap.josm.data.osm.PrimitiveId} or an object with * the properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, i.e. * &lt;code&gt;{id: 1234, type: \"node\"}&lt;/code&gt;. * null and undefined are ignored.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;remove(array|collection)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Removes a collection of objects given by the an array or a * java.util.Collection of ids. * The collection elemeents are either instances of * {@class org.openstreetmap.josm.data.osm.PrimitiveId} or an object with * the properties &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, i.e. * &lt;code&gt;{id: 1234, type: \"node\"}&lt;/code&gt;. * null or undefined elements are ignored. * &lt;/dd&gt; * &lt;/dl&gt; * * @example * import { DataSet, DataSetUtil, OsmPrimitiveType, buildId} from 'josm/ds' * const HashSet = Java.type('java.util.HashSet') * const dsutil = new DataSetUtil(new DataSet()) * * // remove a node with a global id * dsutil.remove(1234, 'node') * * // remove a node and a way * const id1 = buildId(1234, 'node') * const id2 = buildId(3333, OsmPrimitiveType.WAY) * dsutil.remove(id1, id2) * * // remove a relation and a node * dsutil.remove({id: 1234, type: 'relation'}, id1) * * // remove an array of nodes * dsutil.remove([id1,id2]) * * // remove a set of primitives * const ids = new HashSet() * ids.add(id1) * ids.add(id1) * dsutil.remove(ids) * * @param args see description */ remove () { // we have exactly two arguments, id and type. If we succeed // to convert them to a primitive id, then we are done if (arguments.length === 2) { let id try { id = buildId(normalizeId(arguments[0]), normalizeType(arguments[1])) } catch (e) { id = null } if (id) { this.ds.removePrimitive(id) return } } // we have a list of ids or collections of ids to remove. // First build a flat list of the ids, then remove them // in a batch operation from the dataset const ids = normalizeIds(...arguments) const ds = this.ds this.batch(() =&gt; { each(ids, (id) =&gt; { ds.removePrimitive(id) }) }) } /** * Replies a node builder to create {@class org.openstreetmap.josm.data.osm.Node}s in this dataset. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * const dsutil = new DataSetUtil(new DataSet()) * const n = dsutil.nodeBuilder * .withId(1234,4567) * .withTags({amenity: 'restaurant'}) * .create() * dsutil.has(n) * * @property {module:josm/builder~NodeBuilder} nodeBuilder * @readOnly */ get nodeBuilder () { return NodeBuilder.forDataSet(this.ds) } /** * Replies a way builder to create ways in this dataset. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * const nb = dsutil.nodeBuilder() * const w = dsutil.wayBuilder() * .withNodes(nb.create(), nb.create()) * .create(1234, {tags: {highway: \"residential\"}}) * dsutil.has(w) * * @property {module:josm/builder~WayBuilder} wayBuilder * @readOnly */ get wayBuilder () { return WayBuilder.forDataSet(this.ds) } /** * Replies a relation builder to create relations in this dataset. * * @example * import { DataSet, DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil(new DataSet()) * const r = dsutil.relationBuilder() * .withId(8765,1234) * .create({tags: {type: 'network'}}) * ds.has(r) // --&gt; true * * @property {module:josm/builder~RelationBuilder} relationBuilder * @readOnly */ get relationBuilder () { return RelationBuilder.forDataSet(this.ds) } /** * Loads a dataset from a file. * &lt;p&gt; * Derives the format of the file from the file suffix, unless the named * option &lt;code&gt;options.format&lt;/code&gt; is set. * &lt;p&gt; * &lt;code&gt;options&lt;/code&gt; can contain the following named options: * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;format&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;one of the strings &lt;code&gt;osm&lt;/code&gt; (Open Street Map XML data), * &lt;code&gt;osc&lt;/code&gt; (Open Street Map change format), or * &lt;code&gt;osm.gz&lt;/code&gt; (Open Street Map XML data, * compressed with gzip). The format is normalized: white space is removed and it is * converted to lower case.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { DataSetUtil } from 'josm/ds' * * // loads an OSM file * DataSetUtil.load('/path/to/my/file.osm') * * // loads an OSM file, explicity passing in the format * DataSetUtil.load('/path/to/my/file.any-suffix', { format 'osm' }) * * @param {string|java.io.File} source the data source * @param {object} [options] optional named parameters * * @return {module:josm/ds~DataSetUtil} the data set util with the loaded data set */ static load (source, options) { function normalizeFile (source) { if (source instanceof File) { return source } else if (util.isString(source)) { return new File(source) } else { util.assert(false, 'source: illegal value, expected string or File, got {0}', source) } } function normalizeFormat (source, options) { const FORMATS = { osm: true, osc: true, 'osm.gz': true } if (util.isSomething(options.format)) { // convert to string const format = util.trim(options.format + '').toLowerCase() if (FORMATS[format]) { return format } util.assert(false, `options.format: unknown format '${format}'`) } else { if (source.getPath().endsWith('.osm.gz')) { return 'osm.gz' } if (new OsmImporter().acceptFile(source)) { return 'osm' } if (new OsmChangeImporter().acceptFile(source)) { return 'osc' } util.assert(false, `Failed to derive format from file name. file is '${source}'`) } } util.assert(util.isSomething(source), 'source: must not be null or undefined') options = options || {} source = normalizeFile(source) const format = normalizeFormat(source, options) log(`format: ${format}`) let is try { switch (format) { // load an OSM file case 'osm': { is = new FileInputStream(source) const other = OsmReader.parseDataSet(is, null /* null progress monitor */) return new DataSetUtil(other) } // load an OSC file case 'osc': { is = new FileInputStream(source) const other = OsmChangeReader.parseDataSet(is, null /* null progress monitor */) return new DataSetUtil(other) } // load a compressed OSM file case 'osm.gz': { is = new GZIPInputStream(new FileInputStream(source)) const other = OsmReader.parseDataSet(is, null /* null progress monitor */) return new DataSetUtil(other) } default: util.assert(false, `unknown format '${format}'. Failed to load from ${source}`) } } finally { is &amp;&amp; Utils.close(is) } } /** * Saves the dataset to a file (in OSM XML format). * &lt;p&gt; * * &lt;code&gt;options&lt;/code&gt; can contain the following named options: * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;version&lt;/code&gt;: string&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;the value of the attribute &lt;code&gt;version&lt;/code&gt; in the OSM file * header. Default: \"0.6\"&lt;/dd&gt; * * &lt;dt&gt;&lt;codeclass=\"signature\"&gt;changeset&lt;/code&gt;: Changeset&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;the changeset whose id is included in the attribute * &lt;code&gt;changeset&lt;/code&gt; on every OSM object. If undefined, includes the * individual &lt;code&gt;changeset&lt;/code&gt; attribute of the OSM object. * Default: undefined&lt;/dd&gt; * &lt;dt&gt;&lt;codeclass=\"signature\"&gt;osmConform&lt;/code&gt;: bool&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;if true, prevents modification attributes to be written * Default: true&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { DataSetUtil } from 'josm/ds' * * const dsutil = new DataSetUtil() * // create a node in the dataset * dsutil.nodeBuilder() * .withId(1, 1) * .withPosition({ lat: 1.0, lon: 1.0 }) * .create() * * // save the dataset * dsutil.save('/tmp/my-dataset.osm') * * @param {string|java.io.File} target the target file * @param {object} [options] optional named parameters * @instance */ save (target, options) { function normalizeTarget (target) { util.assert(util.isSomething(target), 'target: must not be null or undefined') if (util.isString(target)) { return new File(target) } else if (target instanceof File) { return target } else { util.assert(false, 'target: unexpected type of value, got {0}', target) } } function normalizeOptions (options) { options = options || {} util.assert( !util.isDef(options.version) || util.isString(options.version), 'options.version: expected a string, got {0}', options.version) options.version = options.version ? util.trim(options.version) : null /* default version */ /// true, if not explicity set to false options.osmConform = options.osmConform !== false const changeset = options.changeset util.assert( !util.isDef(changeset) || changeset instanceof Changeset, 'options.changeset: expected a changeset, got {0}', changeset) return options } target = normalizeTarget(target) options = normalizeOptions(options) let pw try { pw = new PrintWriter(new FileWriter(target)) const writer = OsmWriterFactory.createOsmWriter( pw, options.osmConform, options.version) if (options.changeset) { writer.setChangeset(options.changeset) } try { this.ds.getReadLock().lock() writer.header() writer.writeContent(this.ds) writer.footer() } finally { this.ds.getReadLock().unlock() } } finally { pw &amp;&amp; pw.close() } } /** * Queries the dataset * &lt;p&gt; * &lt;strong&gt;Signatures&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;query(josmSearchExpression,?options)&lt;/code&gt; * &lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Queries the dataset using the JOSM search expression * &lt;code&gt;josmSearchExpression&lt;/code&gt;. * &lt;code&gt;josmSearchExpression&lt;/code&gt; is a string as you would enter it in * the JOSM search dialog. &lt;code&gt;options&lt;/code&gt; is an (optional) object * with named parameters, see below.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;query(predicate,?options)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Queries the dataset using a javascript predicate function * &lt;code&gt;predicate&lt;/code&gt;. &lt;code&gt;predicate&lt;/code&gt; is a javascript * function which accepts a object as parameter and replies * true, when it matches for the object ans false otherwise. * &lt;code&gt;options&lt;/code&gt; is an (optional) object with named parameters, * see below.&lt;/dd&gt; * &lt;/dl&gt; * * The parameter &lt;code&gt;options&lt;/code&gt; consist of the following (optional) * named parameters: * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;allElements&lt;/code&gt; : boolean * (Deprecated parameter names: * &lt;code class=\"signature\"&gt;all&lt;/code&gt;)&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;If true, searches &lt;em&gt;all&lt;/em&gt; objects in the dataset. If false, * ignores incomplete or deleted * objects. Default: false.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;caseSensitive&lt;/code&gt; : boolean&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;strong&gt;Only applicable for searches with a JOSM search * expression&lt;/strong&gt;. If true, searches case sensitive. If false, * searches case insensitive. Default: false.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;regexSearch&lt;/code&gt; : boolean (Deprecated * parameter names: * &lt;code class=\"signature\"&gt;withRegexp&lt;/code&gt;, * &lt;code class=\"signature\"&gt;regexpSearch&lt;/code&gt;)&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;strong&gt;Only applicable for searches with a JOSM search * expression&lt;/strong&gt;. If true, the search expression contains regular * expressions. If false, it includes only plain strings for searching. * Default: false.&lt;/dd&gt; * * &lt;dt&gt;&lt;code class=\"signature\"&gt;mapCSSSearch&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;&lt;strong&gt;Only applies for searches with a JOSM search * expression&lt;/strong&gt;. * Default: false.&lt;/dd&gt; * &lt;/dl&gt; * * @example * import { DataSetUtil } from 'josm/ds' * const dsutil = new DataSetUtil() * // add or load primitives to query * // ... * * // query restaurants * const result1 = dsutil.query('amenity=restaurant') * * // query all nodes with a type query * const result2 = dsutil.query('type:node') * * // query using a custom predicate - all primitives * // with exactly two tags * const result3 = dsutil.query((primitive) =&gt; { * primitive.getKeys().size() === 2 * }) * * @param {string|function} expression the match expression * @param {object} [options] additional named parameters * @instance */ query (expression, options) { const SearchSetting = Java.type('org.openstreetmap.josm.data.osm.search.SearchSetting') const SearchCompiler = Java.type('org.openstreetmap.josm.data.osm.search.SearchCompiler') options = options || {} switch (arguments.length) { case 0: return [] case 1: case 2: if (util.isString(expression)) { const ss = new SearchSetting() ss.caseSensitive = Boolean(options.caseSensitive) ss.regexSearch = Boolean(options.regexSearch) || Boolean(options.regexpSearch) || Boolean(options.withRegexp) ss.allElements = Boolean(options.all) || Boolean(options.allElements) ss.mapCSSSearch = Boolean(options.mapCSSSearch) ss.text = expression const matcher = SearchCompiler.compile(ss) let predicate if (ss.allElements) { predicate = (matcher) =&gt; (obj) =&gt; { return matcher.match(obj) } } else { predicate = (matcher) =&gt; (obj) =&gt; { return obj.isUsable() &amp;&amp; matcher.match(obj) } } return collect(this.ds.allPrimitives(), predicate(matcher)) } else if (util.isFunction(expression)) { const all = Boolean(options.all) || Boolean(options.allElements) let predicate = expression if (!all) { predicate = (obj) =&gt; { return obj.isUsable() &amp;&amp; expression(obj) } } return collect(this.ds.allPrimitives(), predicate) } else { util.assert(false, 'expression: Unexpected type of argument, got {0}', arguments[0]) } break default: util.assert(false, 'Expected a predicate, got {0} arguments', arguments.length) } } } Ã— Search results Close "},"josm_layers.mjs.html":{"id":"josm_layers.mjs.html","title":"Source: josm/layers.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/layers.mjs /** * Provides access to the JOSM layers. * * @module josm/layers */ /* global Java */ // -- imports const MainApplication = Java.type('org.openstreetmap.josm.gui.MainApplication') const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const Layer = Java.type('org.openstreetmap.josm.gui.layer.Layer') import * as util from './util' /** * Provides access to JOSM layers. */ export class Layers { /** * Replies the number of currently open layers. * * @readOnly * @type {number} */ get length() { return MainApplication.getLayerManager().getLayers().size() } /** * Set or get the active layer. * * &lt;dl&gt; * &lt;dt&gt;get&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Replies the active layer or undefined.&lt;/dd&gt; * * &lt;dt&gt;set&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Assign either an existing {@class org.openstreetmap.josm.gui.layer.Layer}, * the name of a layer as string, or a layer index as number.&lt;/dd&gt; * &lt;/dl&gt; * * @type {org.openstreetmap.josm.gui.layer.Layer} */ get activeLayer() { return MainApplication.getLayerManager().getActiveLayer() } set activeLayer(value) { util.assert(util.isSomething(value),'Value must not be null or undefined)') let layer = null if (value instanceof Layer) { layer = value } else if (util.isNumber(value) || util.isString(value)) { layer = layers.get(value) } else { util.assert(false, 'Unexpected type of value, got {0}', value) } util.assert(util.isSomething(layer), 'Layer \\'\\'{0}\\'\\' doesn\\'\\'t exist. It can\\'\\'t be set as active layer.', value) MainApplication.getLayerManager().setActiveLayer(layer) } #getLayerByName (key) { key = util.trim(key).toLowerCase() if (this.length === 0) return undefined const layers = MainApplication.getLayerManager().getLayers() for (let it = layers.iterator(); it.hasNext();) { const l = it.next() if (l.getName().trim().toLowerCase() === key) return l } return undefined } #getLayerByIndex (idx) { if (idx &lt; 0 || idx &gt;= this.length) return undefined const layers = MainApplication.getLayerManager().getLayers() return layers.get(idx) } /** * Replies one of the layers given a key. * * &lt;ul&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a number, replies the layer with index key, or * undefined, if no layer for this index exists.&lt;/li&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a string, replies the first layer whose name * is identical to key (case insensitive, without leading/trailing * whitespace), or undefined, if no layer with such a name exists.&lt;/li&gt; * &lt;/ul&gt; * * @example * import layers from 'josm/layers' * * // get the first layer * const layer1 = layers.get(0) * * // get the first layer with name \"data layer\" * const layer2 = layers.get('data layer') * * @param {number|string} key the key to retrieve the layer * @returns {org.openstreetmap.josm.gui.layer.Layer} */ get(key) { if (util.isNothing(key)) return undefined if (util.isString(key)) return this.#getLayerByName(key) if (util.isNumber(key)) return this.#getLayerByIndex(key) return undefined } /** * Checks whether &lt;code&gt;layer&lt;/code&gt; is a currently registered layer. * * @example * import layers from 'josm/layers' * * // is there a layer with name \"my layer\"? * let b = layers.has('my layer') * * // is there a layer at index position 2 * b = layers.has(2) * * // is there a specific layer? * let l = layers.get(0) * b = layers.has(l) * * @param {org.openstreetmap.josm.gui.layer.Layer|string|number} layer a layer, * a layer name, or a layer index * @returns {boolean } true, if the layer or at least one layer with the given name exists. * False, otherwise. */ has(layer) { if (util.isNothing(layer)) return false const layerManager = MainApplication.getLayerManager() if (layer instanceof Layer) { return layerManager.getLayers().contains(layer) } else if (util.isString(layer)) { return util.isSomething(layers.get(layer)) } else if (util.isNumber(layer)) { return layer &gt;= 0 &amp;&amp; layer &lt; layers.length } else { return false } } /** * Adds a layer. * &lt;p&gt; * Either pass in a layer object or a data set. In the later case, an * {@class org.openstreetmap.josm.gui.layer.OsmDataLayer} is * automatically created. * * @example * import layers from 'josm/layers' * const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * const dataLayer = new OsmDataLayer(new DataSet(), null, null); * // add a layer ... * layers.add(dataLayer) * * // or add a dataset, which will create a data layer * const ds = new DataSet() * layer.add(ds) * * @param {org.openstreetmap.josm.gui.layer.Layer * |org.openstreetmap.josm.data.osm.DataSet} obj a layer to add, * or a dataset. Ignored if null or undefined. * @returns {org.openstreetmap.josm.gui.layer.Layer} the added layer */ add(obj) { if (util.isNothing(obj)) return const layerManager = MainApplication.getLayerManager() if (obj instanceof Layer) { layerManager.addLayer(obj) } else if (obj instanceof DataSet) { layerManager.addLayer(new OsmDataLayer(obj, null, null)) } else { util.assert(false, 'Expected an instance of Layer or DataSet, got {0}', obj) } } #removeLayerByIndex (idx) { const layer = this.get(idx) if (util.isNothing(layer)) return MainApplication.getLayerManager().removeLayer(layer) } #removeLayerByName (name) { const layer = this.get(name) if (util.isNothing(layer)) return MainApplication.getLayerManager().removeLayer(layer) } /** * Removes a layer with the given key. * * &lt;ul&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Number&lt;/code&gt;, removes the layer with * the index key. If the index doesn't isn't a valid layer index, nothing * is removed.&lt;/li&gt; * &lt;li&gt;If &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, removes the layer with * the name &lt;code&gt;key&lt;/code&gt;. Leading and trailing white space is removed, * matching is a case-insensitive sub-string match.&lt;/li&gt; * &lt;/ul&gt; * @example * import josm from 'josm' * * // remove the first layer * josm.layers.remove(0) * * // remove the first layer matching with the supplied name * josm.layers.remove('myLayerName') * * @param {number|string} key indicates the layer to remove */ remove(key) { if (util.isNothing(key)) return if (util.isNumber(key)) { this.#removeLayerByIndex(key) } else if (util.isString(key)) { this.#removeLayerByName(key) } else { util.assert(false, 'Expected a number or a string, got {0}', key) } } /** * Creates and adds a new data layer. The new layer becomes the new edit * layer. * &lt;p&gt; * * &lt;string&gt;Signatures&lt;/string&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer()&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;create data layer with a new dataset and default name&lt;/dd&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer(ds)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;create data layer with dataset ds and default name&lt;/dd&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer(name)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;create data layer with a new dataset and name &lt;code&gt;name&lt;/code&gt;&lt;/dd&gt; * &lt;dt&gt;&lt;code class=\"signature\"&gt;addDataLayer({name: ..., ds: ...})&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;create data layer with a new dataset and name &lt;code&gt;name&lt;/code&gt;&lt;/dd&gt; * &lt;/dl&gt; * @example * import josm from 'josm' * const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') * * // creates a new data layer * const l1 = josm.layers.addDataLayer() * * // creates a new data layer with name 'test' * const l2 = josm.layers.addDataLayer('test') * * // creates a new data layer for the dataset ds * const ds = new DataSet() * const l3 = josm.layers.addDataLayer(ds) * * @returns {org.openstreetmap.josm.gui.layer.OsmDataLayer} the added layer * @param {string | org.openstreetmap.josm.data.osm.DataSet | object } args see description */ addDataLayer() { let name, ds switch (arguments.length) { case 0: break case 1: if (util.isString(arguments[0])) { name = util.trim(arguments[0]) } else if (arguments[0] instanceof DataSet) { ds = arguments[0] } else if (typeof arguments[0] === 'object') { if (util.isString(arguments[0].name)) { name = util.trim(arguments[0].name) } if (arguments[0].ds instanceof DataSet) { ds = arguments[0].ds } } else { util.assert(false, 'unsupported type of argument, got {0}', arguments[0]) } break default: util.assert(false, 'Unsupported number of arguments, got {0}', arguments.length) } ds = ds || new DataSet() name = name || OsmDataLayer.createNewName() const layer = new OsmDataLayer(ds, name, null /* no file */) layers.add(layer) return layer } } /** * the singleton instance of the layers class */ const layers = new Layers() export default layers Ã— Search results Close "},"josm_scriptingconsole.mjs.html":{"id":"josm_scriptingconsole.mjs.html","title":"Source: josm/scriptingconsole.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/scriptingconsole.mjs /** * Provides a set of functions to write to the built-in scripting * console. * * @module josm/scriptingconsole */ /* global Java */ // -- imports const ScriptingConsole = Plugin.type('org.openstreetmap.josm.plugins.scripting.ui.console.ScriptingConsole') const MessageFormat = Java.type('java.text.MessageFormat') function consoleWriter () { return ScriptingConsole.static.getInstance().getScriptLog().getLogWriter() } /** * Prints a string to the console * * @example * import {print} from 'josm/scriptingconsole' * print('Hello world!') * * // or use formatting * print('Hello world! My name is {0}', 'foo') * * @param {string} message the message * @param {...object} [values] optional values */ export function print() { const args = Array.prototype.slice.call(arguments, 0) switch (args.length) { case 0: return case 1: consoleWriter().print(args[0] + '') return default: { args[0] = args[0] + '' // make sure first argument is a string const msg = MessageFormat.format(args[0], args.slice(1)) consoleWriter().print(msg) } } } /** * Prints a string to the console, including newline * * @example * import {println} from 'josm/scriptingconsole' * println('Hello world!') * * // or use formatting * println('Hello world! My name is {0}', 'foo') * * @param {string} message the message * @param {...object} [values] optional values */ export function println() { var args = Array.prototype.slice.call(arguments, 0) switch (args.length) { case 0: return case 1: consoleWriter().println(args[0] + '') return default: { args[0] = args[0] + '' // make sure first argument is a string const msg = MessageFormat.format(args[0], args.slice(1)) consoleWriter().println(msg) } } } /** * Clears the scripting console. * * @example * import * as console from 'josm/scriptingconsole' * console.clear() * */ export function clear() { const action = ScriptingConsole.getInstance().getScriptLog().getClearAction() action.actionPerformed(null) } /** * Shows the scripting console * * @example * import * as console from 'josm/scriptingconsole' * console.show() */ export function show() { ScriptingConsole.showScriptingConsole() } /** * Hides the scripting console * * @example * import * as console from 'josm/scriptingconsole' * console.hide() */ export function hide() { ScriptingConsole.hideScriptingConsole() } /** * Toggles the visibility of the scripting console * * @example * import * as console from 'josm/scriptingconsole' * console.toggle() */ export function toggle() { ScriptingConsole.toggleScriptingConsole() } Ã— Search results Close "},"josm_ui_menu.mjs.html":{"id":"josm_ui_menu.mjs.html","title":"Source: josm/ui/menu.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/ui/menu.mjs /** * Provides a collection of namespaces, classes and functions to work with * JOSMs menu system. * * @module josm/ui/menu * @example * import {JSAction} from 'josm/ui/menu' */ /* global Java */ /* global Plugin */ const MainApplication = Java.type('org.openstreetmap.josm.gui.MainApplication') import * as util from 'josm/util' /** * Represents JOSMs global menu bar. * * @class * @name MenuBar */ export const MenuBar = {} /** * Replies the number of menus in the JOSM menu bar. * * @example * import josm from 'josm' * // display the number of menus * josm.alert(josm.menu.length) * * @property {number} length the number of menues * @name length * @summary the number of menus in the JOSM menu bar * @memberof module:josm/ui/menu~MenuBar * @static */ Object.defineProperty(MenuBar, 'length', { enumerable: true, get: function () { if (!MainApplication.getMenu()) return 0 return MainApplication.getMenu().getMenuCount() } }) /** * Replies a menu in the JOSM menu bar. * * &lt;code&gt;key&lt;/code&gt; is either a numberic index or one of the following * symbolic names as string: * &lt;ul&gt; * &lt;li&gt;&lt;code&gt;file&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;edit&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;view&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;tools&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;presets&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;imagery&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;window&lt;/code&gt;&lt;/li&gt; * &lt;li&gt;&lt;code&gt;help&lt;/code&gt;&lt;/li&gt; * &lt;/ul&gt; * * @example * import josm from 'josm' * // get the edit menu with a numeric index * const editMenu = josm.menu.get(1) * * // get the file menu with a symbolic name * const fileMenu = josm.menu.get('file') * * @return {javax.swing.JMenu} the menu * @summary Replies a menu in the JOSM menu bar. * @param {number|string} key the key denoting the menu * @memberof module:josm/ui/menu~MenuBar * @name get * @function * @static */ MenuBar.get = function (key) { util.assert(util.isSomething(key), 'key: must not be null or undefined') const mainMenu = MainApplication.getMenu() if (util.isNumber(key)) { util.assert(key &gt;= 0 &amp;&amp; key &lt; MenuBar.length, 'key: index out of range, got {0}', key) return mainMenu.getMenu(key) } else if (util.isString(key)) { key = util.trim(key).toLowerCase() switch (key) { case 'file': return mainMenu.fileMenu case 'edit': return mainMenu.editMenu case 'view': return mainMenu.viewMenu case 'tools': return mainMenu.toolsMenu case 'presets': return mainMenu.presetsMenu case 'imagery': return mainMenu.imageryMenu case 'window': return mainMenu.windowMenu case 'help': return mainMenu.helpMenu default: util.assert(false, 'Unsupported key to access a menu, got {0}', key) } } else { util.assert(false, 'Unexpected value, got {0}', key) } } /** * Replies an array with the symbolic menu names. * * @memberof module:josm/ui/menu~MenuBar * @name menuNames * @property {array} menuNames the names of the menues in the menu bar * @readOnly * @summary Replies an array with the symbolic menu names. * */ Object.defineProperty(MenuBar, 'menuNames', { enumerable: true, get: function () { return ['file', 'edit', 'view', 'tools', 'presets', 'imagery', 'window', 'help'] } }) /** * Callback type for JSAction * * @callback JSActionCallback */ /** * The named options for building a JSAction. * * @typedef JSActionOptions * @property {string} [name] The optional name of the action. Default: an auto generated name * @property {string} [tooltip] The optional tooltip of the action. Default: empty string * @property {string} [iconName] The optional name of an icon. Default: null * @property {string} [toolbarId] The optional name of the tooblar to which this action is added. * Note that it isn't added automatically, when this action is created. Default: null. * @property {module:josm/ui/menu~JSActionCallback} [onExecute=null] The optional function which is called when the action is executed. * Default: null. * @property {module:josm/ui/menu~JSActionCallback} [onInitEnabled=null] The optional function which is called when the &lt;em&gt;enabled&lt;/em&gt; * state of the function is evaluated the first time. Default: null. * @property {module:josm/ui/menu~JSActionCallback} [onUpdateEnabled=null] The (optional) function which is called when the &lt;em&gt;enabled&lt;/em&gt; * state of the function is reevaluated, in particular, when layer change * events or selection change events occur. Default: null. */ /** * JSAction is an action for which a menu item or a toolbar item can be * added to JOSMs menu or JOSMs toolbar respectively. * * This is just a shortcut for the Java class * {@class org.openstreetmap.josm.plugins.scripting.js.JSAction}. * * The constructor accepts an object with {@link module:josm/ui/menu~JSActionOptions named parameters}. * * @example * import {JSAction} from 'josm/ui/menu' * import * as util from 'josm/util' * import josm from 'josm' * const JMenuItem = Java.type('javax.swing.JMenuItem') * * // create the menu action * const helloWorldAction = new JSAction({ * name: \"My Action\", * iconName: 'myicon', * toolbarId: 'myToolbarId', * tooltip: \"This is my action\", * * onInitEnabled: function() { * util.println('onInitEnabled: entering ...') * }, * * onUpdateEnabled: function() { * util.println('onUpdateEnabled: entering ...') * }, * * onExecute: function() { * util.println('Hello World!') * } * }) * * // register a new menu item in the file menu * const fileMenu = josm.menu.get('file') * fileMenu.addSeparator() * fileMenu.add(new JMenuItem(helloWorldAction)) * * * @property {org.openstreetmap.josm.plugins.scripting.graalvm.JSAction} JSAction */ export const JSAction = Plugin.type('org.openstreetmap.josm.plugins.scripting.graalvm.JSAction') Ã— Search results Close "},"josm_unittest.mjs.html":{"id":"josm_unittest.mjs.html","title":"Source: josm/unittest.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/unittest.mjs /** * @module josm/unittest */ /* global Java */ import * as util from 'josm/util' const System = Java.type('java.lang.System') const out = System.out export function TestCase(name, test) { this._name = name this._test = test } export function test() { switch (arguments.length) { case 1: return new TestCase('No Name', arguments[0]) case 2: return new TestCase(arguments[0], arguments[1]) default: util.assert(false, 'Unsupported arguments') } } TestCase.prototype.run = function () { try { this._test() out.println('PASS - ' + this._name) return true } catch (e) { out.println(`FAIL - ${this._name}`) const desc = e.message || e.description || e out.println(` description: ${desc}`) let context if (e.lineNumber || e.fileName) { context = ` filename: ${e.fileName}, line: ${e.lineNumber}` } if (context) { out.println(` context: ${context}`) } return false } } export function Suite(name) { this._name = name this._tests = [] } export function suite() { if (arguments.length === 0) return new Suite() let idx = 0 const name = arguments[0] let suite if (util.isString(name)) { suite = new Suite(name) idx = 1 } else { suite = new Suite() } for (let i = idx; i &lt; arguments.length; i++) { const test = arguments[i] if (test instanceof TestCase) { suite.add(test) } else if (util.isFunction(test)) { suite.add(test(test)) } else { util.assert(false, 'Unsupported arguments') } } return suite } Suite.prototype.add = function (test) { this._tests.push(test) } Suite.prototype.run = function () { out.println('----------------------------------------------------------------------') if (this._name) { out.println('suite: ' + this._name) out.println('----------------------------------------------------------------------') } let numtests = 0 let numfail = 0 let numok = 0 for (let i = 0; i &lt; this._tests.length; i++) { const ret = this._tests[i].run() numtests++ if (ret) { numok++ } else { numfail++ } } out.println('----------------------------------------------------------------------') out.println(' # tests: ' + numtests + ' # PASS : ' + numok + ' # FAIL : ' + numfail) out.println('----------------------------------------------------------------------') return numfail } export function expectError() { let name = 'no name' let f switch (arguments.length) { case 0: return case 1: f = arguments[0]; break case 2: name = arguments[0] f = arguments[1] break default: util.assert(false, 'Unexpected number of arguments') } try { f() util.assert(false, \"''{0}'': should have failed. Didn''t catch an error.\", name) } catch (e) { // OK } } export function expectAssertionError() { let name = 'no name' let f switch (arguments.length) { case 0: return case 1: f = arguments[0]; break case 2: name = arguments[0] f = arguments[1] break default: util.assert(false, 'Unexpected number of arguments') } try { f() util.assert(false, \"''{0}'': should have failed. Didn''t catch an error.\", name) } catch (e) { if (e.name !== 'AssertionError') { util.assert(false, \"''{0}'': expected an AssertionError, caught {1}.\", name, e.toSource()) } } } Ã— Search results Close "},"josm_util.mjs.html":{"id":"josm_util.mjs.html","title":"Source: josm/util.mjs","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Source: josm/util.mjs /** * Provides a set of static utility functions. * * @module josm/util */ /* global Java */ // -- imports const MessageFormat = Java.type('java.text.MessageFormat') /** * Checks whether a value is null or undefined. * * @param {object} value the value to check * @return {boolean} false, if &lt;code&gt;value&lt;/code&gt; is null or undefined; true, otherwise * @summary Checks whether a value is null or undefined. * @function * @name isNothing */ export function isNothing(value) { return value === null || value === undefined } /** * Checks whether a value is neither null nor undefined. * * @param {object} value the value to check * @return {boolean} false, if &lt;code&gt;value&lt;/code&gt; is null or undefined; true, otherwise * @summary Checks whether a value is neither null nor undefined. * @function * @name isSomething */ export function isSomething(val) { return !isNothing(val) } /** * Trims leading and trailing whitespace from &lt;code&gt;s&lt;/code&gt;. * &lt;p&gt; * * Replies s, if s is null or undefined. Any other value is converted to a * string, then leading and trailing white space is removed. * * @param {string} s the string to be trimmed * @return {string} * @summary Trims leading and trailing whitespace from &lt;code&gt;s&lt;/code&gt;. * @function * @name trim */ export function trim(s) { if (isNothing(s)) { return s } return (s + '').replace(/^\\s+/, '').replace(/\\s+$/, '') } /** * Assert a condition and throw an Error if the condition isn't met. * * &lt;p&gt;&lt;strong&gt;Usage:&lt;/strong&gt; * &lt;dl&gt; * &lt;dt&gt;&lt;code&gt;assert()&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Does nothing&lt;/dd&gt; * * &lt;dt&gt;&lt;code&gt;assert(cond)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Checks the condition &lt;code&gt;cond&lt;/code&gt;. If it is false, throws an * Error.&lt;/dd&gt; * * &lt;dt&gt;&lt;code&gt;assert(cond, msg)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Checks the condition &lt;code&gt;cond&lt;/code&gt;. If it is false, throws an * Error, whose &lt;code&gt;description&lt;/code&gt; property * is set to &lt;code&gt;msg&lt;/code&gt;.&lt;/dd&gt; * * &lt;dt&gt;&lt;code&gt;assert(cond, msg, objs...)&lt;/code&gt;&lt;/dt&gt; * &lt;dd class=\"param-desc\"&gt;Checks the condition &lt;code&gt;cond&lt;/code&gt;. If it is false, throws an * Error, whose &lt;code&gt;description&lt;/code&gt; property * is set to the formatted message &lt;code&gt;msg&lt;/code&gt;. Internally uses * &lt;code&gt;java.text.MessageFormat&lt;/code&gt; to format the message.&lt;/dd&gt; * * &lt;/dl&gt; * * @example * import {assert} from 'josm/util' * // throws an Error * assert(false) * * // throws an Error e, with e.description == \"My message\" * assert(false, \"My message\") * * // throws an Error e, with e.description == \"My message: test\" * assert(false, \"My message: {0}\", \"test\") * * @summary Assert a condition and throw an Error if the condition isn't met. * @function * @name assert * @static * @param {boolean} condition * @param {string} [message] the message * @param {...object} [values] an optional list of values */ export function assert() { let message, name switch (arguments.length) { case 0: return case 1: if (arguments[0]) return name = 'AssertionError' message = 'An assertion failed' break case 2: if (arguments[0]) return name = 'AssertionError' message = arguments[1] break default: { if (arguments[0]) return name = 'AssertionError' const args = Array.prototype.slice.call(arguments, 0) message = MessageFormat.format( args[1], args.slice(2) ) break } } const error = new Error(message) error.name = name throw error } /** * Asserts that &lt;code&gt;val&lt;/code&gt; is defined and non-null. * * @example * import {assertSomething} from 'josm/util' * * assertSomething(null) // -&gt; throws an exception * assertSomething(void 0) // -&gt; throws an exception * * assertSomting(\"test\") // -&gt; OK * assertSomething(5) // -&gt; OK * * @param {any} val the value to check * @param {string} [msg] message if the assertion fails * @param {...object} [values] additional values used in &lt;code&gt;msg&lt;/code&gt; * placeholders * @summary Asserts that &lt;code&gt;val&lt;/code&gt; is defined and non-null. * @function * @static * @name assertSomething */ export function assertSomething(val) { let args if (arguments.length &lt;= 1) { args = [isSomething(val), 'Expected a defined non-null value, got {0}', val] } else { args = [isSomething(val)].concat( Array.prototype.slice.call(arguments, 1)) } assert.apply(args) } /** * Asserts that &lt;code&gt;val&lt;/code&gt; is a number. * * @param {Anything} value the value to check * @param {String} [msg] message if the assertion fails * @param {...object} [values] values used in &lt;code&gt;msg&lt;/code&gt; placeholders * @summary Asserts that &lt;code&gt;val&lt;/code&gt; is a number. * @function * @name assertNumber * @static */ export function assertNumber(val) { let args = [] if (arguments.length &lt;= 1) { args = [isSomething(val), 'Expected a number, got {0}', val] } else { args = [isSomething(val)] .concat(Array.prototype.slice.call(arguments, 1)) } assert.apply(args) } /** * Returns true if &lt;code&gt;val&lt;/code&gt; is defined. * * @param {any} value the value to check * @summary Returns true if &lt;code&gt;val&lt;/code&gt; is defined. * @return {boolean} true if &lt;code&gt;val&lt;/code&gt; is defined * @function * @name isDef * @static */ export function isDef(val) { return val !== undefined } /** * Returns true if &lt;code&gt;val&lt;/code&gt; is a number. * * @param {any} value the value to check * @summary Returns true if &lt;code&gt;val&lt;/code&gt; is a number. * @return {boolean} true if &lt;code&gt;val&lt;/code&gt; is a number * @function * @name isNumber * @static */ export function isNumber(val) { return typeof val === 'number' } /** * Returns true if &lt;code&gt;val&lt;/code&gt; is a string. * * @param {any} value the value to check * @return {boolean} true, if val is a string or a String object * @summary Returns true if &lt;code&gt;val&lt;/code&gt; is a string. * @function * @name isString * @static */ export function isString(val) { return isDef(val) &amp;&amp; (typeof val === 'string' || val instanceof String) } /** * Replies true if &lt;code&gt;val&lt;/code&gt; is an array. * * @param {anything} value the value to check * @return {boolean} true, if val is an array * @summary Replies true if &lt;code&gt;val&lt;/code&gt; is an array. * @function * @name isArray * @static */ export function isArray(val) { return Object.prototype.toString.call(val) === '[object Array]' } /** * Replies true if &lt;code&gt;val&lt;/code&gt; is a list of arguments. * * @param {anything} value the value to check * @return {boolean} true, if val is a list of arguments * @summary Replies true if &lt;code&gt;val&lt;/code&gt; is a list of arguments. * @function * @name isArguments * @static */ export function isArguments(val) { return Object.prototype.toString.call(val) === '[object Arguments]' } /** * Replies the number of properties owned by &lt;code&gt;o&lt;/code&gt;. * * @example * import {countProperties} from 'josm/util' * * let o = {p1: \"v1\", p2: \"v2\"} * let c = countProperties(o) // -&gt; 2 * * o = {} * c = countProperties(o) // -&gt; 0 * * o = undefined * c = countProperties(o) // -&gt; undefined * * @param {any} o the object * @summary Replies the number of properties owned by &lt;code&gt;o&lt;/code&gt;. * @return {number} the number of properties owned by &lt;code&gt;o&lt;/code&gt;. * @function * @name countProperties * @static */ export function countProperties(o) { if (isNothing(o)) return undefined if (!(typeof o === 'object')) return undefined let count = 0 for (const p in o) { if (hasProp(o, p)) count++ } return count } /** * Replies true, if &lt;code&gt;o&lt;/code&gt; owns at least one property. * * @example * import {hasProperties} from 'josm/util' * * let o = {p1: \"v1\", p2: \"v2\"} * let c = hasProperties(o) // -&gt; true * * o = {} * c = hasProperties(o) // -&gt; false * * o = undefined * c = hasProperties(o) // -&gt; false * * @param {any} o the object * @summary Replies true, if &lt;code&gt;o&lt;/code&gt; owns at least one property. * @return {boolean} true, if &lt;code&gt;o&lt;/code&gt; owns at least one property. * @function * @name hasProperties * @static */ export function hasProperties(o) { const count = countProperties(o) if (count === undefined) return false return count &gt; 0 } /** * Replies true, if f is a function. * * @param {any} f the object * @summary Replies true, if f is a function. * @return {boolean} true, if f is a function. * @function * @name isFunction * @static */ export function isFunction(f) { return typeof f === 'function' } /** * Mixes the properties of a list of objects into one object. * * @return a new object which includes the combined properties of the * argument objects * @return {object} * @summary Mixes the properties of a list of objects into one object. * @function * @name mix * @static */ export function mix() { const mixin = {} function copyProperties (other) { for (const p in other) { if (!hasProp(other, p)) continue mixin[p] = other[p] } } for (let i = 0; i &lt; arguments.length; i++) { const template = arguments[i] if (isNothing(template)) continue if (!(typeof template === 'object')) continue copyProperties(template) } return mixin } /** * Prints a message to stdout (including newline). * * Supports the same string templates as {@class java.text.MessageFormat}. * * @example * import * as util from 'josm/util' * * const myname = '...' * util.println('Hello world! My name is {0}', myname); * // escape meta characters like {, } or ' with a leading apostrophe * util.println(\" a pair of curly braces '{'}\"); * * @summary Prints a message to stdout (including newline). * @param {string} message * @param {...object} [args] * @function * @name println * @static */ export function println() { const args = Array.prototype.slice.call(arguments, 0) if (args.length === 0) return '' args[0] = args[0] + '' // make sure first argument is a string const System = Java.type('java.lang.System') System.out.println(MessageFormat.format(args[0], args.slice(1))) } /** * Prints a message to stdout (without newline). * * Supports the same string templates as {@class java.text.MessageFormat} * * @example * import * as util from 'josm/util' * * const myname = \"...\" * util.print('Hello world! My name is {0}', myname) * // escape meta characters like {, } or ' with a leading apostrophe * util.print(\" a pair of curly braces '{'}\") * * @summary Prints a message to stdout (without newline). * @param {string} message * @param {...object} [args] * @function * @name print * @static */ export function print() { const args = Array.prototype.slice.call(arguments, 0) if (args.length === 0) return '' args[0] = args[0] + '' // make sure first argument is a string const System = Java.type('java.lang.System') System.out.print(MessageFormat.format(args[0], args.slice(1))) } /** * Checks whether two java objects are either both null or equal by calling * o1.equals(o2). * * @param {object} o1 a java object or null * @param {object} o2 a java object or null * @summary Are two java objects equal. * @return {boolean} * @function * @name javaEquals * @static */ export function javaEquals(o1, o2) { assert(typeof o1 === 'object' &amp;&amp; typeof o1.equals === 'function') assert(typeof o2 === 'object' &amp;&amp; typeof o2.equals === 'function') if (o1 === null &amp;&amp; o2 === null) return true if (o1 === null &amp;&amp; o2 !== null) return false return o1.equals(o2) } /** * Iterates over the elements in &lt;code&gt;collection&lt;/code&gt; and invokes * &lt;code&gt;delegate()&lt;/code&gt; on each element. * * @param {array|arguments|java.util.Collection} collection the collection of * elements * @param {function} delegate the function to call on each elemennt * @summary Iteraties over the elements of a collection * @function * @name each * @static */ export function each(collection, delegate) { const Collection = Java.type('java.util.Collection') if (isNothing(collection) || isNothing(delegate)) return if (isArray(collection) || isArguments(collection)) { const len = collection.length for (let i = 0; i &lt; len; i++) delegate(collection[i]) } else if (collection instanceof Collection) { for (let it = collection.iterator(); it.hasNext();) delegate(it.next()) } else { assert(false, 'collection: unexpected type of value, got {0}\"', collection) } } /** * Replies true, if a value is an array, an arguments list or a Java * collection. * * @param {object} value the value to check * @summary Is a value a collection? * @return {boolean} true, if &lt;code&gt;value&lt;/code&gt; is a collection * @function * @name isCollection * @static */ export function isCollection(value) { const Collection = Java.type('java.util.Collection') return isArray(value) || isArguments(value) || value instanceof Collection } export function hasProp(o, name) { return Object.prototype.hasOwnProperty.call(o, name) } Ã— Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Modules Classes Api Collection of static methods to download objects from and upload objects to the OSM server ChangesetApi Provides methods to open, close, get, update, etc. changesets on the OSM API server. ApiConfig ApiConfig provides methods and properties for configuring API parameters NodeBuilder NodeBuilder helps to create OSM nodes RelationBuilder Helps to create Relations WayBuilder Helps to create OSM Ways WayBuilder Creates a new WayBuilder with an underlying dataset. AddCommand ChangeCommand CommandHistory Accessor to the global command history DeleteCommand DataSetUtil Build an utility object wrapping the dataset ds Layers MenuBar exports.NodeBuilder Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Classes Classes Api Collection of static methods to download objects from and upload objects to the OSM server ChangesetApi Provides methods to open, close, get, update, etc. changesets on the OSM API server. ApiConfig ApiConfig provides methods and properties for configuring API parameters NodeBuilder NodeBuilder helps to create OSM nodes RelationBuilder Helps to create Relations WayBuilder Helps to create OSM Ways WayBuilder Creates a new WayBuilder with an underlying dataset. AddCommand ChangeCommand CommandHistory Accessor to the global command history DeleteCommand DataSetUtil Build an utility object wrapping the dataset ds Layers MenuBar exports.NodeBuilder Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Ã— Search results Close "},"module-clipboard.html":{"id":"module-clipboard.html","title":"Module: clipboard","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: clipboard Provides access to the system clipboard Source: clipboard.mjs, line 1 Example import clipboard from 'clipboard' Members &lt;static&gt; text Set or get the clipboard content as text Set or get the clipboard content as text get Replies the clipboard content as text or undefined, if no clipboard content is available or if it can't be converted to a string. set Sets the clipboard content Properties: Name Type Description text string clipboard content as text Source: clipboard.mjs, line 15 Example import clipboard from 'clipboard' // set the clipboard content clipboard.text = 'Hello World!' Ã— Search results Close "},"module-josm.html":{"id":"module-josm.html","title":"Module: josm","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm This modules exports an objects with a set of properties and methods to access JOSMs internals. Source: josm.mjs, line 1 Example import josm from 'josm' Members &lt;static, readonly&gt; commands the global command history Replies the global command history. Use this object to undo/redo commands, or to clear the command history. Properties: Name Type Description commands module:josm/command.CommandHistory Source: josm.mjs, line 225 Example import josm from 'josm' // undoes the last command josm.commands.undo() // redoes two commands josm.commands.redo(2) &lt;static, readonly&gt; console Replies an accessor to the JOSM scripting console. Replies an accessor to the JOSM scripting console. Use this object to write messages to the scripting console Properties: Name Type Description console module:josm/scriptingconsole accessor to the JOSM scripting console Source: josm.mjs, line 270 &lt;static, readonly&gt; layers accessor for JOSM layers Replies the layers object. Properties: Name Type Description layers module:josm/layers the layers object Source: josm.mjs, line 47 Example import josm from 'josm' josm.alert('num layers: ' + josm.layers.length) // name of first layer josm.alert('num layers: ' + josm.layers.get(0).name) &lt;static, readonly&gt; menu Replies an accessor for JOSMs menu bar. Replies an accessor for JOSMs menu bar. Use this object to inspect or modify the menu bar, i.e. to add additional menu items. Properties: Name Type Description menu module:josm/ui/menu~MenuBar accessor for JOSMs menu bar Source: josm.mjs, line 252 &lt;static, readonly&gt; version JOSM version string Replies the current JOSM version string. Properties: Name Type Description version string the JOSM version Source: josm.mjs, line 27 Example import josm from 'josm' josm.alert(josm.version) Ã— Search results Close "},"module-josm_api.html":{"id":"module-josm_api.html","title":"Module: josm/api","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/api This module provides functions to retrieve data from and upload data to an OSM server. Source: josm/api.mjs, line 1 Example import {Api, ChangesetApi, ApiConfig} from 'josm/api' Classes Api Collection of static methods to download objects from and upload objects to the OSM server ChangesetApi Provides methods to open, close, get, update, etc. changesets on the OSM API server. ApiConfig ApiConfig provides methods and properties for configuring API parameters Methods &lt;static&gt; buildBounds(obj) Creates a Bounds instance from a javascript object. Parameters: Name Type Description obj BoundsSpec1 | BoundsSpec2 a javascript object Source: josm/api.mjs, line 119 Returns: the bounds Type Bounds Example import { buildBounds } from 'josm/api' const bounds1 = buildBounds({ minlat: 46.9479186, minlon: 7.4619484, maxlat: 46.9497642, maxlon: 7.4660683 }) const bounds2 = buildBounds({ min: {lat: 46.9479186, lon: 7.4619484}, max: {lat: 46.9497642, lon: 7.4660683} }) &lt;static&gt; buildLatLon(obj) Create a LatLon from a javascript object. Creates a LatLon from a javascript object. Parameters: Name Type Description obj module:josm/api~LatLonSpec a specification of the position Source: josm/api.mjs, line 55 Returns: Type LatLon Example import { buildLatLon } from 'josm/api' const pos = buildLatLon({lat: 1, lon: 2}); Type Definitions BasicCredentials Basic credentials replied by getCredentials Properties: Name Type Description host string the host name user string the user name password string the password Source: josm/api.mjs, line 1152 BoundsSpec1 Specification of a bounds as JavaScript object. Properties: Name Type Description minlat number minlon number maxlat number maxlon number Source: josm/api.mjs, line 72 Example const bounds = { minlat: 46.9479186, minlon: 7.4619484, maxlat: 46.9497642, maxlon: 7.4660683 } BoundsSpec2 Specification of a bounds as JavaScript object. Properties: Name Type Description min module:josm/api~LatLonSpec the upper left point max module:josm/api~LatLonSpec the lower right point Source: josm/api.mjs, line 87 Example const bounds = { min: {lat: 46.9479186, lon: 7.4619484}, max: {lat: 46.9497642, lon: 7.4660683} } DownloadObjectOptions Options for the method downloadObject() Properties: Name Type Argument Default Description full boolean &lt;optional&gt; false if true, the object and its immediate children are downloaded, i.e. the nodes of a way and the relation members of a relation. Default: false. version number &lt;optional&gt; if present, the specified version of the object is downloaded. If missing, the current version is downloaded. If present, the option full is ignored. Source: josm/api.mjs, line 525 DownloadReferrerOptions Options for the method donwloadReferrers() Properties: Name Type Argument Default Description full boolean &lt;optional&gt; false If true, the full objects are retrieved using multi-gets. If missing or false, only proxy objects are downloaded. Default: false Source: josm/api.mjs, line 680 LatLonSpec Specification of position as lat/lon-pair. Properties: Name Type Description lat number the latitude lon number the longitude Source: josm/api.mjs, line 33 OAuthCredentials OAuth credentials replied by getCredentials Properties: Name Type Description key string the OAuth key secret string the OAuth secret Source: josm/api.mjs, line 1161 SetOrGetCredentialOptions Options for the method setCredentials Source: josm/api.mjs, line 1143 UploadOptions Options for the method upload() Properties: Name Type Argument Default Description strategy string | UploadStrategy &lt;optional&gt; Indicates how the data is uploaded. Either one of the strings individualobjects chunked singlerequest or one of the enumeration values in {@class org.openstreetmap.josm.io.UploadStrategy}. Default value: UploadStrategy.DEFAULT_UPLOAD_STRATEGY changeset number | Changeset &lt;optional&gt; The changeset to which the data is uploaded. Default: creates a new changeset chunkSize number &lt;optional&gt; the size of an upload chunk if the data is uploaded with the upload strategy {@class org.openstreetmap.josm.io.UploadStrategy}.CHUNKED_DATASET_STRATEGY. closeChangeset boolean &lt;optional&gt; true if true, closes the changeset after the upload Source: josm/api.mjs, line 818 Ã— Search results Close "},"module-josm_api.Api.html":{"id":"module-josm_api.Api.html","title":"Class: Api","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: Api josm/api. Api Collection of static methods to download objects from and upload objects to the OSM server. Note: this class doesn't provide a constructor. Methods and properties are 'static'. new Api() Collection of static methods to download objects from and upload objects to the OSM server Source: josm/api.mjs, line 399 Example // load the api import { Api } from 'josm/api' // download node 12345 const ds = Api.downloadObject(12345, 'node') Methods &lt;static&gt; downloadArea(bounds) Downloads the objects within a bounding box. Parameters: Name Type Description bounds Bounds | module:josm/api~BoundsSpec1 | module:josm/api~BoundsSpec2 the bounding box Source: josm/api.mjs, line 800 Returns: the downloaded primitives Type DataSet Example import { Api } from 'josm/api' const Bounds = Java.type('org.openstreetmap.josm.data.Bounds') const LatLon = Java.type('org.openstreetmap.josm.data.coor.LatLon') const ds1 = Api.downloadArea(new Bounds( new LatLon(46.9479186,7.4619484), // min new LatLon(46.9497642, 7.4660683) // max )) const ds2 = Api.downloadArea({ min: {lat: 46.9479186, lon: 7.4619484}, max: {lat: 46.9497642, lon: 7.4660683} }) &lt;static&gt; downloadObject(id [, type] [, options]) Downloads an object from the server. There are multiple options to specify what object to download. In addition, the function accepts a set of optional named parameters as last argument. downloadObject(id, type, ?options) id is the global numeric id. type is either one of the strings 'node', 'way', or 'relation', or one of the enumeration OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION downloadObject(id, ?options) id is a PrimitiveId or an object with the (mandatory) properties id and type, i.e. an object {id: ..., type: ...}. id is again a number, type is again either one of the strings 'node', 'way', or 'relation', or one of the enumeration OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. Parameters: Name Type Argument Description id number | PrimitiveId the id of the object type string | OsmPrimitiveType &lt;optional&gt; the type of the object options module:josm/api~DownloadObjectOptions &lt;optional&gt; named options Source: josm/api.mjs, line 587 Returns: the downloaded primitives Type DataSet Example import { Api } from 'josm/api' const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') // download the node with id 12345 const ds1 = Api.downloadObject(12345, 'node') // download the node with id 12345 const ds2 = Api.downloadObject({id: 12345, type: 'node'}) // download the full relation (including its members) with id 12345 const id = new SimplePrimitiveId(12345, OsmPrimitiveType.RELATION) const ds3 = Api.downloadObject(id, {full: true}) // download version 5 of the full way 12345 (including its nodes) const ds4 = Api.downloadObject(12345, OsmPrimitiveType.WAY, {full: true, version: 5}) &lt;static&gt; downloadReferrer(id [, type] [, options]) Downloads the objects referring to another object from the server. Downloads primitives from the OSM server which refer to a specific primitive. Given a node, the referring ways and relations are downloaded. Given a way or a relation, only referring relations are downloaded. The default behaviour is to reply proxy objects only. If you set the option {full: true}, every referring object is downloaded in full. There are multiple options to specify what referrers to download. In addition, the function accepts a set of optional named parameters as last argument. downloadReferrer(id, type, ?options) id is the global numeric id. type is either one of the strings 'node', 'way', or 'relation', or one of the enumeration OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. downloadReferrer(id, ?options) id is a PrimitiveId or an object with the (mandatory) properties id and type, i.e. an object {id: ..., type: ...}. id is again a number, type is again either one of the strings 'node', 'way', or 'relation', or one of the enumeration OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. Parameters: Name Type Argument Description id number | PrimitiveId the id of the object type string | OsmPrimitiveType &lt;optional&gt; the type of the object options module:josm/api~DownloadReferrerOptions &lt;optional&gt; named options Source: josm/api.mjs, line 758 Returns: the downloaded primitives Type DataSet Example import { Api } from 'josm/api' import { NodeBuilder } from 'josm/builder' const SimplePrimitiveId = Java.type('org.openstreetmap.josm.data.osm.SimplePrimitiveId') const OsmPrimitiveType = Java.type('org.openstreetmap.josm.data.osm.OsmPrimitiveType') // download the objects referring to the node with id 12345 const ds1 = Api.downloadReferrer(12345, 'node') // download the objects referring to the node with id 12345 const ds2 = Api.downloadReferrer({id: 12345, type: 'node'}) // download the relations referring to the relation with id 12345. // Referring relations are downloaded in full. const id = new SimplePrimitiveId(12345, OsmPrimitiveType.RELATION) const ds3 = Api.downloadReferrer(id, { full: true }) // create the global node 12345 ... const node = NodeBuilder.create(12345) // ... and downloads its referrers in full const ds = Api.downloadReferrer(node, { full: true }) &lt;static&gt; upload(data, comment [, options]) Uploads objects to the server. You can submit data either as DataSet, APIDataSet, javascript array of OsmPrimitives or a Collection of OsmPrimitives. This method supports the same upload strategy as the JOSM upload dialog. Supply the named parameter {strategy: ...} to choose the strategy. Be careful when uploading data to the OSM server! Do not upload copyright- protected or test data. The method takes care to update the primitives in the uploaded data when the upload succeeds. For instance, uploaded new primitives become global objects and get assigned their new id and version, successfully deleted objects become invisible, etc. Even if the entire upload of a dataset fails, a subset therefore may have been uploaded successfully. In order to keep track, which pritives have been uploaded successfully in case of an error, the method replies a collection of the successfully uploaded objects. Parameters: Name Type Argument Description data DataSet | APIDataSet | array | Collection the data to upload comment string the upload comment options module:josm/api~UploadOptions &lt;optional&gt; named options Source: josm/api.mjs, line 895 Returns: Type Collection Example const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') import { WayBuilder, NodeBuilder } from 'josm/builder' import { Api } from 'josm/api' const ds = new DataSet() const nb = NodeBuilder.forDataSet(ds) WayBuilder .forDataSet(ds) .withNodes( nb.withTags({name: 'node1'}).create(), nb.withTags({name: 'node2'}).create() ) .withTags({name: 'way1'}) .create() // uploads the data in a new changeset in one chunk const processed = Api.upload(ds, 'just testing') Ã— Search results Close "},"module-josm_api.ChangesetApi.html":{"id":"module-josm_api.ChangesetApi.html","title":"Class: ChangesetApi","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: ChangesetApi josm/api. ChangesetApi Provides methods to open, close, get, update, etc. changesets on the OSM API server. Note: this class doesn't provide a constructor. Methods and properties are static. new ChangesetApi() Provides methods to open, close, get, update, etc. changesets on the OSM API server. Source: josm/api.mjs, line 179 Example // load the changeset api import { ChangesetApi } from 'josm/api' // create a new changeset on the server const cs = ChangesetApi.open() Methods &lt;static&gt; close(changeset) Closes a changeset Parameters: Name Type Description changeset number | Changeset the changeset to close Source: josm/api.mjs, line 258 Returns: the changeset Type Changeset Example import { ChangesetApi } from 'josm/api' import * as util from 'josm/util' const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // closs the changeset 12345 ChangesetApi.close(12345) // open a new changeset with the tags given by the supplied changeset const cs2 = new Changeset(12345) cs2 = ChangesetApi.close(cs2) util.assert(cs2.closed) // the changeset is now closed &lt;static&gt; get(changeset) Get a changeset from the server Parameters: Name Type Description changeset number | Changeset the changeset to get Source: josm/api.mjs, line 349 Returns: the changeset Type Changeset Example import { ChangesetApi } from 'josm/api' const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // get the changeset with id 12345 const cs1 = ChangesetApi.get(12345) // get the changeset with id 12345 lets cs2 = new Changeset(12345) cs2 = ChangesetApi.get(cs2) &lt;static&gt; open( [changeset]) Creates and opens a changeset Parameters: Name Type Argument Description changeset Changeset | object &lt;optional&gt; the changeset to open Source: josm/api.mjs, line 202 Returns: the changeset Type Changeset Example import { ChangesetApi } from 'josm/api' const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // open a new changeset with no tags const cs1 = ChangesetApi.open() // open a new changeset with the tags given by the supplied changeset const cs2 = new Changeset() cs2.put('comment', 'a test comment') cs2 = ChangesetApi.open(cs2) // open a new changeset with the tags given by the object const cs3 = ChangesetApi.open({comment: 'a test comment'}) &lt;static&gt; update(changeset) Updates a changeset Parameters: Name Type Description changeset Changeset the changeset to update Source: josm/api.mjs, line 305 Returns: the changeset Type Changeset Example import { ChangesetApi } from 'josm/api' const Changeset = Java.type('org.openstreetmap.josm.data.osm.Changeset') // update the comment of a changeset const cs2 = new Changeset(12345) cs2.put('comment', 'an updated comment') cs2 = ChangesetApi.update(cs2) Ã— Search results Close "},"module-josm_api-ApiConfig.html":{"id":"module-josm_api-ApiConfig.html","title":"Class: ApiConfig","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: ApiConfig josm/api~ ApiConfig new ApiConfig() ApiConfig provides methods and properties for configuring API parameters ApiConfig provides methods and properties for configuring API parameters. Source: josm/api.mjs, line 994 Members &lt;static&gt; authMethod : string Get or set the authentication method. Get or set the authentication method. JOSM uses two authentication methods: basic Basic authentication with a username and a password oauth Authentication with the OAuth protocol. Type: string Properties: Name Type Description authMethod string the authentication method Source: josm/api.mjs, line 1101 Example import { ApiConfig } from 'josm/api' ApiConfig.authMethod // -&gt; the current authentication method // set OAuth as authentication method ApiConfig.authMethod = 'oauth' &lt;static, readonly&gt; defaultServerUrl Get the default server URL Get the default server URL. Properties: Name Type Description defaultServerUrl string the default server URL Source: josm/api.mjs, line 1071 Example import { ApiConfig } from 'josm/api' ApiConfig.defaultServerUrl // -&gt; the default server url &lt;static&gt; serverUrl Get or set the API server URL. Get or set the API server URL. get Replies the currently configured server URL or undefinend, if no server URL is configured. set Sets the current server URL. If null or undefined, removes the current configuration. Accepts either a string or a URL. Only accepts http or https URLs. Properties: Name Type Description serverUrl string Source: josm/api.mjs, line 1006 Example import { ApiConfig } from 'josm/api' ApiConfig.serverUrl // -&gt; the current server url // set a new API url ApiConfig.serverUrl = 'http://api06.dev.openstreetmap.org' Methods &lt;static&gt; getCredentials(authMethod [, options]) Gets the credentials, i.e. username and password for the basic authentication method. Parameters: Name Type Argument Description authMethod string the authentication method. Either basic or oauth options module:josm/api~SetOrGetCredentialOptions &lt;optional&gt; additional options Source: josm/api.mjs, line 1185 Returns: the credentials Type BasicCredentials | OAuthCredentials Example import { ApiConfig } from 'josm/api' // get username/password for the current OSM API server const credentials = ApiConfig.getCredentials('basic') &lt;static&gt; setCredentials(authMethod, credentials [, options]) Set the credentials, i.e. username and password for the basic authentication method. Basic authentication credentials are either an instance of PasswordAuthentication or an object {user: string, password: string}. OAuth authentication credentials are either an instance of OAuthToken or an object {key: string, secret: string}. Parameters: Name Type Argument Description authMethod string the authentication method. Either 'basic' or 'oauth'. credentials module:josm/api~BasicAuthParameters | module:josm/api~OAuthParameters | OAuthToken | PasswordAuthentication the credentials options module:josm/api~SetOrGetCredentialOptions &lt;optional&gt; additional options Source: josm/api.mjs, line 1317 Returns: the credentials Type object Example import { ApiConfig } from 'josm/api' // set the credentials ApiConfig.setCredentials('basic', { user:'test', password:'my-password' }) Ã— Search results Close "},"module-josm_builder.html":{"id":"module-josm_builder.html","title":"Module: josm/builder","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/builder Collection of builders for creating OSM nodes, ways and relations. Source: josm/builder.mjs, line 1 See: module:josm/builder/node~NodeBuilder module:josm/builder/way~WayBuilder module:josm/builder/relation~RelationBuilder Example // josm/builder exports the NodeBuilder, WayBuilder, and RelationBuilder // from its sub modules import { NodeBuilder, WayBuilder, RelationBuilder } from 'josm/builder' Ã— Search results Close "},"module-josm_builder_node.html":{"id":"module-josm_builder_node.html","title":"Module: josm/builder/node","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/builder/node Source: josm/builder/node-builder.mjs, line 1 Classes NodeBuilder NodeBuilder helps to create OSM nodes Ã— Search results Close "},"module-josm_builder_node-NodeBuilder.html":{"id":"module-josm_builder_node-NodeBuilder.html","title":"Class: NodeBuilder","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: NodeBuilder josm/builder/node~ NodeBuilder new NodeBuilder( [ds]) NodeBuilder helps to create OSM nodes NodeBuilder helps to create OSM nodes. Methods of NodeBuilder can be used in a static and in an instance context. It isn't necessary to create an instance of NodeBuilder, unless it is configured with a DataSet, to which created nodes are added. Parameters: Name Type Argument Description ds DataSet &lt;optional&gt; the dataset which created objects are added to Source: josm/builder/node-builder.mjs, line 31 Example import {NodeBuilder} from 'josm/builder' const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() // create a node builder without and underlying dataset ... let nbuilder = new NodeBuilder() // ... with an underlying dataset .... nbuilder = new NodeBuilder(ds) // ... or using this factory method nbuilder = NodeBuilder.forDataSet(ds) // create a new local node at position (0,0) without tags const n1 = NodeBuilder.create() // create a new global node at a specific position with tags const n2 = NodeBuilder.withPosition(1,1).withTags({name: 'test'}).create(1) // create a new proxy for a global node // (an 'incomplete' node in JOSM terminology) const n3 = NodeBuilder.createProxy(2) Methods create( [id] [, options]) Creates a new Node Creates a new Node. Can be used in an instance or in a static context. Parameters: Name Type Argument Description id number &lt;optional&gt; a global node id. If missing and not set before using withId(..), creates a new local id. options module:josm/builder/node~NodeBuilder.NodeBuilderOptions &lt;optional&gt; additional options for creating the node Source: josm/builder/node-builder.mjs, line 184 Returns: the created node Type Node Example import { NodeBuilder } from 'josm/builder' // create a new local node at position [0,0] const n1 = NodeBuilder.create() // create a new global node with id 1111 at position [0,0] const n2 = NodeBuilder.create(1111) // create a new global node with version 3 at a specific position // and with some tags const n3 = NodeBuilder.create(2222, { version: 3, lat: 23.45, lon: 87.23, tags: {amenity: 'restaurant'} }) createProxy(id) Creates a new proxy Node. A proxy node is a node, for which we only know its global id. In order to know more details (position, tags, etc.), we would have to download it from the OSM server. The method can be used in a static and in an instance context. Parameters: Name Type Description id number the node id (not null, number &gt; 0 expected) Source: josm/builder/node-builder.mjs, line 276 Returns: the new proxy node Type Node Example import { NodeBuilder } from 'josm/builder' // a new proxy node for the global node with id 1111 const n1 = NodeBuilder.createProxy(1111) forDataSet(ds) Creates a new NodeBuilder for a specific DataSet. Creates or configures a NodeBuilder which will add created nodes to the dataset ds. Parameters: Name Type Description ds DataSet the dataset which created objects are added to Source: josm/builder/node-builder.mjs, line 108 Returns: the node builder Type module:josm/builder/node~NodeBuilder Example import { NodeBuilder } from 'josm/builder' // create a new node builder building to a data set const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() // ... using a static method ... const nb1 = NodeBuilder.forDataSet(ds) // ... or the instance method const nb2 = new NodeBuilder.forDataSet(ds) withId(id [, version]) Declares the global node id and the global node version. The method can be used in a static and in an instance context. Parameters: Name Type Argument Default Description id number the global node id. A number &gt; 0. version number &lt;optional&gt; 1 optional the global node version. If present, a number &gt; 0. Source: josm/builder/node-builder.mjs, line 370 Returns: the node builder (for method chaining) Type module:josm/builder/node~NodeBuilder withPosition(lat, lon) Declares the node position. The method can be used in a static and in an instance context. Parameters: Name Type Description lat Number the latitude. A number in the range [-90..90]. lon Number the longitude. A number in the range [-180..180]. Source: josm/builder/node-builder.mjs, line 313 Returns: a node builder (for method chaining) Type module:josm/builder/node~NodeBuilder Example import { NodeBuilder } from 'josm/builder' // a new global node with the global id 1111 at position (34,45) const n1 = NodeBuilder.withPosition(34,45).create(1111) // a new local node at position (23.2, 87.33) const n2 = NodeBuilder.withPosition(23.3,87.33).create() withTags( [tags]) Declares the tags to be assigned to the new node. The method can be used in a static and in an instance context. Parameters: Name Type Argument Description tags object &lt;optional&gt; the tags Source: josm/builder/node-builder.mjs, line 350 Returns: the node builder (for method chaining) Type module:josm/builder/node~NodeBuilder Example import { NodeBuilder } from 'josm/builder' // a new global node with the global id 1111 and tags name=test and // highway=road const n1 = NodeBuilder.withTags({'name':'test', 'highway':'road'}).create(1111) // a new local node with tags name=test and highway=road const tags = { 'name' : 'test', 'highway' : 'road' } const n2 = NodeBuilder.withTags(tags).create() Type Definitions NodeBuilderOptions Named options for {@link module:josm/builder/node~NodeBuilder#create create} Properties: Name Type Argument Default Description version number &lt;optional&gt; 1 the version (&gt; 0) of the node. Default: 1. lat number &lt;optional&gt; 0.0 a valide latitude (number in the range [-90,90]. Default: 0.0 lon number &lt;optional&gt; 0.0 a valide longitude (number in the range[-180,180]. Default: 0.0 pos Array.&lt;number&gt; | Object &lt;optional&gt; null a position, either an array with two numbers or as an object tags object &lt;optional&gt; an object with tags. Null values and undefined values are ignored. Any other value is converted to a string. Leading and trailing white space in keys is removed. Source: josm/builder/node-builder.mjs, line 130 Example // options to create a node at position (1.0, 2.0) with some tags const options = { lat: 1.0, lon: 2.0, tags: { amenity: 'restaurant' } } Ã— Search results Close "},"module-josm_builder_relation.html":{"id":"module-josm_builder_relation.html","title":"Module: josm/builder/relation","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/builder/relation Source: josm/builder/relation-builder.mjs, line 1 Example import {RelationBuilder} from 'josm/builder' // creates a new relation with no tags and a // local id const relation = RelationBuilder.create() Classes RelationBuilder Helps to create Relations Ã— Search results Close "},"module-josm_builder_relation-RelationBuilder.html":{"id":"module-josm_builder_relation-RelationBuilder.html","title":"Class: RelationBuilder","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: RelationBuilder josm/builder/relation~ RelationBuilder new RelationBuilder(ds) Helps to create Relations RelationBuilder helps to create OSM Relations. Methods of RelationBuilder can be used in a static and in an instance context. It isn't necessary to create an instance of RelationBuilder, unless it is configured with a DataSet to which created ways are added. Parameters: Name Type Description ds DataSet (optional) a JOSM dataset which created ways are added to. If missing, the created ways aren't added to a dataset. Source: josm/builder/relation-builder.mjs, line 40 Example import {RelationBuilder} from 'josm/builder' const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() // create a relation builder without and underlying dataset ... let rbuilder = new RelationBuilder() // ... with an underlying dataset ... rbuilder = new RelationBuilder(ds) // ... or using this factory method rbuilder = RelationBuilder.forDataSet(ds) // create a new local relation const r1 = rbuilder.create() // create a new global way const r2 = rbuilder.withTags({route: 'bicycle'}).create(1111) // create a new proxy for a global relation // (an 'incomplete' node in JOSM terminology) const r3 = rbuilder.createProxy(2222) Methods &lt;static&gt; forDataSet(ds) Creates or configures a RelationBuilder which will add created nodes to the dataset ds. Parameters: Name Type Description ds DataSet a JOSM dataset which created ways are added to. Source: josm/builder/relation-builder.mjs, line 107 Returns: the relation builder Type module:josm/builder/relation~RelationBuilder Example import {RelationBuilder} = 'josm/builder' // create a new relation builder building to a data set const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() const rb1 = RelationBuilder.forDataSet(ds) // configure an existing relation builder let rb2 = new RelationBuilder() rb2 = rb2.forDataSet(ds) &lt;static&gt; member( [role], primitive) Utility function - creates a relation member Create a RelationMember member(role, obj) Create a relation member with role role and member object obj. role can be null or undefined, obj must neither be null nor undefinde. role is a string, obj is an OSM node, a way, or a relation. member(obj) Create a relation member for the member object obj. obj must neither be null nor undefinde. obj is an OSM node, a way, or a relation. The created relation member has no role. Parameters: Name Type Argument Description role string &lt;optional&gt; the member role primitive primitive the member primitive Source: josm/builder/relation-builder.mjs, line 150 Returns: the relation member Type RelationMember Example import {RelationBuilder, NodeBuilder} from 'josm/builder' // create a new RelationMember with role 'house' for a new node const m1 = RelationBuilder.member('house', NodeBuilder.create()) // create a new RelationMember with an empty role for a new node const m2 = RelationBuilder.member(NodeBuilder.create()) create( [id] [, options]) Creates a new relation. Can be used in an instance or in a static context. Parameters: Name Type Argument Description id number &lt;optional&gt; a global way id. If missing and not set before using withId(..), creates a new local id. options module:josm/builder/relation~RelationBuilder.RelationBuilderOptions &lt;optional&gt; options for creating the relation Source: josm/builder/relation-builder.mjs, line 425 Returns: the relation Type Relation Example import { NodeBuilder, RelationBuilder } from 'josm/builder' const member = RelationBuilder.member // create a new local relation const r1 = RelationBuilder.create() // create a new global relation const r2 = RelationBuilder.create(1111) // create a new global relation with version 3 with some tags and two // members const r3 = RelationBuilder.create(2222, { version: 3, tags: {type: 'route'}, members: [ member('house', NodeBuilder.create()), member(NodeBuilder.create()) ] }) createProxy(id) Creates a new proxy relation. A proxy relation is a relation, for which we only know its global id. In order to know more details (members, tags, etc.), we would have to download it from the OSM server. The method can be used in a static and in an instance context. Parameters: Name Type Description id number the id for the proxy relation Source: josm/builder/relation-builder.mjs, line 264 Returns: the new proxy relation Type Relation Example import {RelationBuilder} from 'josm/builder' // a new proxy relation for the global way with id 1111 const r1 = RelationBuilder.createProxy(1111) withId(id [, version]) Declares the global relation id and the global relation version. The method can be used in a static and in an instance context. Parameters: Name Type Argument Default Description id number the global relation id. A number &gt; 0. version number &lt;optional&gt; 1 the global relation version. If present, a number &gt; 0 Source: josm/builder/relation-builder.mjs, line 206 Returns: the relation builder (for method chaining) Type module:josm/builder/relation~RelationBuilder Example import {RelationBuilder} from 'josm/builder' // creates a global relation with id 1111 an version 22 const r = RelationBuilder.withId(1111, 22).create() withMembers(members) Declares the members of a relation. Accepts either a vararg list of relation members, nodes, ways or relations, an array of relation members, nodes ways or relations, or a Java list of members, nodes, ways or relation. The method can be used in a static and in an instance context. Parameters: Name Type Argument Description members OsmPrimitive | RelationMember | Array.&lt;(OsmPrimitive|RelationMember)&gt; | List &lt;repeatable&gt; the list of members. See description and examples. Source: josm/builder/relation-builder.mjs, line 321 Returns: the relation builder (for method chaining) Type module:josm/builder/relation~RelationBuilder Example import {RelationBuilder, NodeBuilder} from 'josm/builder' const {member} = RelationBuilder const r1 = RelationBuilder.withMembers( member('house', NodeBuilder.create()), member('house', NodeBuilder.create()) ) .create() const members = [ NodeBuilder.create(), // empty role member('house', NodeBuilder.create() ] const r2 = RelationBuilder.withMembers( members, NodeBuilder.create(), ).create() withTags( [tags]) Declares the tags to be assigned to the new relation. The method can be used in a static and in an instance context. Parameters: Name Type Argument Description tags object &lt;optional&gt; the tags Source: josm/builder/relation-builder.mjs, line 237 Returns: a relation builder (for method chaining) Type module:josm/builder/relation~RelationBuilder Example import {RelationBuilder} from 'josm/builder' // a new global relation with the global id 1111 and tags route='bicycle' //and name='n8' const r1 = RelationBuilder.withTags({name:'n8', route:'bicycle'}).create(1111) // a new local relation with tags name=test and highway=road const tags = { name : 'n8', route : 'bicycle' } const r2 = RelationBuilder.withTags(tags).create() Type Definitions RelationBuilderOptions Named options for {@link module:josm/builder/relation~RelationBuilder#create create} Properties: Name Type Argument Default Description id number &lt;optional&gt; the id (&gt; 0) of the way. Default: creates new local id. version number &lt;optional&gt; 1 the version (&gt; 0) of the way. Default: 1. tags object &lt;optional&gt; an object with tags. Null values and undefined values are ignored. Any other value is converted to a string. Leading and trailing white space in keys is removed. members RelationMember[] | List &lt;optional&gt; the member for the relation Source: josm/builder/relation-builder.mjs, line 368 Example import {RelationBuilder, NodeBuilder} from 'josm/builder' const {member} = RelationBuilder // options to create a relation const options = { version: 3, tags: {type: 'route'}, members: [ member('house', NodeBuilder.create()), member(NodeBuilder.create()) ] } Ã— Search results Close "},"module-josm_builder_way.html":{"id":"module-josm_builder_way.html","title":"Module: josm/builder/way","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/builder/way Source: josm/builder/way-builder.mjs, line 1 Classes WayBuilder Helps to create OSM Ways Ã— Search results Close "},"module-josm_builder_way-WayBuilder.html":{"id":"module-josm_builder_way-WayBuilder.html","title":"Class: WayBuilder","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: WayBuilder josm/builder/way~ WayBuilder new WayBuilder( [ds]) Helps to create OSM Ways WayBuilder helps to create OSM Ways. Methods of WayBuilder can be used in a static and in an instance context. It isn't necessary to create an instance of WayBuilder, unless it is configured with a DataSet, to which created ways are added. Parameters: Name Type Argument Description ds DataSet &lt;optional&gt; a JOSM dataset to which created ways are added. If missing, the created ways aren't added to a dataset. Source: josm/builder/way-builder.mjs, line 35 Example import {WayBuilder} from 'josm/builder' const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const ds = new DataSet() // create a way builder without and underlying dataset ... let wbuilder = new WayBuilder() // ... with an underlying dataset .... wbuilder = new WayBuilder(ds) // ... or using this factory method wbuilder = WayBuilder.forDataSet(ds) // create a new local way const w1 = wbuilder.create() // create a new global way const w2 = wbuilder.withTags({highway: 'residential'}).create(1111) // create a new proxy for a global way // (an 'incomplete' node in JOSM terminology) const w3 = wbuilder.createProxy(2222) Classes WayBuilder Creates a new WayBuilder with an underlying dataset. Methods create( [id] [, options]) Creates a new way. Can be used in an instance or in a static context. Parameters: Name Type Argument Description id number &lt;optional&gt; a global way id. If missing and not set before using withId(..), creates a new local id. options module:josm/builder/way~WayBuilder.WayBuilderOptions &lt;optional&gt; additional parameters for creating the way Source: josm/builder/way-builder.mjs, line 368 Returns: the created way Type Way Example import {WayBuilder, NodeBuilder} from 'josm/builder' // create a new local way const w1 = WayBuilder.create() // create a new global way const w2 = WayBuilder.create(1111) // create a new global way with version 3 with some nodes and with // some tags const w3 = WayBuilder.create(2222, { version: 3, tags: {higway: 'primary'}, nodes: [ NodeBuilder.withPosition(1,1).create(), NodeBuilder.withPosition(2,2).create(), NodeBuilder.withPosition(3,3).create() ] }) createProxy(id) Creates a new proxy way. A proxy way is a way for which we only know its global id. In order to know more details (nodes, tags, etc.), we would have to download it from the OSM server. The method can be used in a static and in an instance context. Parameters: Name Type Description id number the id. A number &gt; 0 Source: josm/builder/way-builder.mjs, line 273 Returns: the new proxy way Type Way Example import {WayBuilder} from 'josm/builder' // a new proxy way for the global way with id 1111 const w1 = WayBuilder.createProxy(1111) forDataSet(ds) Creates or configures a WayBuilder which will add created nodes to the dataset ds. Parameters: Name Type Description ds DataSet the dataset to which created objects are added Source: josm/builder/way-builder.mjs, line 110 Returns: the way builder Type module:josm/builder/way~WayBuilder Example import {DataSet, WayBuilder} from 'josm/builder' // create a new way builder which builds to a data set const ds = new DataSet() let wb = WayBuilder.forDataSet(ds) withId(id [, version]) Declares the global way id and the global way version. The method can be used in a static and in an instance context. Parameters: Name Type Argument Description id number (mandatory) the global way id. A number &gt; 0. version number &lt;optional&gt; the global way version. If present, a number &gt; 0. If missing, the version 1 is assumed. Source: josm/builder/way-builder.mjs, line 138 Returns: the way builder (for method chaining) Type module:josm/builder/way~WayBuilder Example import {WayBuilder} from 'josm/builder' // creates a global way with id 1111 an version 22 const way = WayBuilder.withId(1111, 22).create() withNodes( [nodes]) Declares the nodes of the way. Accepts either a vararg list of Node, an array of Nodes or a Java list of Nodes. At least two non-identical nodes have to be supplied. The same node can occure more than once in the list, but a consecutive sequence of the same node is collapsed to one node. The method can be used in a static and in an instance context. Parameters: Name Type Argument Description nodes Node | List | Node[] &lt;optional&gt; the list of nodes. See description and examples. Source: josm/builder/way-builder.mjs, line 207 Returns: the way builder (for method chaining) Type module:josm/builder/way~WayBuilder Example import {WayBuilder, NodeBuilder} from 'josm/builder' // creates a new local way with two local nodes const way = WayBuilder.withNodes( NodeBuilder.create(), NodeBuilder.create() ).create() withTags( [tags]) Declares the tags to be assigned to the new way. The method can be used in a static and in an instance context. Parameters: Name Type Argument Description tags object &lt;optional&gt; the tags Source: josm/builder/way-builder.mjs, line 171 Returns: the way builder (for method chaining) Type module:josm/builder/way~WayBuilder Example import {WayBuilder} from 'josm/builder' // a new global way with the global id 1111 and tags name='Laubeggstrasse' // and highway=residential const w1 = WayBuilder.withTags({name:'Laubeggstrasse', highway:'residential'}) .create(1111) // a new local way with tags name=test and highway=road const tags = { name : 'Laubeggstrasse', highway : 'residential' } const w2 = WayBuilder.withTags(tags).create() Type Definitions WayBuilderOptions Named options for {@link module:josm/builder/way~WayBuilder#create create} Properties: Name Type Argument Default Description id number &lt;optional&gt; the id (&gt; 0) of the way. Default: creates new local id. version number &lt;optional&gt; 1 the version (&gt; 0) of the way. Default: 1. tags object &lt;optional&gt; an object with tags. Null values and undefined values are ignored. Any other value is converted to a string. Leading and trailing white space in keys is removed. nodes Node[] | List &lt;optional&gt; the nodes for the way. Source: josm/builder/way-builder.mjs, line 310 Example import {NodeBuilder} from 'josm/builder' // options to create a way const options = { version: 3, tags: {highway: 'primary'}, nodes: [ NodeBuilder.withPosition(1,1).create(), NodeBuilder.withPosition(2,2).create(), NodeBuilder.withPosition(3,3).create() ] } Ã— Search results Close "},"module-josm_builder_way-WayBuilder.WayBuilder.html":{"id":"module-josm_builder_way-WayBuilder.WayBuilder.html","title":"Class: WayBuilder","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: WayBuilder josm/builder/way~WayBuilder. WayBuilder new WayBuilder(ds) Creates a new WayBuilder with an underlying dataset. Creates a new WayBuilder with an underlying dataset. Parameters: Name Type Description ds DataSet the dataset which created objects are added to Source: josm/builder/way-builder.mjs, line 74 Returns: the way builder Type module:josm/builder/way~WayBuilder Ã— Search results Close "},"module-josm_command.html":{"id":"module-josm_command.html","title":"Module: josm/command","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/command A collection of functions to create commands which can be applied, undone and redone on OsmDataLayers. Source: josm/command.mjs, line 1 Example import { buildAddCommand, buildChangeCommand, buildDeleteCommand } from 'josm/command' Classes AddCommand ChangeCommand CommandHistory Accessor to the global command history DeleteCommand Methods &lt;static&gt; buildAddCommand(obj) Creates a command to add a collection of objects to a data layer. Signatures add(obj, obj, ...) obj are Nodes, Ways, or Relationss. Or javascript array or Java collections thereof. Parameters: Name Type Argument Description obj OsmPrimitive | OsmPrimitive[] | Collection &lt;repeatable&gt; the primitives to add Source: josm/command.mjs, line 151 Returns: the command object Type module:josm/command.AddCommand Example import {buildAddCommand} from 'josm/command' import layers from 'josm/layer' import {NodeBuilder} from 'josm/builder' const layer = layers.get('Data Layer 1') // add two nodes buildAddCommand( NodeBuilder.create(), NodeBuilder.create() ).applyTo(layer) &lt;static&gt; buildChangeCommand(objs, change) Creates a command to change a collection of objects in a data layer. The mandatory last argument is an object with named parameters. Parameters: Name Type Argument Description objs OsmPrimitive | OsmPrimitive[] | Collection &lt;repeatable&gt; the objects to change. See documentation. change module:josm/command~ChangeSpec the change specification Source: josm/command.mjs, line 402 Returns: the change command object Type module:josm/command.ChangeCommand Example import {buildChangeCommand} from 'josm/command' import layers from 'josm/layers' const layer = layers.get(\"Data Layer 1\") // change the position of a node buildChangeCommand(n1, {lat: 123.45, lon: 44.234}).applyTo(layer) // change the tags of a collection of primitives buildChangeCommand(n1, n3, w1, r1, { tags: {'mycustomtag': 'value'} }).applyTo(layer) &lt;static&gt; buildDeleteCommand(obj) Creates a command to delete a collection of objects in a data layer. Parameters: Name Type Argument Description obj OsmPrimitive | OsmPrimitive[] | Collection &lt;repeatable&gt; the primitives to delete Source: josm/command.mjs, line 195 Returns: the command object Type module:josm/command.DeleteCommand Example import {buildDeleteCommand} from 'josm/command' import layers from 'josm/layer' import {NodeBuilder} from 'josm/builder' const layer = layers.get('Data Layer 1') // delete two nodes buildDeleteCommand(NodeBuilder.create(),NodeBuilder.create()).applyTo(layer) * &lt;static&gt; combineSelectedWays() Combines the currently selected ways. Combines the currently selected ways in the active layer into one resulting way. Returns without effect if there is no active layer the active layer is not a data layer there are less than two selected ways in the active layer Reuses the logic behind the JOSM standard menu entry Tools-&gt;Combine Ways. If invoked from a script, this may trigger modal dialogs which are presented to the user, in particular if the direction of the ways has to be reversed because otherwise they could not be combined. Source: josm/command.mjs, line 593 Example import {combineSelectedWays} from 'josm/command' import layers from 'josm/layer' const ds = layers.activeLayer.data combineSelectedWays(ways) &lt;static&gt; combineWays(ways, ways) Combines two or more ways into one resulting way. Combines two or more ways into one resulting way. Reuses the logic behind the JOSM standard menu entry Tools-&gt;Combine Ways. If invoked from a script, this may trigger modal dialogs which are presented to the user, in particular if the direction of the ways has to be reversed because otherwise they could not be combined. Parameters: Name Type Description ways the ways to be combined ways Way | array the ways to be combined Source: josm/command.mjs, line 540 Example import {combineWays} from 'josm/command' import layers from 'josm/layer' const ds = layers.activeLayer.data const ways = [ds.way(1), ds.way(2), ds.way(3)] // pass in an array ... combineWays(ways) // ... or the individual ways ... combineWays(ds.way(1), ds.way(2), ds.way(3)) // ... or any combination thereof. Type Definitions ChangeSpec The change specification for a change command. Type: Object Properties: Name Type Description lat number if present and applied to a node, changes the nodes latitude lon number if present and applied to a node, changes the nodes longitude pos LatLon | module:josm/command~LatLonSpec if present and applied to a node, changes the nodes position tags Map | object if present, changes the tags of the target object nodes List | OsmPrimitive[] if present and applied to a way, changes the ways nodes nodes List | RelationMember[] if present and applied to a relation, changes the relations members Source: josm/command.mjs, line 351 Example // change the positon of a node const changeSpec1 = { lat: 1.0, lon: 2.0 } // change the tags of one or more primitives const changeSpec2 = { tags: { amentity: 'restaurant' } } LatLonSpec A lat/lon position as a JavaScript object. Type: Object Properties: Name Type Description lat number the latitude of the position lon number the longitude of the position Source: josm/command.mjs, line 338 Example const latLonSpec = { lat: 1.0, lon: 1.0 } Ã— Search results Close "},"module-josm_command.AddCommand.html":{"id":"module-josm_command.AddCommand.html","title":"Class: AddCommand","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: AddCommand josm/command. AddCommand A command to add a collection of objects to a data layer. new AddCommand(objs) Parameters: Name Type Description objs Collection | array the objects to add Source: josm/command.mjs, line 101 Methods createJOSMCommand(layer) Creates the internal JOSM command for this command Parameters: Name Type Description layer OsmDataLayer the data layer Source: josm/command.mjs, line 115 Returns: the command Type Command Ã— Search results Close "},"module-josm_command.ChangeCommand.html":{"id":"module-josm_command.ChangeCommand.html","title":"Class: ChangeCommand","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: ChangeCommand josm/command. ChangeCommand A command to change a collection of objects in a data layer. new ChangeCommand(objs, change) Parameters: Name Type Description objs Collection | array the objects to change change Change the change specification Source: josm/command.mjs, line 317 Methods createJOSMCommand(layer) Creates the internal JOSM command for this command Parameters: Name Type Description layer OsmDataLayer the data layer Source: josm/command.mjs, line 330 Returns: the command object Type Command Ã— Search results Close "},"module-josm_command.CommandHistory.html":{"id":"module-josm_command.CommandHistory.html","title":"Class: CommandHistory","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: CommandHistory josm/command. CommandHistory Accessor to the global command history. Provides static methods to redo and undo commands. new CommandHistory() Accessor to the global command history Source: josm/command.mjs, line 441 Methods &lt;static&gt; clear( [layer]) Removes commands in the command history, either all commands, or only the commands applied to a specific layer. Parameters: Name Type Argument Description layer Layer &lt;optional&gt; the reference layer. Only commands applied to this layer are removed. Default if missing: all commands are removed. Source: josm/command.mjs, line 489 &lt;static&gt; redo( [depth]) Redoes the last depth commands. Parameters: Name Type Argument Default Description depth number &lt;optional&gt; 1 the number of commands to be redone. Source: josm/command.mjs, line 467 &lt;static&gt; undo( [depth]) Undoes the last depth commands. Parameters: Name Type Argument Default Description depth number &lt;optional&gt; 1 the number of commands to be undone Source: josm/command.mjs, line 448 Ã— Search results Close "},"module-josm_command.DeleteCommand.html":{"id":"module-josm_command.DeleteCommand.html","title":"Class: DeleteCommand","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: DeleteCommand josm/command. DeleteCommand A command to delete a collection of objects in a data layer. new DeleteCommand(objs) Parameters: Name Type Description objs Collection | array the objects to add Source: josm/command.mjs, line 161 Methods createJOSMCommand(layer) Creates the internal JOSM command for this command Parameters: Name Type Description layer OsmDataLayer the data layer Source: josm/command.mjs, line 173 Returns: the command object Type Command Ã— Search results Close "},"module-josm_ds.html":{"id":"module-josm_ds.html","title":"Module: josm/ds","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/ds Provides utitly methods for data sets Source: josm/ds.mjs, line 1 Classes DataSetUtil Build an utility object wrapping the dataset ds Methods &lt;static&gt; buildId(args) Creates an ID for an OSM primitive. Signatures buildId(id, type) Replies an object given by its unique numeric id and a type. The type is either a string node, way, or relation, or one of the symbols OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. buildId(id) Replies an object given an ID. id is either an instance of PrimitiveId or an object with the properties id and type, i.e. {id: 1234, type: 'node'}. Parameters: Name Type Description args see description Source: josm/ds.mjs, line 110 Example import { buildId, OsmPrimitiveType} from 'josm/ds' // build a node id const id1 = buildId(1234, 'node') // build a way id const id2 = buildId(3333, OsmPrimitiveType.WAY) // build a relation id const id3 = buildId({id: 5423, type: 'relation'}) Ã— Search results Close "},"module-josm_ds.DataSetUtil.html":{"id":"module-josm_ds.DataSetUtil.html","title":"Class: DataSetUtil","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: DataSetUtil josm/ds. DataSetUtil DataSetUtil provides methods to build OSM primitive IDs and to manipulate data in a DataSet. new DataSetUtil( [ds]) Build an utility object wrapping the dataset ds Creates an instance of DataSetUtil for a given DataSet Parameters: Name Type Argument Description ds DataSet &lt;optional&gt; the dataset. Creates a new dataset if missing Source: josm/ds.mjs, line 193 Example import { DataSetUtil, DataSet } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) Members &lt;readonly&gt; nodeBuilder Replies a node builder to create Nodes in this dataset. Properties: Name Type Description nodeBuilder module:josm/builder~NodeBuilder Source: josm/ds.mjs, line 447 Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) const n = dsutil.nodeBuilder .withId(1234,4567) .withTags({amenity: 'restaurant'}) .create() dsutil.has(n) &lt;readonly&gt; relationBuilder Replies a relation builder to create relations in this dataset. Properties: Name Type Description relationBuilder module:josm/builder~RelationBuilder Source: josm/ds.mjs, line 486 Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) const r = dsutil.relationBuilder() .withId(8765,1234) .create({tags: {type: 'network'}}) ds.has(r) // --&gt; true &lt;readonly&gt; wayBuilder Replies a way builder to create ways in this dataset. Properties: Name Type Description wayBuilder module:josm/builder~WayBuilder Source: josm/ds.mjs, line 467 Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) const nb = dsutil.nodeBuilder() const w = dsutil.wayBuilder() .withNodes(nb.create(), nb.create()) .create(1234, {tags: {highway: \"residential\"}}) dsutil.has(w) Methods &lt;static&gt; load(source [, options]) Loads a dataset from a file. Derives the format of the file from the file suffix, unless the named option options.format is set. options can contain the following named options: format one of the strings osm (Open Street Map XML data), osc (Open Street Map change format), or osm.gz (Open Street Map XML data, compressed with gzip). The format is normalized: white space is removed and it is converted to lower case. Parameters: Name Type Argument Description source string | File the data source options object &lt;optional&gt; optional named parameters Source: josm/ds.mjs, line 520 Returns: the data set util with the loaded data set Type module:josm/ds~DataSetUtil Example import { DataSetUtil } from 'josm/ds' // loads an OSM file DataSetUtil.load('/path/to/my/file.osm') // loads an OSM file, explicity passing in the format DataSetUtil.load('/path/to/my/file.any-suffix', { format 'osm' }) batch(delegate) Run a sequence of operations against the dataset in \"batch mode\". Listeners to data set events are only notified at the end of the batch. Parameters: Name Type Description delegate function the function implementing the batch process. Ignored if null or undefined. Source: josm/ds.mjs, line 331 Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) // creates and adds two nodes and a way in batch operation // to the dataset dsutil.batch(() =&gt; { const n1 = dsutil.nodeBuilder().create() const n2 = dsutil.nodeBuilder().create() dsutil.wayBuilder().withNodes(n1,n2).create() }) get(args) Replies an OSM object from the dataset, or undefined, if no such object exists. Signatures get(id, type) Replies an object given by its unique numeric id and a type. The type is either a string \"node\", \"way\", or \"relation\", or one of the symbols OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. get(id) Replies an object given an ID. id is either an instance of PrimitiveId or an object with the properties id and type, i.e. {id: 1234, type: \"node\"}. Parameters: Name Type Description args see description Source: josm/ds.mjs, line 254 Example import { buildId , DataSetUtil, DataSet, OsmPrimitiveType} from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) // get a node const n1 = dsutil.get(1234, 'node') // get a way const w1 = dsutil.get(3333, OsmPrimitiveType.WAY) // get a relation const r1 = dsutil.get({id: 5423, type: 'relation'}) // pass in a SimplePrimitiveId const id = buildId(-5, OsmPrimitiveType.NODE) const n2 = dsutil.get(id) // pass in a primitive to get it const w2 = dsutil.wayBuilder().create(987) const w3 = dsutil.get(w2) node(id) Replies the node with id id, or null. Parameters: Name Type Description id number the unique numeric id. Must not be 0. Source: josm/ds.mjs, line 272 Returns: the node Type Node Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) // get a node const n = dsutil.node(1234) query(expression [, options]) Queries the dataset Signatures query(josmSearchExpression,?options) Queries the dataset using the JOSM search expression josmSearchExpression. josmSearchExpression is a string as you would enter it in the JOSM search dialog. options is an (optional) object with named parameters, see below. query(predicate,?options) Queries the dataset using a javascript predicate function predicate. predicate is a javascript function which accepts a object as parameter and replies true, when it matches for the object ans false otherwise. options is an (optional) object with named parameters, see below. The parameter options consist of the following (optional) named parameters: allElements : boolean (Deprecated parameter names: all) If true, searches all objects in the dataset. If false, ignores incomplete or deleted objects. Default: false. caseSensitive : boolean Only applicable for searches with a JOSM search expression. If true, searches case sensitive. If false, searches case insensitive. Default: false. regexSearch : boolean (Deprecated parameter names: withRegexp, regexpSearch) Only applicable for searches with a JOSM search expression. If true, the search expression contains regular expressions. If false, it includes only plain strings for searching. Default: false. mapCSSSearch Only applies for searches with a JOSM search expression. Default: false. Parameters: Name Type Argument Description expression string | function the match expression options object &lt;optional&gt; additional named parameters Source: josm/ds.mjs, line 773 Example import { DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil() // add or load primitives to query // ... // query restaurants const result1 = dsutil.query('amenity=restaurant') // query all nodes with a type query const result2 = dsutil.query('type:node') // query using a custom predicate - all primitives // with exactly two tags const result3 = dsutil.query((primitive) =&gt; { primitive.getKeys().size() === 2 }) relation(id) Replies the relation with id id. Parameters: Name Type Description id number the unique numeric id. Must not be 0. Source: josm/ds.mjs, line 307 Returns: the relation Type Relation Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) // get a relation const r = dsutil.relation(1234) remove(args) Removes objects from the dataset Signatures remove(id, type) Removes a single object given by its unique numeric ID (nid) and a type. The type is either a string \"node\", \"way\", or \"relation\", or one of the symbols OsmPrimitiveType.NODE, OsmPrimitiveType.WAY, or OsmPrimitiveType.RELATION. remove(id, id, ...) Removes a collection of objects given by the ids. id is either an instance of PrimitiveId or an object with the properties id and type, i.e. {id: 1234, type: \"node\"}. null and undefined are ignored. remove(array|collection) Removes a collection of objects given by the an array or a java.util.Collection of ids. The collection elemeents are either instances of PrimitiveId or an object with the properties id and type, i.e. {id: 1234, type: \"node\"}. null or undefined elements are ignored. Parameters: Name Type Description args see description Source: josm/ds.mjs, line 404 Example import { DataSet, DataSetUtil, OsmPrimitiveType, buildId} from 'josm/ds' const HashSet = Java.type('java.util.HashSet') const dsutil = new DataSetUtil(new DataSet()) // remove a node with a global id dsutil.remove(1234, 'node') // remove a node and a way const id1 = buildId(1234, 'node') const id2 = buildId(3333, OsmPrimitiveType.WAY) dsutil.remove(id1, id2) // remove a relation and a node dsutil.remove({id: 1234, type: 'relation'}, id1) // remove an array of nodes dsutil.remove([id1,id2]) // remove a set of primitives const ids = new HashSet() ids.add(id1) ids.add(id1) dsutil.remove(ids) save(target [, options]) Saves the dataset to a file (in OSM XML format). options can contain the following named options: version: string the value of the attribute version in the OSM file header. Default: \"0.6\" changeset: Changeset the changeset whose id is included in the attribute changeset on every OSM object. If undefined, includes the individual changeset attribute of the OSM object. Default: undefined osmConform: bool if true, prevents modification attributes to be written Default: true Parameters: Name Type Argument Description target string | File the target file options object &lt;optional&gt; optional named parameters Source: josm/ds.mjs, line 641 Example import { DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil() // create a node in the dataset dsutil.nodeBuilder() .withId(1, 1) .withPosition({ lat: 1.0, lon: 1.0 }) .create() // save the dataset dsutil.save('/tmp/my-dataset.osm') way(id) Replies the way with id id, or null Parameters: Name Type Description id number the unique numeric id. Must not be 0. Source: josm/ds.mjs, line 289 Returns: the way Type Way Example import { DataSet, DataSetUtil } from 'josm/ds' const dsutil = new DataSetUtil(new DataSet()) // get a way const w = dsutil.way(1234) Ã— Search results Close "},"module-josm_layers.html":{"id":"module-josm_layers.html","title":"Module: josm/layers","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/layers Provides access to the JOSM layers. Source: josm/layers.mjs, line 1 Classes Layers Members &lt;inner, constant&gt; layers the singleton instance of the layers class Source: josm/layers.mjs, line 304 Ã— Search results Close "},"module-josm_layers.Layers.html":{"id":"module-josm_layers.Layers.html","title":"Class: Layers","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: Layers josm/layers. Layers Provides access to JOSM layers. new Layers() Source: josm/layers.mjs, line 20 Members activeLayer : Layer Set or get the active layer. get Replies the active layer or undefined. set Assign either an existing Layer, the name of a layer as string, or a layer index as number. Type: Layer Source: josm/layers.mjs, line 46 &lt;readonly&gt; length : number Replies the number of currently open layers. Type: number Source: josm/layers.mjs, line 28 Methods add(obj) Adds a layer. Either pass in a layer object or a data set. In the later case, an OsmDataLayer is automatically created. Parameters: Name Type Description obj Layer | DataSet a layer to add, or a dataset. Ignored if null or undefined. Source: josm/layers.mjs, line 175 Returns: the added layer Type Layer Example import layers from 'josm/layers' const OsmDataLayer = Java.type('org.openstreetmap.josm.gui.layer.OsmDataLayer') const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') const dataLayer = new OsmDataLayer(new DataSet(), null, null); // add a layer ... layers.add(dataLayer) // or add a dataset, which will create a data layer const ds = new DataSet() layer.add(ds) addDataLayer(args) Creates and adds a new data layer. The new layer becomes the new edit layer. Signatures addDataLayer() create data layer with a new dataset and default name addDataLayer(ds) create data layer with dataset ds and default name addDataLayer(name) create data layer with a new dataset and name name addDataLayer({name: ..., ds: ...}) create data layer with a new dataset and name name Parameters: Name Type Description args string | DataSet | object see description Source: josm/layers.mjs, line 267 Returns: the added layer Type OsmDataLayer Example import josm from 'josm' const DataSet = Java.type('org.openstreetmap.josm.data.osm.DataSet') // creates a new data layer const l1 = josm.layers.addDataLayer() // creates a new data layer with name 'test' const l2 = josm.layers.addDataLayer('test') // creates a new data layer for the dataset ds const ds = new DataSet() const l3 = josm.layers.addDataLayer(ds) get(key) Replies one of the layers given a key. If key is a number, replies the layer with index key, or undefined, if no layer for this index exists. If key is a string, replies the first layer whose name is identical to key (case insensitive, without leading/trailing whitespace), or undefined, if no layer with such a name exists. Parameters: Name Type Description key number | string the key to retrieve the layer Source: josm/layers.mjs, line 106 Returns: Type Layer Example import layers from 'josm/layers' // get the first layer const layer1 = layers.get(0) // get the first layer with name \"data layer\" const layer2 = layers.get('data layer') has(layer) Checks whether layer is a currently registered layer. Parameters: Name Type Description layer Layer | string | number a layer, a layer name, or a layer index Source: josm/layers.mjs, line 135 Returns: true, if the layer or at least one layer with the given name exists. False, otherwise. Type boolean Example import layers from 'josm/layers' // is there a layer with name \"my layer\"? let b = layers.has('my layer') // is there a layer at index position 2 b = layers.has(2) // is there a specific layer? let l = layers.get(0) b = layers.has(l) remove(key) Removes a layer with the given key. If key is a Number, removes the layer with the index key. If the index doesn't isn't a valid layer index, nothing is removed. If key is a string, removes the layer with the name key. Leading and trailing white space is removed, matching is a case-insensitive sub-string match. Parameters: Name Type Description key number | string indicates the layer to remove Source: josm/layers.mjs, line 222 Example import josm from 'josm' // remove the first layer josm.layers.remove(0) // remove the first layer matching with the supplied name josm.layers.remove('myLayerName') Ã— Search results Close "},"module-josm_scriptingconsole.html":{"id":"module-josm_scriptingconsole.html","title":"Module: josm/scriptingconsole","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/scriptingconsole Provides a set of functions to write to the built-in scripting console. Source: josm/scriptingconsole.mjs, line 1 Methods &lt;static&gt; clear() Clears the scripting console. Source: josm/scriptingconsole.mjs, line 90 Example import * as console from 'josm/scriptingconsole' console.clear() &lt;static&gt; hide() Hides the scripting console Source: josm/scriptingconsole.mjs, line 113 Example import * as console from 'josm/scriptingconsole' console.hide() &lt;static&gt; print(message [, values]) Prints a string to the console Parameters: Name Type Argument Description message string the message values object &lt;optional&gt; &lt;repeatable&gt; optional values Source: josm/scriptingconsole.mjs, line 31 Example import {print} from 'josm/scriptingconsole' print('Hello world!') // or use formatting print('Hello world! My name is {0}', 'foo') &lt;static&gt; println(message [, values]) Prints a string to the console, including newline Parameters: Name Type Argument Description message string the message values object &lt;optional&gt; &lt;repeatable&gt; optional values Source: josm/scriptingconsole.mjs, line 63 Example import {println} from 'josm/scriptingconsole' println('Hello world!') // or use formatting println('Hello world! My name is {0}', 'foo') &lt;static&gt; show() Shows the scripting console Source: josm/scriptingconsole.mjs, line 102 Example import * as console from 'josm/scriptingconsole' console.show() &lt;static&gt; toggle() Toggles the visibility of the scripting console Source: josm/scriptingconsole.mjs, line 124 Example import * as console from 'josm/scriptingconsole' console.toggle() Ã— Search results Close "},"module-josm_ui_menu.html":{"id":"module-josm_ui_menu.html","title":"Module: josm/ui/menu","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/ui/menu Provides a collection of namespaces, classes and functions to work with JOSMs menu system. Source: josm/ui/menu.mjs, line 1 Example import {JSAction} from 'josm/ui/menu' Classes MenuBar Members &lt;static, constant&gt; JSAction JSAction is an action for which a menu item or a toolbar item can be added to JOSMs menu or JOSMs toolbar respectively. This is just a shortcut for the Java class JSAction. The constructor accepts an object with {@link module:josm/ui/menu~JSActionOptions named parameters}. Properties: Name Type Description JSAction JSAction Source: josm/ui/menu.mjs, line 190 Example import {JSAction} from 'josm/ui/menu' import * as util from 'josm/util' import josm from 'josm' const JMenuItem = Java.type('javax.swing.JMenuItem') // create the menu action const helloWorldAction = new JSAction({ name: \"My Action\", iconName: 'myicon', toolbarId: 'myToolbarId', tooltip: \"This is my action\", onInitEnabled: function() { util.println('onInitEnabled: entering ...') }, onUpdateEnabled: function() { util.println('onUpdateEnabled: entering ...') }, onExecute: function() { util.println('Hello World!') } }) // register a new menu item in the file menu const fileMenu = josm.menu.get('file') fileMenu.addSeparator() fileMenu.add(new JMenuItem(helloWorldAction)) Type Definitions JSActionCallback() Callback type for JSAction Source: josm/ui/menu.mjs, line 123 JSActionOptions The named options for building a JSAction. Properties: Name Type Argument Default Description name string &lt;optional&gt; The optional name of the action. Default: an auto generated name tooltip string &lt;optional&gt; The optional tooltip of the action. Default: empty string iconName string &lt;optional&gt; The optional name of an icon. Default: null toolbarId string &lt;optional&gt; The optional name of the tooblar to which this action is added. Note that it isn't added automatically, when this action is created. Default: null. onExecute module:josm/ui/menu~JSActionCallback &lt;optional&gt; null The optional function which is called when the action is executed. Default: null. onInitEnabled module:josm/ui/menu~JSActionCallback &lt;optional&gt; null The optional function which is called when the enabled state of the function is evaluated the first time. Default: null. onUpdateEnabled module:josm/ui/menu~JSActionCallback &lt;optional&gt; null The (optional) function which is called when the enabled state of the function is reevaluated, in particular, when layer change events or selection change events occur. Default: null. Source: josm/ui/menu.mjs, line 129 Ã— Search results Close "},"module-josm_ui_menu-MenuBar.html":{"id":"module-josm_ui_menu-MenuBar.html","title":"Class: MenuBar","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: MenuBar josm/ui/menu~ MenuBar new MenuBar() Represents JOSMs global menu bar. Source: josm/ui/menu.mjs, line 16 Members &lt;static&gt; length the number of menus in the JOSM menu bar Replies the number of menus in the JOSM menu bar. Properties: Name Type Description length number the number of menues Source: josm/ui/menu.mjs, line 24 Example import josm from 'josm' // display the number of menus josm.alert(josm.menu.length) &lt;static, readonly&gt; menuNames Replies an array with the symbolic menu names. Replies an array with the symbolic menu names. Properties: Name Type Description menuNames array the names of the menues in the menu bar Source: josm/ui/menu.mjs, line 105 Methods &lt;static&gt; get(key) Replies a menu in the JOSM menu bar. Replies a menu in the JOSM menu bar. key is either a numberic index or one of the following symbolic names as string: file edit view tools presets imagery window help Parameters: Name Type Description key number | string the key denoting the menu Source: josm/ui/menu.mjs, line 46 Returns: the menu Type JMenu Example import josm from 'josm' // get the edit menu with a numeric index const editMenu = josm.menu.get(1) // get the file menu with a symbolic name const fileMenu = josm.menu.get('file') Ã— Search results Close "},"module-josm_unittest.html":{"id":"module-josm_unittest.html","title":"Module: josm/unittest","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/unittest Source: josm/unittest.mjs, line 1 Ã— Search results Close "},"module-josm_util.html":{"id":"module-josm_util.html","title":"Module: josm/util","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Module: josm/util Provides a set of static utility functions. Source: josm/util.mjs, line 1 Methods &lt;static&gt; assert(condition [, message] [, values]) Assert a condition and throw an Error if the condition isn't met. Assert a condition and throw an Error if the condition isn't met. Usage: assert() Does nothing assert(cond) Checks the condition cond. If it is false, throws an Error. assert(cond, msg) Checks the condition cond. If it is false, throws an Error, whose description property is set to msg. assert(cond, msg, objs...) Checks the condition cond. If it is false, throws an Error, whose description property is set to the formatted message msg. Internally uses java.text.MessageFormat to format the message. Parameters: Name Type Argument Description condition boolean message string &lt;optional&gt; the message values object &lt;optional&gt; &lt;repeatable&gt; an optional list of values Source: josm/util.mjs, line 58 Example import {assert} from 'josm/util' // throws an Error assert(false) // throws an Error e, with e.description == \"My message\" assert(false, \"My message\") // throws an Error e, with e.description == \"My message: test\" assert(false, \"My message: {0}\", \"test\") &lt;static&gt; assertNumber(value [, msg] [, values]) Asserts that val is a number. Asserts that val is a number. Parameters: Name Type Argument Description value Anything the value to check msg String &lt;optional&gt; message if the assertion fails values object &lt;optional&gt; &lt;repeatable&gt; values used in msg placeholders Source: josm/util.mjs, line 169 &lt;static&gt; assertSomething(val [, msg] [, values]) Asserts that val is defined and non-null. Asserts that val is defined and non-null. Parameters: Name Type Argument Description val any the value to check msg string &lt;optional&gt; message if the assertion fails values object &lt;optional&gt; &lt;repeatable&gt; additional values used in msg placeholders Source: josm/util.mjs, line 136 Example import {assertSomething} from 'josm/util' assertSomething(null) // -&gt; throws an exception assertSomething(void 0) // -&gt; throws an exception assertSomting(\"test\") // -&gt; OK assertSomething(5) // -&gt; OK &lt;static&gt; countProperties(o) Replies the number of properties owned by o. Replies the number of properties owned by o. Parameters: Name Type Description o any the object Source: josm/util.mjs, line 262 Returns: the number of properties owned by o. Type number Example import {countProperties} from 'josm/util' let o = {p1: \"v1\", p2: \"v2\"} let c = countProperties(o) // -&gt; 2 o = {} c = countProperties(o) // -&gt; 0 o = undefined c = countProperties(o) // -&gt; undefined &lt;static&gt; each(collection, delegate) Iteraties over the elements of a collection Iterates over the elements in collection and invokes delegate() on each element. Parameters: Name Type Description collection array | arguments | Collection the collection of elements delegate function the function to call on each elemennt Source: josm/util.mjs, line 442 &lt;static&gt; hasProperties(o) Replies true, if o owns at least one property. Replies true, if o owns at least one property. Parameters: Name Type Description o any the object Source: josm/util.mjs, line 294 Returns: true, if o owns at least one property. Type boolean Example import {hasProperties} from 'josm/util' let o = {p1: \"v1\", p2: \"v2\"} let c = hasProperties(o) // -&gt; true o = {} c = hasProperties(o) // -&gt; false o = undefined c = hasProperties(o) // -&gt; false &lt;static&gt; isArguments(value) Replies true if val is a list of arguments. Replies true if val is a list of arguments. Parameters: Name Type Description value anything the value to check Source: josm/util.mjs, line 248 Returns: true, if val is a list of arguments Type boolean &lt;static&gt; isArray(value) Replies true if val is an array. Replies true if val is an array. Parameters: Name Type Description value anything the value to check Source: josm/util.mjs, line 234 Returns: true, if val is an array Type boolean &lt;static&gt; isCollection(value) Is a value a collection? Replies true, if a value is an array, an arguments list or a Java collection. Parameters: Name Type Description value object the value to check Source: josm/util.mjs, line 468 Returns: true, if value is a collection Type boolean &lt;static&gt; isDef(value) Returns true if val is defined. Returns true if val is defined. Parameters: Name Type Description value any the value to check Source: josm/util.mjs, line 191 Returns: true if val is defined Type boolean &lt;static&gt; isFunction(f) Replies true, if f is a function. Replies true, if f is a function. Parameters: Name Type Description f any the object Source: josm/util.mjs, line 322 Returns: true, if f is a function. Type boolean &lt;static&gt; isNumber(value) Returns true if val is a number. Returns true if val is a number. Parameters: Name Type Description value any the value to check Source: josm/util.mjs, line 205 Returns: true if val is a number Type boolean &lt;static&gt; isString(value) Returns true if val is a string. Returns true if val is a string. Parameters: Name Type Description value any the value to check Source: josm/util.mjs, line 219 Returns: true, if val is a string or a String object Type boolean &lt;static&gt; javaEquals(o1, o2) Are two java objects equal. Checks whether two java objects are either both null or equal by calling o1.equals(o2). Parameters: Name Type Description o1 object a java object or null o2 object a java object or null Source: josm/util.mjs, line 422 Returns: Type boolean &lt;static&gt; mix() Mixes the properties of a list of objects into one object. Mixes the properties of a list of objects into one object. Source: josm/util.mjs, line 336 Returns: a new object which includes the combined properties of the argument objects Type object &lt;static&gt; print(message [, args]) Prints a message to stdout (without newline). Prints a message to stdout (without newline). Supports the same string templates as MessageFormat Parameters: Name Type Argument Description message string args object &lt;optional&gt; &lt;repeatable&gt; Source: josm/util.mjs, line 394 Example import * as util from 'josm/util' const myname = \"...\" util.print('Hello world! My name is {0}', myname) // escape meta characters like {, } or ' with a leading apostrophe util.print(\" a pair of curly braces '{'}\") &lt;static&gt; println(message [, args]) Prints a message to stdout (including newline). Prints a message to stdout (including newline). Supports the same string templates as MessageFormat. Parameters: Name Type Argument Description message string args object &lt;optional&gt; &lt;repeatable&gt; Source: josm/util.mjs, line 366 Example import * as util from 'josm/util' const myname = '...' util.println('Hello world! My name is {0}', myname); // escape meta characters like {, } or ' with a leading apostrophe util.println(\" a pair of curly braces '{'}\"); &lt;inner&gt; isNothing(value) Checks whether a value is null or undefined. Checks whether a value is null or undefined. Parameters: Name Type Description value object the value to check Source: josm/util.mjs, line 12 Returns: false, if value is null or undefined; true, otherwise Type boolean &lt;inner&gt; isSomething(value) Checks whether a value is neither null nor undefined. Checks whether a value is neither null nor undefined. Parameters: Name Type Description value object the value to check Source: josm/util.mjs, line 25 Returns: false, if value is null or undefined; true, otherwise Type boolean &lt;inner&gt; trim(s) Trims leading and trailing whitespace from s. Trims leading and trailing whitespace from s. Replies s, if s is null or undefined. Any other value is converted to a string, then leading and trailing white space is removed. Parameters: Name Type Description s string the string to be trimmed Source: josm/util.mjs, line 38 Returns: Type string Ã— Search results Close "},"NodeBuilder.exports.NodeBuilder.html":{"id":"NodeBuilder.exports.NodeBuilder.html","title":"Class: exports.NodeBuilder","body":" JOSM Scripting Plugin - JavaScript API V3 Modules clipboardjosmjosm/apijosm/builderjosm/builder/nodejosm/builder/relationjosm/builder/wayjosm/commandjosm/dsjosm/layersjosm/scriptingconsolejosm/ui/menujosm/unittestjosm/util Classes josm/api.Apijosm/api.ChangesetApijosm/api~ApiConfigjosm/builder/node~NodeBuilderjosm/builder/relation~RelationBuilderjosm/builder/way~WayBuilderjosm/builder/way~WayBuilder.WayBuilderjosm/command.AddCommandjosm/command.ChangeCommandjosm/command.CommandHistoryjosm/command.DeleteCommandjosm/ds.DataSetUtiljosm/layers.Layersjosm/ui/menu~MenuBarNodeBuilder.exports.NodeBuilder Class: exports.NodeBuilder exports.NodeBuilder new exports.NodeBuilder( [ds]) Creates a new node builder. Parameters: Name Type Argument Description ds DataSet &lt;optional&gt; the dataset to which created objects are added Source: josm/builder/node-builder.mjs, line 76 Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
